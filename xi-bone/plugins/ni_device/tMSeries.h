// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tMSeries_h___
#define ___tMSeries_h___

// includes
#ifndef ___nimdbg_tStatus2_h___
#include "tStatus2.h"
#endif

#include "osiBus.h"

class tMSeries
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg8IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u8 value,
         nMDBG::tStatus2* statusChain = NULL);
      
      inline u8 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };
   
   class tReg16IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u16 value,
         nMDBG::tStatus2* statusChain = NULL);
      
      inline u16 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };
   
   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);
      
      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };
   
   //---------------------------------------------------------------------------
   // AI_Command_1
   //---------------------------------------------------------------------------
   class tAI_Command_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x110,
         kId     = 0
      };
      tAI_Command_1();


      typedef enum {
         kRegisterId                          = 0,
         kAI_CONVERT_PulseId                  = 1,
         kAI_LOCALMUX_CLK_PulseId             = 3,
         kAI_EXTMUX_CLK_PulseId               = 4,
         kAI_SCAN_IN_PROG_PulseId             = 5,
         kAI_SC_LoadId                        = 6,
         kAI_SC_ArmId                         = 7,
         kAI_DIV_LoadId                       = 8,
         kAI_DIV_ArmId                        = 9,
         kAI_SI_LoadId                        = 10,
         kAI_SI_ArmId                         = 11,
         kAI_SI2_LoadId                       = 12,
         kAI_SI2_ArmId                        = 13,
         kAI_DisarmId                         = 14,
         kAI_Analog_Trigger_ResetId           = 15
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Command_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Command_1& setAI_CONVERT_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_CONVERT_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_CONVERT_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_CONVERT_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_LOCALMUX_CLK_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_LOCALMUX_CLK_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_LOCALMUX_CLK_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_LOCALMUX_CLK_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_EXTMUX_CLK_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_EXTMUX_CLK_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_EXTMUX_CLK_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_EXTMUX_CLK_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SCAN_IN_PROG_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SCAN_IN_PROG_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SCAN_IN_PROG_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SCAN_IN_PROG_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_DIV_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_DIV_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_DIV_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_DIV_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_DIV_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_DIV_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_DIV_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_DIV_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SI_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SI_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SI2_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI2_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI2_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI2_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_SI2_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI2_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI2_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI2_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Disarm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Disarm(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_1& setAI_Analog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Analog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Analog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Analog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Command_2
   //---------------------------------------------------------------------------
   class tAI_Command_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x108,
         kId     = 1
      };
      tAI_Command_2();


      typedef enum {
         kRegisterId                          = 0,
         kAI_START1_PulseId                   = 1,
         kAI_START2_PulseId                   = 2,
         kAI_START_PulseId                    = 3,
         kAI_STOP_PulseId                     = 4,
         kAI_SC_Switch_Load_On_TCId           = 5,
         kAI_SI_Switch_Load_On_TCId           = 8,
         kAI_SI_Switch_Load_On_STOPId         = 9,
         kAI_SI_Switch_Load_On_SC_TCId        = 10,
         kAI_SC_Save_TraceId                  = 11,
         kAI_START1_DisableId                 = 12,
         kAI_End_On_End_Of_ScanId             = 15,
         kAI_End_On_SC_TCId                   = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Command_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Command_2& setAI_START1_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START1_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START1_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_START2_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START2_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START2_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_START_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_STOP_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_STOP_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_STOP_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_SC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_SI_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_SI_Switch_Load_On_STOP(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Switch_Load_On_STOP(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Switch_Load_On_STOP(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Switch_Load_On_STOP(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_SI_Switch_Load_On_SC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Switch_Load_On_SC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Switch_Load_On_SC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Switch_Load_On_SC_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_SC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Save_Trace(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_Save_Trace(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_START1_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START1_Disable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START1_Disable(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_End_On_End_Of_Scan(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_End_On_End_Of_Scan(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_End_On_End_Of_Scan(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_End_On_End_Of_Scan(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Command_2& setAI_End_On_SC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_End_On_SC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_End_On_SC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_End_On_SC_TC(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Mode_2
   //---------------------------------------------------------------------------
   class tAI_Mode_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x11a,
         kId     = 2
      };
      tAI_Mode_2();


      typedef enum {
         kRegisterId                          = 0,
         kAI_SC_Write_SwitchId                = 1,
         kAI_SC_Reload_ModeId                 = 2,
         kAI_SC_Initial_Load_SourceId         = 3,
         kAI_SI_Write_SwitchId                = 4,
         kAI_SI_Reload_ModeId                 = 5,
         kAI_SI_Initial_Load_SourceId         = 6,
         kAI_SI2_Reload_ModeId                = 7,
         kAI_SI2_Initial_Load_SourceId        = 8,
         kAI_External_MUX_PresentId           = 11,
         kAI_Pre_TriggerId                    = 12,
         kAI_Start_Stop_Gate_EnableId         = 13,
         kAI_SC_Gate_EnableId                 = 14
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Mode_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Mode_2& setAI_SC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SC_Reload_ModeNo_Change         = 0,
         kAI_SC_Reload_ModeSwitch            = 1,
      } tAI_SC_Reload_Mode;
      inline tAI_Mode_2& setAI_SC_Reload_Mode(tAI_SC_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SC_Reload_Mode getAI_SC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Reload_Mode(tAI_SC_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SC_Reload_Mode readAI_SC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SC_Initial_Load_SourceLoad_A            = 0,
         kAI_SC_Initial_Load_SourceLoad_B            = 1,
      } tAI_SC_Initial_Load_Source;
      inline tAI_Mode_2& setAI_SC_Initial_Load_Source(tAI_SC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SC_Initial_Load_Source getAI_SC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Initial_Load_Source(tAI_SC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SC_Initial_Load_Source readAI_SC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_2& setAI_SI_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SI_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI_Reload_ModeNo_Change         = 0,
         kAI_SI_Reload_ModeAlternate_First_Period_Every_STOP                   = 4,
         kAI_SI_Reload_ModeSwitch_Every_STOP   = 5,
         kAI_SI_Reload_ModeAlternate_First_Period_Every_SCTC                   = 6,
         kAI_SI_Reload_ModeSwitch_Every_SCTC   = 7,
      } tAI_SI_Reload_Mode;
      inline tAI_Mode_2& setAI_SI_Reload_Mode(tAI_SI_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI_Reload_Mode getAI_SI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Reload_Mode(tAI_SI_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI_Reload_Mode readAI_SI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI_Initial_Load_SourceLoad_A            = 0,
         kAI_SI_Initial_Load_SourceLoad_B            = 1,
      } tAI_SI_Initial_Load_Source;
      inline tAI_Mode_2& setAI_SI_Initial_Load_Source(tAI_SI_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI_Initial_Load_Source getAI_SI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Initial_Load_Source(tAI_SI_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI_Initial_Load_Source readAI_SI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI2_Reload_ModeNo_Change         = 0,
         kAI_SI2_Reload_ModeAlternate_First_Period_Every_STOP                   = 1,
      } tAI_SI2_Reload_Mode;
      inline tAI_Mode_2& setAI_SI2_Reload_Mode(tAI_SI2_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI2_Reload_Mode getAI_SI2_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI2_Reload_Mode(tAI_SI2_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI2_Reload_Mode readAI_SI2_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI2_Initial_Load_SourceLoad_A            = 0,
         kAI_SI2_Initial_Load_SourceLoad_B            = 1,
      } tAI_SI2_Initial_Load_Source;
      inline tAI_Mode_2& setAI_SI2_Initial_Load_Source(tAI_SI2_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI2_Initial_Load_Source getAI_SI2_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI2_Initial_Load_Source(tAI_SI2_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI2_Initial_Load_Source readAI_SI2_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_External_MUX_PresentEvery_Convert     = 0,
         kAI_External_MUX_PresentDIV_TC_Converts   = 1,
      } tAI_External_MUX_Present;
      inline tAI_Mode_2& setAI_External_MUX_Present(tAI_External_MUX_Present fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_External_MUX_Present getAI_External_MUX_Present(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_External_MUX_Present(tAI_External_MUX_Present fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_External_MUX_Present readAI_External_MUX_Present(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_2& setAI_Pre_Trigger(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Pre_Trigger(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Pre_Trigger(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Pre_Trigger(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_2& setAI_Start_Stop_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Start_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Start_Stop_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Start_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_2& setAI_SC_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_SC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_SC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Mode_3
   //---------------------------------------------------------------------------
   class tAI_Mode_3 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1ae,
         kId     = 3
      };
      tAI_Mode_3();


      typedef enum {
         kRegisterId                          = 0,
         kAI_External_Gate_SelectId           = 1,
         kAI_External_Gate_PolarityId         = 2,
         kAI_FIFO_ModeId                      = 3,
         kAI_External_Gate_ModeId             = 4,
         kAI_Delayed_START1Id                 = 5,
         kAI_Delayed_START2Id                 = 6,
         kAI_SI2_Source_SelectId              = 7,
         kAI_Software_GateId                  = 9,
         kAI_Delay_STARTId                    = 10,
         kAI_Trigger_LengthId                 = 11
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Mode_3& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAI_External_Gate_SelectDisabled          = 0,
         kAI_External_Gate_SelectPFI0              = 1,
         kAI_External_Gate_SelectPFI1              = 2,
         kAI_External_Gate_SelectPFI2              = 3,
         kAI_External_Gate_SelectPFI3              = 4,
         kAI_External_Gate_SelectPFI4              = 5,
         kAI_External_Gate_SelectPFI5              = 6,
         kAI_External_Gate_SelectPFI6              = 7,
         kAI_External_Gate_SelectPFI7              = 8,
         kAI_External_Gate_SelectPFI8              = 9,
         kAI_External_Gate_SelectPFI9              = 10,
         kAI_External_Gate_SelectRTSI0             = 11,
         kAI_External_Gate_SelectRTSI1             = 12,
         kAI_External_Gate_SelectRTSI2             = 13,
         kAI_External_Gate_SelectRTSI3             = 14,
         kAI_External_Gate_SelectRTSI4             = 15,
         kAI_External_Gate_SelectRTSI5             = 16,
         kAI_External_Gate_SelectRTSI6             = 17,
         kAI_External_Gate_SelectStar_Trigger      = 20,
         kAI_External_Gate_SelectPFI10             = 21,
         kAI_External_Gate_SelectPFI11             = 22,
         kAI_External_Gate_SelectPFI12             = 23,
         kAI_External_Gate_SelectPFI13             = 24,
         kAI_External_Gate_SelectPFI14             = 25,
         kAI_External_Gate_SelectPFI15             = 26,
         kAI_External_Gate_SelectRTSI7             = 27,
         kAI_External_Gate_SelectAnalog_Trigger    = 30,
         kAI_External_Gate_SelectLow               = 31,
      } tAI_External_Gate_Select;
      inline tAI_Mode_3& setAI_External_Gate_Select(tAI_External_Gate_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_External_Gate_Select getAI_External_Gate_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_External_Gate_Select(tAI_External_Gate_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_External_Gate_Select readAI_External_Gate_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_External_Gate_PolarityActive_High       = 0,
         kAI_External_Gate_PolarityActive_Low        = 1,
      } tAI_External_Gate_Polarity;
      inline tAI_Mode_3& setAI_External_Gate_Polarity(tAI_External_Gate_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_External_Gate_Polarity getAI_External_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_External_Gate_Polarity(tAI_External_Gate_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_External_Gate_Polarity readAI_External_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_FIFO_ModeNot_Empty         = 0,
         kAI_FIFO_ModeHalf_Full         = 1,
         kAI_FIFO_ModeFull              = 2,
         kAI_FIFO_ModeHalf_Full_Until_Empty       = 3,
      } tAI_FIFO_Mode;
      inline tAI_Mode_3& setAI_FIFO_Mode(tAI_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_FIFO_Mode getAI_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_FIFO_Mode(tAI_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_FIFO_Mode readAI_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_External_Gate_ModeFree_Run          = 0,
         kAI_External_Gate_ModeHalt_Gating       = 1,
      } tAI_External_Gate_Mode;
      inline tAI_Mode_3& setAI_External_Gate_Mode(tAI_External_Gate_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_External_Gate_Mode getAI_External_Gate_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_External_Gate_Mode(tAI_External_Gate_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_External_Gate_Mode readAI_External_Gate_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_3& setAI_Delayed_START1(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Delayed_START1(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Delayed_START1(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Delayed_START1(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_3& setAI_Delayed_START2(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Delayed_START2(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Delayed_START2(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Delayed_START2(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI2_Source_SelectSame_As_SI        = 0,
         kAI_SI2_Source_SelectINTIMEBASE1       = 1,
      } tAI_SI2_Source_Select;
      inline tAI_Mode_3& setAI_SI2_Source_Select(tAI_SI2_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI2_Source_Select getAI_SI2_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI2_Source_Select(tAI_SI2_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI2_Source_Select readAI_SI2_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_3& setAI_Software_Gate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Software_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Software_Gate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Software_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_3& setAI_Delay_START(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Delay_START(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Delay_START(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Delay_START(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_3& setAI_Trigger_Length(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Trigger_Length(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Trigger_Length(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Trigger_Length(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Personal
   //---------------------------------------------------------------------------
   class tAI_Personal : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x19a,
         kId     = 4
      };
      tAI_Personal();


      typedef enum {
         kRegisterId                          = 0,
         kAI_EXTMUX_CLK_Pulse_WidthId         = 7,
         kAI_CONVERT_Pulse_WidthId            = 11
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Personal& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAI_EXTMUX_CLK_Pulse_Width45_Clock_Periods  = 0,
         kAI_EXTMUX_CLK_Pulse_WidthEq_LOCALMUX_CLK_Pulse_Width             = 1,
      } tAI_EXTMUX_CLK_Pulse_Width;
      inline tAI_Personal& setAI_EXTMUX_CLK_Pulse_Width(tAI_EXTMUX_CLK_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_EXTMUX_CLK_Pulse_Width getAI_EXTMUX_CLK_Pulse_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_EXTMUX_CLK_Pulse_Width(tAI_EXTMUX_CLK_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_EXTMUX_CLK_Pulse_Width readAI_EXTMUX_CLK_Pulse_Width(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_CONVERT_Pulse_WidthAbout_2_Clock_Periods       = 0,
         kAI_CONVERT_Pulse_WidthAbout_1_Clock_Period      = 1,
      } tAI_CONVERT_Pulse_Width;
      inline tAI_Personal& setAI_CONVERT_Pulse_Width(tAI_CONVERT_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_CONVERT_Pulse_Width getAI_CONVERT_Pulse_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_CONVERT_Pulse_Width(tAI_CONVERT_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_CONVERT_Pulse_Width readAI_CONVERT_Pulse_Width(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Output_Control
   //---------------------------------------------------------------------------
   class tAI_Output_Control : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x178,
         kId     = 5
      };
      tAI_Output_Control();


      typedef enum {
         kRegisterId                          = 0,
         kAI_CONVERT_Output_SelectId          = 1,
         kAI_EXTMUX_CLK_Output_SelectId       = 6,
         kAI_SCAN_IN_PROG_Output_SelectId     = 7,
         kAI_START_Output_SelectId            = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Output_Control& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAI_CONVERT_Output_SelectHigh_Z            = 0,
         kAI_CONVERT_Output_SelectGround            = 1,
         kAI_CONVERT_Output_SelectActive_Low        = 2,
         kAI_CONVERT_Output_SelectActive_High       = 3,
      } tAI_CONVERT_Output_Select;
      inline tAI_Output_Control& setAI_CONVERT_Output_Select(tAI_CONVERT_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_CONVERT_Output_Select getAI_CONVERT_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_CONVERT_Output_Select(tAI_CONVERT_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_CONVERT_Output_Select readAI_CONVERT_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_EXTMUX_CLK_Output_SelectHigh_Z            = 0,
         kAI_EXTMUX_CLK_Output_SelectGround            = 1,
         kAI_EXTMUX_CLK_Output_SelectActive_Low        = 2,
         kAI_EXTMUX_CLK_Output_SelectActive_High       = 3,
      } tAI_EXTMUX_CLK_Output_Select;
      inline tAI_Output_Control& setAI_EXTMUX_CLK_Output_Select(tAI_EXTMUX_CLK_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_EXTMUX_CLK_Output_Select getAI_EXTMUX_CLK_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_EXTMUX_CLK_Output_Select(tAI_EXTMUX_CLK_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_EXTMUX_CLK_Output_Select readAI_EXTMUX_CLK_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SCAN_IN_PROG_Output_SelectHigh_Z            = 0,
         kAI_SCAN_IN_PROG_Output_SelectGround            = 1,
         kAI_SCAN_IN_PROG_Output_SelectActive_Low        = 2,
         kAI_SCAN_IN_PROG_Output_SelectActive_High       = 3,
      } tAI_SCAN_IN_PROG_Output_Select;
      inline tAI_Output_Control& setAI_SCAN_IN_PROG_Output_Select(tAI_SCAN_IN_PROG_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SCAN_IN_PROG_Output_Select getAI_SCAN_IN_PROG_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SCAN_IN_PROG_Output_Select(tAI_SCAN_IN_PROG_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SCAN_IN_PROG_Output_Select readAI_SCAN_IN_PROG_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_START_Output_SelectAD_START          = 0,
         kAI_START_Output_SelectSCAN_IN_PROG      = 1,
      } tAI_START_Output_Select;
      inline tAI_Output_Control& setAI_START_Output_Select(tAI_START_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START_Output_Select getAI_START_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Output_Select(tAI_START_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_Output_Select readAI_START_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SC_Load_A
   //---------------------------------------------------------------------------
   class tAI_SC_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x124,
         kId     = 6
      };
      tAI_SC_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SC_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SC_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SC_Load_B
   //---------------------------------------------------------------------------
   class tAI_SC_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x128,
         kId     = 7
      };
      tAI_SC_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SC_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SC_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SC_Save
   //---------------------------------------------------------------------------
   class tAI_SC_Save : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x184,
         kId     = 8
      };
      tAI_SC_Save();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAI_SC_Save& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SC_Save& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SI_Load_A
   //---------------------------------------------------------------------------
   class tAI_SI_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x11c,
         kId     = 9
      };
      tAI_SI_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SI_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SI_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SI_Load_B
   //---------------------------------------------------------------------------
   class tAI_SI_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x120,
         kId     = 10
      };
      tAI_SI_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SI_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SI_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SI_Save
   //---------------------------------------------------------------------------
   class tAI_SI_Save : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x180,
         kId     = 11
      };
      tAI_SI_Save();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAI_SI_Save& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SI_Save& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SI2_Load_A
   //---------------------------------------------------------------------------
   class tAI_SI2_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x12c,
         kId     = 12
      };
      tAI_SI2_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SI2_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SI2_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_SI2_Load_B
   //---------------------------------------------------------------------------
   class tAI_SI2_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x130,
         kId     = 13
      };
      tAI_SI2_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_SI2_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_SI2_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_START_STOP_Select
   //---------------------------------------------------------------------------
   class tAI_START_STOP_Select : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x17c,
         kId     = 14
      };
      tAI_START_STOP_Select();


      typedef enum {
         kRegisterId                          = 0,
         kAI_START_SelectId                   = 1,
         kAI_START_EdgeId                     = 2,
         kAI_START_SyncId                     = 3,
         kAI_STOP_SelectId                    = 4,
         kAI_STOP_EdgeId                      = 5,
         kAI_STOP_SyncId                      = 6,
         kAI_STOP_PolarityId                  = 7,
         kAI_START_PolarityId                 = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_START_STOP_Select& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAI_START_SelectSI_TC             = 0,
         kAI_START_SelectPFI0              = 1,
         kAI_START_SelectPFI1              = 2,
         kAI_START_SelectPFI2              = 3,
         kAI_START_SelectPFI3              = 4,
         kAI_START_SelectPFI4              = 5,
         kAI_START_SelectPFI5              = 6,
         kAI_START_SelectPFI6              = 7,
         kAI_START_SelectPFI7              = 8,
         kAI_START_SelectPFI8              = 9,
         kAI_START_SelectPFI9              = 10,
         kAI_START_SelectRTSI0             = 11,
         kAI_START_SelectRTSI1             = 12,
         kAI_START_SelectRTSI2             = 13,
         kAI_START_SelectRTSI3             = 14,
         kAI_START_SelectRTSI4             = 15,
         kAI_START_SelectRTSI5             = 16,
         kAI_START_SelectRTSI6             = 17,
         kAI_START_SelectPulse             = 18,
         kAI_START_SelectGPCtr0_Out        = 19,
         kAI_START_SelectStar_Trigger      = 20,
         kAI_START_SelectPFI10             = 21,
         kAI_START_SelectPFI11             = 22,
         kAI_START_SelectPFI12             = 23,
         kAI_START_SelectPFI13             = 24,
         kAI_START_SelectPFI14             = 25,
         kAI_START_SelectPFI15             = 26,
         kAI_START_SelectRTSI7             = 27,
         kAI_START_SelectGPCtr1_Out        = 28,
         kAI_START_SelectSCXI_Trig1        = 29,
         kAI_START_SelectAnalog_Trigger    = 30,
         kAI_START_SelectLow               = 31,
      } tAI_START_Select;
      inline tAI_START_STOP_Select& setAI_START_Select(tAI_START_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START_Select getAI_START_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Select(tAI_START_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_Select readAI_START_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_STOP_Select& setAI_START_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_STOP_Select& setAI_START_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START_Sync(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_STOP_SelectDIV_TC_Or_Pulse   = 0,
         kAI_STOP_SelectPFI0              = 1,
         kAI_STOP_SelectPFI1              = 2,
         kAI_STOP_SelectPFI2              = 3,
         kAI_STOP_SelectPFI3              = 4,
         kAI_STOP_SelectPFI4              = 5,
         kAI_STOP_SelectPFI5              = 6,
         kAI_STOP_SelectPFI6              = 7,
         kAI_STOP_SelectPFI7              = 8,
         kAI_STOP_SelectPFI8              = 9,
         kAI_STOP_SelectPFI9              = 10,
         kAI_STOP_SelectRTSI0             = 11,
         kAI_STOP_SelectRTSI1             = 12,
         kAI_STOP_SelectRTSI2             = 13,
         kAI_STOP_SelectRTSI3             = 14,
         kAI_STOP_SelectRTSI4             = 15,
         kAI_STOP_SelectRTSI5             = 16,
         kAI_STOP_SelectRTSI6             = 17,
         kAI_STOP_SelectSI2TC             = 18,
         kAI_STOP_SelectIN                = 19,
         kAI_STOP_SelectStar_Trigger      = 20,
         kAI_STOP_SelectPFI10             = 21,
         kAI_STOP_SelectPFI11             = 22,
         kAI_STOP_SelectPFI12             = 23,
         kAI_STOP_SelectPFI13             = 24,
         kAI_STOP_SelectPFI14             = 25,
         kAI_STOP_SelectPFI15             = 26,
         kAI_STOP_SelectRTSI7             = 27,
         kAI_STOP_SelectAnalog_Trigger    = 30,
         kAI_STOP_SelectLow               = 31,
      } tAI_STOP_Select;
      inline tAI_START_STOP_Select& setAI_STOP_Select(tAI_STOP_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_STOP_Select getAI_STOP_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Select(tAI_STOP_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_STOP_Select readAI_STOP_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_STOP_Select& setAI_STOP_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_STOP_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_STOP_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_STOP_Select& setAI_STOP_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_STOP_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_STOP_Sync(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_STOP_PolarityActive_High_Or_Rising_Edge            = 0,
         kAI_STOP_PolarityActive_Low_Or_Falling_Edge            = 1,
         kAI_STOP_PolarityActive_High       = 0,
         kAI_STOP_PolarityActive_Low        = 1,
         kAI_STOP_PolarityRising_Edge       = 0,
         kAI_STOP_PolarityFalling_Edge      = 1,
      } tAI_STOP_Polarity;
      inline tAI_START_STOP_Select& setAI_STOP_Polarity(tAI_STOP_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_STOP_Polarity getAI_STOP_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Polarity(tAI_STOP_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_STOP_Polarity readAI_STOP_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_START_PolarityActive_High_Or_Rising_Edge            = 0,
         kAI_START_PolarityActive_Low_Or_Falling_Edge            = 1,
         kAI_START_PolarityActive_High       = 0,
         kAI_START_PolarityActive_Low        = 1,
         kAI_START_PolarityRising_Edge       = 0,
         kAI_START_PolarityFalling_Edge      = 1,
      } tAI_START_Polarity;
      inline tAI_START_STOP_Select& setAI_START_Polarity(tAI_START_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START_Polarity getAI_START_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Polarity(tAI_START_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START_Polarity readAI_START_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Status_1
   //---------------------------------------------------------------------------
   class tAI_Status_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x104,
         kId     = 15
      };
      tAI_Status_1();


      typedef enum {
         kRegisterId                          = 0,
         kPass_Thru_0_Interrupt_StId          = 1,
         kAI_FIFO_Request_StId                = 2,
         kG0_Gate_Interrupt_StId              = 3,
         kG0_TC_StId                          = 4,
         kAI_STOP_StId                        = 5,
         kAI_START_StId                       = 6,
         kAI_SC_TC_StId                       = 7,
         kAI_START1_StId                      = 8,
         kAI_START2_StId                      = 9,
         kAI_SC_TC_Error_StId                 = 10,
         kAI_Overflow_StId                    = 11,
         kAI_Overrun_StId                     = 12,
         kAI_FIFO_Empty_StId                  = 13,
         kAI_FIFO_Half_Full_StId              = 14,
         kAI_FIFO_Full_StId                   = 15,
         kInterrupt_Group_A_StatusId          = 16
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAI_Status_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Status_1& setPass_Thru_0_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getPass_Thru_0_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readPass_Thru_0_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_FIFO_Request_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setG0_Gate_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG0_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readG0_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setG0_TC_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG0_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readG0_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_STOP_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_STOP_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_STOP_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_START_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_START_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_SC_TC_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_SC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_SC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_START1_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START1_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_START1_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_START2_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START2_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_START2_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_SC_TC_Error_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_SC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_SC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_Overflow_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Overflow_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_Overflow_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_Overrun_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Overrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_Overrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_FIFO_Empty_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_FIFO_Half_Full_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_FIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_FIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setAI_FIFO_Full_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAI_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Status_1& setInterrupt_Group_A_Status(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getInterrupt_Group_A_Status(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readInterrupt_Group_A_Status(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Analog_Trigger_Etc
   //---------------------------------------------------------------------------
   class tAnalog_Trigger_Etc : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x17a,
         kId     = 16
      };
      tAnalog_Trigger_Etc();


      typedef enum {
         kRegisterId                          = 0,
         kAnalog_Trigger_ModeId               = 1,
         kAnalog_Trigger_EnableId             = 2,
         kAnalog_Trigger_ResetId              = 4,
         kMisc_Counter_TCs_Output_EnableId    = 5,
         kGPFO_1_Output_SelectId              = 6,
         kGPFO_0_Output_SelectId              = 10,
         kGPFO_0_Output_EnableId              = 11,
         kGPFO_1_Output_EnableId              = 12
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAnalog_Trigger_Etc& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAnalog_Trigger_ModeLow_Window        = 0,
         kAnalog_Trigger_ModeHigh_Window       = 1,
         kAnalog_Trigger_ModeMiddle_Window     = 2,
         kAnalog_Trigger_ModeHigh_Hysteresis   = 4,
         kAnalog_Trigger_ModeLow_Hysteresis    = 6,
      } tAnalog_Trigger_Mode;
      inline tAnalog_Trigger_Etc& setAnalog_Trigger_Mode(tAnalog_Trigger_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAnalog_Trigger_Mode getAnalog_Trigger_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAnalog_Trigger_Mode(tAnalog_Trigger_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAnalog_Trigger_Mode readAnalog_Trigger_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAnalog_Trigger_EnableDisabled          = 0,
         kAnalog_Trigger_EnableEnabled           = 1,
      } tAnalog_Trigger_Enable;
      inline tAnalog_Trigger_Etc& setAnalog_Trigger_Enable(tAnalog_Trigger_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAnalog_Trigger_Enable getAnalog_Trigger_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAnalog_Trigger_Enable(tAnalog_Trigger_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAnalog_Trigger_Enable readAnalog_Trigger_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAnalog_Trigger_Etc& setAnalog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAnalog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAnalog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAnalog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tAnalog_Trigger_Etc& setMisc_Counter_TCs_Output_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getMisc_Counter_TCs_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeMisc_Counter_TCs_Output_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readMisc_Counter_TCs_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kGPFO_1_Output_SelectG_OUT             = 0,
         kGPFO_1_Output_SelectDIV_TC            = 1,
      } tGPFO_1_Output_Select;
      inline tAnalog_Trigger_Etc& setGPFO_1_Output_Select(tGPFO_1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tGPFO_1_Output_Select getGPFO_1_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGPFO_1_Output_Select(tGPFO_1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tGPFO_1_Output_Select readGPFO_1_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kGPFO_0_Output_SelectG_OUT             = 0,
         kGPFO_0_Output_SelectRTSI0             = 1,
         kGPFO_0_Output_SelectRTSI1             = 2,
         kGPFO_0_Output_SelectRTSI2             = 3,
         kGPFO_0_Output_SelectRTSI3             = 4,
         kGPFO_0_Output_SelectRTSI4             = 5,
         kGPFO_0_Output_SelectRTSI5             = 6,
         kGPFO_0_Output_SelectRTSI6             = 7,
      } tGPFO_0_Output_Select;
      inline tAnalog_Trigger_Etc& setGPFO_0_Output_Select(tGPFO_0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tGPFO_0_Output_Select getGPFO_0_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGPFO_0_Output_Select(tGPFO_0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tGPFO_0_Output_Select readGPFO_0_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kGPFO_0_Output_EnableInput             = 0,
         kGPFO_0_Output_EnableOutput            = 1,
      } tGPFO_0_Output_Enable;
      inline tAnalog_Trigger_Etc& setGPFO_0_Output_Enable(tGPFO_0_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tGPFO_0_Output_Enable getGPFO_0_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGPFO_0_Output_Enable(tGPFO_0_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tGPFO_0_Output_Enable readGPFO_0_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kGPFO_1_Output_EnableInput             = 0,
         kGPFO_1_Output_EnableOutput            = 1,
      } tGPFO_1_Output_Enable;
      inline tAnalog_Trigger_Etc& setGPFO_1_Output_Enable(tGPFO_1_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tGPFO_1_Output_Enable getGPFO_1_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGPFO_1_Output_Enable(tGPFO_1_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tGPFO_1_Output_Enable readGPFO_1_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Trigger_Select
   //---------------------------------------------------------------------------
   class tAI_Trigger_Select : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x17e,
         kId     = 17
      };
      tAI_Trigger_Select();


      typedef enum {
         kRegisterId                          = 0,
         kAI_START1_SelectId                  = 1,
         kAI_START1_EdgeId                    = 2,
         kAI_START1_SyncId                    = 3,
         kAI_START2_SelectId                  = 4,
         kAI_START2_EdgeId                    = 5,
         kAI_START2_SyncId                    = 6,
         kAI_START2_PolarityId                = 7,
         kAI_START1_PolarityId                = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Trigger_Select& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAI_START1_SelectPulse             = 0,
         kAI_START1_SelectPFI0              = 1,
         kAI_START1_SelectPFI1              = 2,
         kAI_START1_SelectPFI2              = 3,
         kAI_START1_SelectPFI3              = 4,
         kAI_START1_SelectPFI4              = 5,
         kAI_START1_SelectPFI5              = 6,
         kAI_START1_SelectPFI6              = 7,
         kAI_START1_SelectPFI7              = 8,
         kAI_START1_SelectPFI8              = 9,
         kAI_START1_SelectPFI9              = 10,
         kAI_START1_SelectRTSI0             = 11,
         kAI_START1_SelectRTSI1             = 12,
         kAI_START1_SelectRTSI2             = 13,
         kAI_START1_SelectRTSI3             = 14,
         kAI_START1_SelectRTSI4             = 15,
         kAI_START1_SelectRTSI5             = 16,
         kAI_START1_SelectRTSI6             = 17,
         kAI_START1_SelectGPCtr0_Out        = 18,
         kAI_START1_SelectGPCtr1_Out        = 19,
         kAI_START1_SelectStar_Trigger      = 20,
         kAI_START1_SelectPFI10             = 21,
         kAI_START1_SelectPFI11             = 22,
         kAI_START1_SelectPFI12             = 23,
         kAI_START1_SelectPFI13             = 24,
         kAI_START1_SelectPFI14             = 25,
         kAI_START1_SelectPFI15             = 26,
         kAI_START1_SelectRTSI7             = 27,
         kAI_START1_SelectAnalog_Trigger    = 30,
         kAI_START1_SelectLow               = 31,
      } tAI_START1_Select;
      inline tAI_Trigger_Select& setAI_START1_Select(tAI_START1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START1_Select getAI_START1_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Select(tAI_START1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START1_Select readAI_START1_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Trigger_Select& setAI_START1_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START1_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START1_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Trigger_Select& setAI_START1_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START1_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START1_Sync(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_START2_SelectPulse             = 0,
         kAI_START2_SelectPFI0              = 1,
         kAI_START2_SelectPFI1              = 2,
         kAI_START2_SelectPFI2              = 3,
         kAI_START2_SelectPFI3              = 4,
         kAI_START2_SelectPFI4              = 5,
         kAI_START2_SelectPFI5              = 6,
         kAI_START2_SelectPFI6              = 7,
         kAI_START2_SelectPFI7              = 8,
         kAI_START2_SelectPFI8              = 9,
         kAI_START2_SelectPFI9              = 10,
         kAI_START2_SelectRTSI0             = 11,
         kAI_START2_SelectRTSI1             = 12,
         kAI_START2_SelectRTSI2             = 13,
         kAI_START2_SelectRTSI3             = 14,
         kAI_START2_SelectRTSI4             = 15,
         kAI_START2_SelectRTSI5             = 16,
         kAI_START2_SelectRTSI6             = 17,
         kAI_START2_SelectStar_Trigger      = 20,
         kAI_START2_SelectPFI10             = 21,
         kAI_START2_SelectPFI11             = 22,
         kAI_START2_SelectPFI12             = 23,
         kAI_START2_SelectPFI13             = 24,
         kAI_START2_SelectPFI14             = 25,
         kAI_START2_SelectPFI15             = 26,
         kAI_START2_SelectRTSI7             = 27,
         kAI_START2_SelectAnalog_Trigger    = 30,
         kAI_START2_SelectLow               = 31,
      } tAI_START2_Select;
      inline tAI_Trigger_Select& setAI_START2_Select(tAI_START2_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START2_Select getAI_START2_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Select(tAI_START2_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START2_Select readAI_START2_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Trigger_Select& setAI_START2_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START2_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START2_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Trigger_Select& setAI_START2_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START2_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START2_Sync(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_START2_PolarityActive_High_Or_Rising_Edge            = 0,
         kAI_START2_PolarityActive_Low_Or_Falling_Edge            = 1,
         kAI_START2_PolarityActive_High       = 0,
         kAI_START2_PolarityActive_Low        = 1,
         kAI_START2_PolarityRising_Edge       = 0,
         kAI_START2_PolarityFalling_Edge      = 1,
      } tAI_START2_Polarity;
      inline tAI_Trigger_Select& setAI_START2_Polarity(tAI_START2_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START2_Polarity getAI_START2_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Polarity(tAI_START2_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START2_Polarity readAI_START2_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_START1_PolarityActive_High_Or_Rising_Edge            = 0,
         kAI_START1_PolarityActive_Low_Or_Falling_Edge            = 1,
         kAI_START1_PolarityActive_High       = 0,
         kAI_START1_PolarityActive_Low        = 1,
         kAI_START1_PolarityRising_Edge       = 0,
         kAI_START1_PolarityFalling_Edge      = 1,
      } tAI_START1_Polarity;
      inline tAI_Trigger_Select& setAI_START1_Polarity(tAI_START1_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_START1_Polarity getAI_START1_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Polarity(tAI_START1_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_START1_Polarity readAI_START1_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_BC_Load_A
   //---------------------------------------------------------------------------
   class tAO_BC_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x158,
         kId     = 18
      };
      tAO_BC_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_BC_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_BC_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_BC_Load_B
   //---------------------------------------------------------------------------
   class tAO_BC_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x15c,
         kId     = 19
      };
      tAO_BC_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_BC_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_BC_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_BC_Save
   //---------------------------------------------------------------------------
   class tAO_BC_Save : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x124,
         kId     = 20
      };
      tAO_BC_Save();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_BC_Save& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_BC_Save& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Command_2
   //---------------------------------------------------------------------------
   class tAO_Command_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x10a,
         kId     = 21
      };
      tAO_Command_2();


      typedef enum {
         kRegisterId                          = 0,
         kAO_START1_PulseId                   = 1,
         kAO_Mute_AId                         = 3,
         kAO_Mute_BId                         = 4,
         kAO_BC_Switch_Load_On_TCId           = 5,
         kAO_UC_Switch_Load_On_TCId           = 6,
         kAO_UC_Switch_Load_On_BC_TCId        = 7,
         kAO_UI_Switch_Load_On_TCId           = 8,
         kAO_UI_Switch_Load_On_StopId         = 9,
         kAO_UI_Switch_Load_On_BC_TCId        = 10,
         kAO_BC_Save_TraceId                  = 11,
         kAO_BC_Gate_EnableId                 = 12,
         kAO_UC_Save_TraceId                  = 13,
         kAO_Start_Stop_Gate_EnableId         = 14,
         kAO_End_On_UC_TCId                   = 15,
         kAO_End_On_BC_TCId                   = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Command_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Command_2& setAO_START1_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START1_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START1_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_Mute_A(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Mute_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Mute_A(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Mute_A(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_Mute_B(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Mute_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Mute_B(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Mute_B(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_BC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UC_Switch_Load_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Switch_Load_On_BC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Switch_Load_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Switch_Load_On_BC_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UI_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Switch_Load_On_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Switch_Load_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UI_Switch_Load_On_Stop(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Switch_Load_On_Stop(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Switch_Load_On_Stop(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Switch_Load_On_Stop(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UI_Switch_Load_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Switch_Load_On_BC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Switch_Load_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Switch_Load_On_BC_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_BC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Save_Trace(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Save_Trace(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_BC_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_BC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Gate_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_BC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_UC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Save_Trace(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Save_Trace(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Save_Trace(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_Start_Stop_Gate_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Start_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Start_Stop_Gate_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Start_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_End_On_UC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_End_On_UC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_End_On_UC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_End_On_UC_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_2& setAO_End_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_End_On_BC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_End_On_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_End_On_BC_TC(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Command_1
   //---------------------------------------------------------------------------
   class tAO_Command_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x112,
         kId     = 22
      };
      tAO_Command_1();


      typedef enum {
         kRegisterId                          = 0,
         kAO_UPDATE_PulseId                   = 1,
         kAO_DAC0_Update_ModeId               = 3,
         kAO_DAC1_Update_ModeId               = 5,
         kAO_BC_LoadId                        = 6,
         kAO_BC_ArmId                         = 7,
         kAO_UC_LoadId                        = 8,
         kAO_UC_ArmId                         = 9,
         kAO_UI_LoadId                        = 10,
         kAO_UI_ArmId                         = 11,
         kAO_DisarmId                         = 14,
         kAO_START_PulseId                    = 15,
         kAO_Analog_Trigger_ResetId           = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Command_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Command_1& setAO_UPDATE_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UPDATE_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UPDATE_Pulse(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_DAC0_Update_ModeImmediate         = 0,
         kAO_DAC0_Update_ModeTimed             = 1,
      } tAO_DAC0_Update_Mode;
      inline tAO_Command_1& setAO_DAC0_Update_Mode(tAO_DAC0_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_DAC0_Update_Mode getAO_DAC0_Update_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DAC0_Update_Mode(tAO_DAC0_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_DAC0_Update_Mode readAO_DAC0_Update_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_DAC1_Update_ModeImmediate         = 0,
         kAO_DAC1_Update_ModeTimed             = 1,
      } tAO_DAC1_Update_Mode;
      inline tAO_Command_1& setAO_DAC1_Update_Mode(tAO_DAC1_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_DAC1_Update_Mode getAO_DAC1_Update_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DAC1_Update_Mode(tAO_DAC1_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_DAC1_Update_Mode readAO_DAC1_Update_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_BC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_BC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_UC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_UC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_UI_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_UI_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Disarm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Disarm(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_START_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Pulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Command_1& setAO_Analog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Analog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Analog_Trigger_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Analog_Trigger_Reset(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Mode_1
   //---------------------------------------------------------------------------
   class tAO_Mode_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x14c,
         kId     = 23
      };
      tAO_Mode_1();


      typedef enum {
         kRegisterId                          = 0,
         kAO_Trigger_OnceId                   = 1,
         kAO_ContinuousId                     = 2,
         kAO_UC_Switch_Load_Every_TCId        = 3,
         kAO_UI_Source_PolarityId             = 4,
         kAO_UPDATE_Source_PolarityId         = 5,
         kAO_Multiple_ChannelsId              = 6,
         kAO_UI_Source_SelectId               = 7,
         kAO_UPDATE_Source_SelectId           = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Mode_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Mode_1& setAO_Trigger_Once(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Trigger_Once(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Trigger_Once(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Trigger_Once(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_ContinuousStop_On_BC_TC     = 0,
         kAO_ContinuousIgnore_BC_TC      = 1,
      } tAO_Continuous;
      inline tAO_Mode_1& setAO_Continuous(tAO_Continuous fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_Continuous getAO_Continuous(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Continuous(tAO_Continuous fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Continuous readAO_Continuous(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_1& setAO_UC_Switch_Load_Every_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Switch_Load_Every_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Switch_Load_Every_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Switch_Load_Every_TC(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UI_Source_PolarityRising_Edge       = 0,
         kAO_UI_Source_PolarityFalling_Edge      = 1,
      } tAO_UI_Source_Polarity;
      inline tAO_Mode_1& setAO_UI_Source_Polarity(tAO_UI_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UI_Source_Polarity getAO_UI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Source_Polarity(tAO_UI_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UI_Source_Polarity readAO_UI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UPDATE_Source_PolarityRising_Edge       = 0,
         kAO_UPDATE_Source_PolarityFalling_Edge      = 1,
      } tAO_UPDATE_Source_Polarity;
      inline tAO_Mode_1& setAO_UPDATE_Source_Polarity(tAO_UPDATE_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Source_Polarity getAO_UPDATE_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Source_Polarity(tAO_UPDATE_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Source_Polarity readAO_UPDATE_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_1& setAO_Multiple_Channels(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Multiple_Channels(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Multiple_Channels(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Multiple_Channels(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UI_Source_SelectGround            = 0,
         kAO_UI_Source_SelectPFI0              = 1,
         kAO_UI_Source_SelectPFI1              = 2,
         kAO_UI_Source_SelectPFI2              = 3,
         kAO_UI_Source_SelectPFI3              = 4,
         kAO_UI_Source_SelectPFI4              = 5,
         kAO_UI_Source_SelectPFI5              = 6,
         kAO_UI_Source_SelectPFI6              = 7,
         kAO_UI_Source_SelectPFI7              = 8,
         kAO_UI_Source_SelectPFI8              = 9,
         kAO_UI_Source_SelectPFI9              = 10,
         kAO_UI_Source_SelectRTSI0             = 11,
         kAO_UI_Source_SelectRTSI1             = 12,
         kAO_UI_Source_SelectRTSI2             = 13,
         kAO_UI_Source_SelectRTSI3             = 14,
         kAO_UI_Source_SelectRTSI4             = 15,
         kAO_UI_Source_SelectRTSI5             = 16,
         kAO_UI_Source_SelectRTSI6             = 17,
         kAO_UI_Source_SelectIN_TIMEBASE2      = 19,
         kAO_UI_Source_SelectStar_Trigger      = 20,
         kAO_UI_Source_SelectPFI10             = 21,
         kAO_UI_Source_SelectPFI11             = 22,
         kAO_UI_Source_SelectPFI12             = 23,
         kAO_UI_Source_SelectPFI13             = 24,
         kAO_UI_Source_SelectPFI14             = 25,
         kAO_UI_Source_SelectPFI15             = 26,
         kAO_UI_Source_SelectRTSI7             = 27,
         kAO_UI_Source_SelectAO_IN_TIMEBASE1   = 28,
         kAO_UI_Source_SelectPXI_Clk10         = 29,
         kAO_UI_Source_SelectAnalog_Trigger    = 30,
         kAO_UI_Source_SelectLow               = 31,
      } tAO_UI_Source_Select;
      inline tAO_Mode_1& setAO_UI_Source_Select(tAO_UI_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UI_Source_Select getAO_UI_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Source_Select(tAO_UI_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UI_Source_Select readAO_UI_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UPDATE_Source_SelectUI_TC             = 0,
         kAO_UPDATE_Source_SelectPFI0              = 1,
         kAO_UPDATE_Source_SelectPFI1              = 2,
         kAO_UPDATE_Source_SelectPFI2              = 3,
         kAO_UPDATE_Source_SelectPFI3              = 4,
         kAO_UPDATE_Source_SelectPFI4              = 5,
         kAO_UPDATE_Source_SelectPFI5              = 6,
         kAO_UPDATE_Source_SelectPFI6              = 7,
         kAO_UPDATE_Source_SelectPFI7              = 8,
         kAO_UPDATE_Source_SelectPFI8              = 9,
         kAO_UPDATE_Source_SelectPFI9              = 10,
         kAO_UPDATE_Source_SelectRTSI0             = 11,
         kAO_UPDATE_Source_SelectRTSI1             = 12,
         kAO_UPDATE_Source_SelectRTSI2             = 13,
         kAO_UPDATE_Source_SelectRTSI3             = 14,
         kAO_UPDATE_Source_SelectRTSI4             = 15,
         kAO_UPDATE_Source_SelectRTSI5             = 16,
         kAO_UPDATE_Source_SelectRTSI6             = 17,
         kAO_UPDATE_Source_SelectGPCTR0_Out        = 18,
         kAO_UPDATE_Source_SelectGPCTR1_Out        = 19,
         kAO_UPDATE_Source_SelectStar_Trigger      = 20,
         kAO_UPDATE_Source_SelectPFI10             = 21,
         kAO_UPDATE_Source_SelectPFI11             = 22,
         kAO_UPDATE_Source_SelectPFI12             = 23,
         kAO_UPDATE_Source_SelectPFI13             = 24,
         kAO_UPDATE_Source_SelectPFI14             = 25,
         kAO_UPDATE_Source_SelectPFI15             = 26,
         kAO_UPDATE_Source_SelectRTSI7             = 27,
         kAO_UPDATE_Source_SelectAnalog_Trigger    = 30,
         kAO_UPDATE_Source_SelectLow               = 31,
      } tAO_UPDATE_Source_Select;
      inline tAO_Mode_1& setAO_UPDATE_Source_Select(tAO_UPDATE_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Source_Select getAO_UPDATE_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Source_Select(tAO_UPDATE_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Source_Select readAO_UPDATE_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Mode_2
   //---------------------------------------------------------------------------
   class tAO_Mode_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x14e,
         kId     = 24
      };
      tAO_Mode_2();


      typedef enum {
         kRegisterId                          = 0,
         kAO_BC_Write_SwitchId                = 1,
         kAO_BC_Reload_ModeId                 = 2,
         kAO_BC_Initial_Load_SourceId         = 3,
         kAO_UI_Write_SwitchId                = 4,
         kAO_UI_Reload_ModeId                 = 5,
         kAO_UI_Initial_Load_SourceId         = 6,
         kAO_UC_Write_SwitchId                = 9,
         kAO_UC_Initial_Load_SourceId         = 10,
         kAO_START1_DisableId                 = 11,
         kAO_FIFO_Retransmit_EnableId         = 12,
         kAO_FIFO_ModeId                      = 13
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Mode_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Mode_2& setAO_BC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_2& setAO_BC_Reload_Mode(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Reload_Mode(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_BC_Initial_Load_SourceReg_A             = 0,
         kAO_BC_Initial_Load_SourceReg_B             = 1,
      } tAO_BC_Initial_Load_Source;
      inline tAO_Mode_2& setAO_BC_Initial_Load_Source(tAO_BC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_BC_Initial_Load_Source getAO_BC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Initial_Load_Source(tAO_BC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_BC_Initial_Load_Source readAO_BC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_2& setAO_UI_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UI_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UI_Reload_ModeNo_Change         = 0,
         kAO_UI_Reload_ModeAlternate_On_STOP   = 4,
         kAO_UI_Reload_ModeSwitch_On_STOP    = 5,
         kAO_UI_Reload_ModeAlternate_On_BC_TC    = 6,
         kAO_UI_Reload_ModeSwitch_On_BC_TC   = 7,
      } tAO_UI_Reload_Mode;
      inline tAO_Mode_2& setAO_UI_Reload_Mode(tAO_UI_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UI_Reload_Mode getAO_UI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Reload_Mode(tAO_UI_Reload_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UI_Reload_Mode readAO_UI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UI_Initial_Load_SourceReg_A             = 0,
         kAO_UI_Initial_Load_SourceReg_B             = 1,
      } tAO_UI_Initial_Load_Source;
      inline tAO_Mode_2& setAO_UI_Initial_Load_Source(tAO_UI_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UI_Initial_Load_Source getAO_UI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UI_Initial_Load_Source(tAO_UI_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UI_Initial_Load_Source readAO_UI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_2& setAO_UC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Write_Switch(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UC_Initial_Load_SourceReg_A             = 0,
         kAO_UC_Initial_Load_SourceReg_B             = 1,
      } tAO_UC_Initial_Load_Source;
      inline tAO_Mode_2& setAO_UC_Initial_Load_Source(tAO_UC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UC_Initial_Load_Source getAO_UC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Initial_Load_Source(tAO_UC_Initial_Load_Source fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UC_Initial_Load_Source readAO_UC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_2& setAO_START1_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START1_Disable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START1_Disable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_2& setAO_FIFO_Retransmit_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_FIFO_Retransmit_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_FIFO_Retransmit_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_FIFO_Retransmit_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_FIFO_ModeEmpty             = 0,
         kAO_FIFO_ModeLess_Than_Half_Full     = 1,
         kAO_FIFO_ModeLess_Than_Full    = 2,
         kAO_FIFO_ModeLess_Than_Half_Full_to_Full             = 3,
      } tAO_FIFO_Mode;
      inline tAO_Mode_2& setAO_FIFO_Mode(tAO_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_FIFO_Mode getAO_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_FIFO_Mode(tAO_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_FIFO_Mode readAO_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Output_Control
   //---------------------------------------------------------------------------
   class tAO_Output_Control : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1ac,
         kId     = 25
      };
      tAO_Output_Control();


      typedef enum {
         kRegisterId                          = 0,
         kAO_UPDATE_Output_SelectId           = 1,
         kAO_External_Gate_PolarityId         = 3,
         kAO_Number_Of_ChannelsId             = 5,
         kAO_External_Gate_SelectId           = 6,
         kAO_External_Gate_EnableId           = 7
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Output_Control& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAO_UPDATE_Output_SelectHigh_Z            = 0,
         kAO_UPDATE_Output_SelectGround            = 1,
         kAO_UPDATE_Output_SelectActive_Low        = 2,
         kAO_UPDATE_Output_SelectActive_High       = 3,
      } tAO_UPDATE_Output_Select;
      inline tAO_Output_Control& setAO_UPDATE_Output_Select(tAO_UPDATE_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Output_Select getAO_UPDATE_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Output_Select(tAO_UPDATE_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Output_Select readAO_UPDATE_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_External_Gate_PolarityActive_High       = 0,
         kAO_External_Gate_PolarityActive_Low        = 1,
      } tAO_External_Gate_Polarity;
      inline tAO_Output_Control& setAO_External_Gate_Polarity(tAO_External_Gate_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_External_Gate_Polarity getAO_External_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_External_Gate_Polarity(tAO_External_Gate_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_External_Gate_Polarity readAO_External_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Output_Control& setAO_Number_Of_Channels(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Number_Of_Channels(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Number_Of_Channels(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Number_Of_Channels(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_External_Gate_SelectDisabled          = 0,
         kAO_External_Gate_SelectPFI0              = 1,
         kAO_External_Gate_SelectPFI1              = 2,
         kAO_External_Gate_SelectPFI2              = 3,
         kAO_External_Gate_SelectPFI3              = 4,
         kAO_External_Gate_SelectPFI4              = 5,
         kAO_External_Gate_SelectPFI5              = 6,
         kAO_External_Gate_SelectPFI6              = 7,
         kAO_External_Gate_SelectPFI7              = 8,
         kAO_External_Gate_SelectPFI8              = 9,
         kAO_External_Gate_SelectPFI9              = 10,
         kAO_External_Gate_SelectRTSI0             = 11,
         kAO_External_Gate_SelectRTSI1             = 12,
         kAO_External_Gate_SelectRTSI2             = 13,
         kAO_External_Gate_SelectRTSI3             = 14,
         kAO_External_Gate_SelectRTSI4             = 15,
         kAO_External_Gate_SelectRTSI5             = 16,
         kAO_External_Gate_SelectRTSI6             = 17,
         kAO_External_Gate_SelectStar_Trigger      = 20,
         kAO_External_Gate_SelectPFI10             = 21,
         kAO_External_Gate_SelectPFI11             = 22,
         kAO_External_Gate_SelectPFI12             = 23,
         kAO_External_Gate_SelectPFI13             = 24,
         kAO_External_Gate_SelectPFI14             = 25,
         kAO_External_Gate_SelectPFI15             = 26,
         kAO_External_Gate_SelectRTSI7             = 27,
         kAO_External_Gate_SelectAnalog_Trigger    = 30,
         kAO_External_Gate_SelectLow               = 31,
      } tAO_External_Gate_Select;
      inline tAO_Output_Control& setAO_External_Gate_Select(tAO_External_Gate_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_External_Gate_Select getAO_External_Gate_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_External_Gate_Select(tAO_External_Gate_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_External_Gate_Select readAO_External_Gate_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Output_Control& setAO_External_Gate_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_External_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_External_Gate_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_External_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Mode_3
   //---------------------------------------------------------------------------
   class tAO_Mode_3 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x18c,
         kId     = 26
      };
      tAO_Mode_3();


      typedef enum {
         kRegisterId                          = 0,
         kAO_Last_Gate_DisableId              = 1,
         kAO_Software_GateId                  = 2,
         kAO_Not_An_UPDATEId                  = 3,
         kAO_Stop_On_BC_TC_ErrorId            = 4,
         kAO_Stop_On_BC_TC_Trigger_ErrorId    = 5,
         kAO_Stop_On_Overrun_ErrorId          = 6,
         kAO_Trigger_LengthId                 = 12,
         kAO_UC_Switch_Load_Every_BC_TCId     = 13
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Mode_3& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Mode_3& setAO_Last_Gate_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Last_Gate_Disable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Last_Gate_Disable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Last_Gate_Disable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_Software_Gate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Software_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Software_Gate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Software_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_Not_An_UPDATE(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Not_An_UPDATE(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Not_An_UPDATE(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Not_An_UPDATE(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_Stop_On_BC_TC_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Stop_On_BC_TC_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Stop_On_BC_TC_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Stop_On_BC_TC_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_Stop_On_BC_TC_Trigger_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Stop_On_BC_TC_Trigger_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Stop_On_BC_TC_Trigger_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Stop_On_BC_TC_Trigger_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_Stop_On_Overrun_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Stop_On_Overrun_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Stop_On_Overrun_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Stop_On_Overrun_Error(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_Trigger_LengthDA_START1         = 0,
         kAO_Trigger_LengthDA_ST1ED          = 1,
      } tAO_Trigger_Length;
      inline tAO_Mode_3& setAO_Trigger_Length(tAO_Trigger_Length fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_Trigger_Length getAO_Trigger_Length(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Trigger_Length(tAO_Trigger_Length fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Trigger_Length readAO_Trigger_Length(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Mode_3& setAO_UC_Switch_Load_Every_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Switch_Load_Every_BC_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_Switch_Load_Every_BC_TC(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_Switch_Load_Every_BC_TC(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Personal
   //---------------------------------------------------------------------------
   class tAO_Personal : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x19c,
         kId     = 27
      };
      tAO_Personal();


      typedef enum {
         kRegisterId                          = 0,
         kAO_Interval_Buffer_ModeId           = 4,
         kAO_BC_Source_SelectId               = 5,
         kAO_UPDATE_Pulse_WidthId             = 6,
         kAO_UPDATE_Pulse_TimebaseId          = 7,
         kAO_UPDATE_Original_PulseId          = 8,
         kAO_FIFO_EnableId                    = 11,
         kAO_TMRDACWR_Pulse_WidthId           = 13,
         kAO_Number_Of_DAC_PackagesId         = 15,
         kAO_Multiple_DACS_Per_PackageId      = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Personal& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Personal& setAO_Interval_Buffer_Mode(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Interval_Buffer_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Interval_Buffer_Mode(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Interval_Buffer_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_BC_Source_SelectUPDATE            = 0,
         kAO_BC_Source_SelectUC_TC             = 1,
      } tAO_BC_Source_Select;
      inline tAO_Personal& setAO_BC_Source_Select(tAO_BC_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_BC_Source_Select getAO_BC_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_Source_Select(tAO_BC_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_BC_Source_Select readAO_BC_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UPDATE_Pulse_WidthAbout_1_TIMEBASE_Periods          = 0,
         kAO_UPDATE_Pulse_WidthAbout_3_TIMEBASE_Periods          = 1,
      } tAO_UPDATE_Pulse_Width;
      inline tAO_Personal& setAO_UPDATE_Pulse_Width(tAO_UPDATE_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Pulse_Width getAO_UPDATE_Pulse_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Pulse_Width(tAO_UPDATE_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Pulse_Width readAO_UPDATE_Pulse_Width(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UPDATE_Pulse_TimebaseSelect_By_PulseWidth      = 0,
         kAO_UPDATE_Pulse_TimebaseSelect_By_OriginalPulse         = 1,
      } tAO_UPDATE_Pulse_Timebase;
      inline tAO_Personal& setAO_UPDATE_Pulse_Timebase(tAO_UPDATE_Pulse_Timebase fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Pulse_Timebase getAO_UPDATE_Pulse_Timebase(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Pulse_Timebase(tAO_UPDATE_Pulse_Timebase fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Pulse_Timebase readAO_UPDATE_Pulse_Timebase(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_UPDATE_Original_PulseMax_Of_UPDATE_Pulsewidth          = 0,
         kAO_UPDATE_Original_PulseEqual_To_UPDATE_Pulsewidth            = 1,
      } tAO_UPDATE_Original_Pulse;
      inline tAO_Personal& setAO_UPDATE_Original_Pulse(tAO_UPDATE_Original_Pulse fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_UPDATE_Original_Pulse getAO_UPDATE_Original_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Original_Pulse(tAO_UPDATE_Original_Pulse fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_UPDATE_Original_Pulse readAO_UPDATE_Original_Pulse(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Personal& setAO_FIFO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_FIFO_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_FIFO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_FIFO_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_TMRDACWR_Pulse_WidthAbout_3_TIMEBASE_Periods          = 0,
         kAO_TMRDACWR_Pulse_WidthAbout_2_TIMEBASE_Periods          = 1,
      } tAO_TMRDACWR_Pulse_Width;
      inline tAO_Personal& setAO_TMRDACWR_Pulse_Width(tAO_TMRDACWR_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_TMRDACWR_Pulse_Width getAO_TMRDACWR_Pulse_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_TMRDACWR_Pulse_Width(tAO_TMRDACWR_Pulse_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_TMRDACWR_Pulse_Width readAO_TMRDACWR_Pulse_Width(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_Number_Of_DAC_PackagesDual_DAC_mode     = 0,
         kAO_Number_Of_DAC_PackagesSingle_DAC_mode   = 1,
      } tAO_Number_Of_DAC_Packages;
      inline tAO_Personal& setAO_Number_Of_DAC_Packages(tAO_Number_Of_DAC_Packages fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_Number_Of_DAC_Packages getAO_Number_Of_DAC_Packages(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Number_Of_DAC_Packages(tAO_Number_Of_DAC_Packages fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Number_Of_DAC_Packages readAO_Number_Of_DAC_Packages(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Personal& setAO_Multiple_DACS_Per_Package(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Multiple_DACS_Per_Package(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Multiple_DACS_Per_Package(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Multiple_DACS_Per_Package(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_START_Select
   //---------------------------------------------------------------------------
   class tAO_START_Select : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x184,
         kId     = 28
      };
      tAO_START_Select();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1,
         kAO_START_EdgeId                     = 2,
         kAO_START_SyncId                     = 3,
         kAO_AOFREQ_EnableId                  = 5,
         kAO_START_PolarityId                 = 6
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_START_Select& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPulse             = 0,
         kPFI0              = 1,
         kPFI1              = 2,
         kPFI2              = 3,
         kPFI3              = 4,
         kPFI4              = 5,
         kPFI5              = 6,
         kPFI6              = 7,
         kPFI7              = 8,
         kPFI8              = 9,
         kPFI9              = 10,
         kRTSI0             = 11,
         kRTSI1             = 12,
         kRTSI2             = 13,
         kRTSI3             = 14,
         kRTSI4             = 15,
         kRTSI5             = 16,
         kRTSI6             = 17,
         kLow               = 31,
      } tDefault;
      inline tAO_START_Select& set(tDefault fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tDefault get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(tDefault fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tDefault read(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START_Select& setAO_START_Edge(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Edge(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START_Select& setAO_START_Sync(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Sync(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START_Sync(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START_Select& setAO_AOFREQ_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_AOFREQ_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_AOFREQ_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_AOFREQ_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_START_PolarityActive_High_Or_Rising_Edge            = 0,
         kAO_START_PolarityActive_Low_Or_Falling_Edge            = 1,
         kAO_START_PolarityActive_High       = 0,
         kAO_START_PolarityActive_Low        = 1,
         kAO_START_PolarityRising_Edge       = 0,
         kAO_START_PolarityFalling_Edge      = 1,
      } tAO_START_Polarity;
      inline tAO_START_Select& setAO_START_Polarity(tAO_START_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_START_Polarity getAO_START_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Polarity(tAO_START_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START_Polarity readAO_START_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Status_2
   //---------------------------------------------------------------------------
   class tAO_Status_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x10c,
         kId     = 29
      };
      tAO_Status_2();


      typedef enum {
         kRegisterId                          = 0,
         kAO_BC_Armed_StId                    = 1,
         kAO_BC_Save_StId                     = 3,
         kAO_BC_Q_StId                        = 4,
         kAO_BC_TC_Trigger_Error_StId         = 5,
         kAO_UI_Armed_StId                    = 6,
         kAO_UI_Next_Load_Source_StId         = 7,
         kAO_UC_Save_StId                     = 8,
         kAO_UI_Count_Enabled_StId            = 9,
         kAO_UI_Q_StId                        = 10,
         kAO_UC_Armed_StId                    = 15
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_Status_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Status_2& setAO_BC_Armed_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_BC_Save_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Save_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_Save_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_BC_Q_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_BC_TC_Trigger_Error_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_Trigger_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_TC_Trigger_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UI_Armed_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UI_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UI_Next_Load_Source_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UC_Save_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Save_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UC_Save_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UI_Count_Enabled_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Count_Enabled_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UI_Count_Enabled_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UI_Q_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UI_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UI_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_2& setAO_UC_Armed_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UC_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Status_1
   //---------------------------------------------------------------------------
   class tAO_Status_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x106,
         kId     = 30
      };
      tAO_Status_1();


      typedef enum {
         kRegisterId                          = 0,
         kPass_Thru_1_Interrupt_StId          = 1,
         kAO_FIFO_Request_StId                = 2,
         kG1_Gate_Interrupt_StId              = 3,
         kG1_TC_StId                          = 4,
         kAO_UPDATE_StId                      = 6,
         kAO_UC_TC_StId                       = 7,
         kAO_BC_TC_StId                       = 8,
         kAO_START1_StId                      = 9,
         kAO_Overrun_StId                     = 10,
         kAO_START_StId                       = 11,
         kAO_BC_TC_Error_StId                 = 12,
         kAO_FIFO_Empty_StId                  = 13,
         kAO_FIFO_Half_Full_StId              = 14,
         kAO_FIFO_Full_StId                   = 15,
         kInterrupt_Group_B_StatusId          = 16
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_Status_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Status_1& setPass_Thru_1_Interrupt_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getPass_Thru_1_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readPass_Thru_1_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_FIFO_Request_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setG1_Gate_Interrupt_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setG1_TC_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_UPDATE_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UPDATE_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UPDATE_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_UC_TC_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_BC_TC_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_START1_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START1_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_START1_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_Overrun_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Overrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_Overrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_START_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_START_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_BC_TC_Error_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_FIFO_Empty_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_FIFO_Half_Full_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_FIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_FIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setAO_FIFO_Full_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Status_1& setInterrupt_Group_B_Status(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getInterrupt_Group_B_Status(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readInterrupt_Group_B_Status(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Trigger_Select
   //---------------------------------------------------------------------------
   class tAO_Trigger_Select : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x186,
         kId     = 31
      };
      tAO_Trigger_Select();


      typedef enum {
         kRegisterId                          = 0,
         kAO_START1_SelectId                  = 1,
         kAO_START1_EdgeId                    = 2,
         kAO_START1_SyncId                    = 3,
         kAO_START1_PolarityId                = 6,
         kAO_Delayed_START1Id                 = 7
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Trigger_Select& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAO_START1_SelectPulse             = 0,
         kAO_START1_SelectPFI0              = 1,
         kAO_START1_SelectPFI1              = 2,
         kAO_START1_SelectPFI2              = 3,
         kAO_START1_SelectPFI3              = 4,
         kAO_START1_SelectPFI4              = 5,
         kAO_START1_SelectPFI5              = 6,
         kAO_START1_SelectPFI6              = 7,
         kAO_START1_SelectPFI7              = 8,
         kAO_START1_SelectPFI8              = 9,
         kAO_START1_SelectPFI9              = 10,
         kAO_START1_SelectRTSI0             = 11,
         kAO_START1_SelectRTSI1             = 12,
         kAO_START1_SelectRTSI2             = 13,
         kAO_START1_SelectRTSI3             = 14,
         kAO_START1_SelectRTSI4             = 15,
         kAO_START1_SelectRTSI5             = 16,
         kAO_START1_SelectRTSI6             = 17,
         kAO_START1_SelectAI_START_2        = 18,
         kAO_START1_SelectAI_START_1        = 19,
         kAO_START1_SelectStar_Trigger      = 20,
         kAO_START1_SelectPFI10             = 21,
         kAO_START1_SelectPFI11             = 22,
         kAO_START1_SelectPFI12             = 23,
         kAO_START1_SelectPFI13             = 24,
         kAO_START1_SelectPFI14             = 25,
         kAO_START1_SelectPFI15             = 26,
         kAO_START1_SelectRTSI7             = 27,
         kAO_START1_SelectAnalog_Trigger    = 30,
         kAO_START1_SelectLow               = 31,
      } tAO_START1_Select;
      inline tAO_Trigger_Select& setAO_START1_Select(tAO_START1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_START1_Select getAO_START1_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Select(tAO_START1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START1_Select readAO_START1_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Trigger_Select& setAO_START1_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_START1_Edge(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Edge(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_START1_Edge(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Trigger_Select& setAO_START1_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_START1_Sync(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Sync(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_START1_Sync(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_START1_PolarityActive_High       = 0,
         kAO_START1_PolarityRising_Edge       = 0,
         kAO_START1_PolarityActive_Low        = 1,
         kAO_START1_PolarityFalling_Edge      = 1,
      } tAO_START1_Polarity;
      inline tAO_Trigger_Select& setAO_START1_Polarity(tAO_START1_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_START1_Polarity getAO_START1_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Polarity(tAO_START1_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_START1_Polarity readAO_START1_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Trigger_Select& setAO_Delayed_START1(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Delayed_START1(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Delayed_START1(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Delayed_START1(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UC_Load_A
   //---------------------------------------------------------------------------
   class tAO_UC_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x160,
         kId     = 32
      };
      tAO_UC_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_UC_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UC_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UC_Load_B
   //---------------------------------------------------------------------------
   class tAO_UC_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x164,
         kId     = 33
      };
      tAO_UC_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_UC_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UC_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UC_Save
   //---------------------------------------------------------------------------
   class tAO_UC_Save : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x128,
         kId     = 34
      };
      tAO_UC_Save();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_UC_Save& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UC_Save& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UI_Load_A
   //---------------------------------------------------------------------------
   class tAO_UI_Load_A : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x150,
         kId     = 35
      };
      tAO_UI_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_UI_Load_A& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UI_Load_A& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UI_Load_B
   //---------------------------------------------------------------------------
   class tAO_UI_Load_B : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x154,
         kId     = 36
      };
      tAO_UI_Load_B();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_UI_Load_B& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UI_Load_B& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_UI_Save
   //---------------------------------------------------------------------------
   class tAO_UI_Save : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x120,
         kId     = 37
      };
      tAO_UI_Save();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_UI_Save& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_UI_Save& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Clock_and_FOUT
   //---------------------------------------------------------------------------
   class tClock_and_FOUT : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x170,
         kId     = 38
      };
      tClock_and_FOUT();


      typedef enum {
         kRegisterId                          = 0,
         kFOUT_DividerId                      = 1,
         kClock_To_BoardId                    = 6,
         kClock_To_Board_Divide_By_2Id        = 7,
         kSlow_Internal_TimebaseId            = 9,
         kDIO_Serial_Out_Divide_By_2Id        = 11,
         kFOUT_Timebase_SelectId              = 12,
         kFOUT_EnableId                       = 13
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tClock_and_FOUT& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tClock_and_FOUT& setFOUT_Divider(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getFOUT_Divider(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFOUT_Divider(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readFOUT_Divider(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setClock_To_Board(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getClock_To_Board(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClock_To_Board(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClock_To_Board(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setClock_To_Board_Divide_By_2(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getClock_To_Board_Divide_By_2(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClock_To_Board_Divide_By_2(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClock_To_Board_Divide_By_2(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setSlow_Internal_Timebase(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getSlow_Internal_Timebase(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSlow_Internal_Timebase(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSlow_Internal_Timebase(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setDIO_Serial_Out_Divide_By_2(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getDIO_Serial_Out_Divide_By_2(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDIO_Serial_Out_Divide_By_2(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readDIO_Serial_Out_Divide_By_2(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setFOUT_Timebase_Select(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getFOUT_Timebase_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFOUT_Timebase_Select(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readFOUT_Timebase_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tClock_and_FOUT& setFOUT_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getFOUT_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFOUT_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readFOUT_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_A_Ack
   //---------------------------------------------------------------------------
   class tInterrupt_A_Ack : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x104,
         kId     = 39
      };
      tInterrupt_A_Ack();


      typedef enum {
         kRegisterId                          = 0,
         kG0_Gate_Error_ConfirmId             = 6,
         kG0_TC_Error_ConfirmId               = 7,
         kAI_SC_TC_Error_ConfirmId            = 8,
         kAI_SC_TC_Interrupt_AckId            = 9,
         kAI_START1_Interrupt_AckId           = 10,
         kAI_START2_Interrupt_AckId           = 11,
         kAI_START_Interrupt_AckId            = 12,
         kAI_STOP_Interrupt_AckId             = 13,
         kAI_Error_Interrupt_AckId            = 14,
         kG0_TC_Interrupt_AckId               = 15,
         kG0_Gate_Interrupt_AckId             = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_A_Ack& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_A_Ack& setG0_Gate_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_Gate_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_Gate_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_Gate_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setG0_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_SC_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_SC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_SC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_START1_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_START2_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START2_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START2_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_START_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_START_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_START_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_STOP_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_STOP_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_STOP_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setAI_Error_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Error_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Error_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Error_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setG0_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Ack& setG0_Gate_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_Gate_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_Gate_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_Gate_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_A_Enable
   //---------------------------------------------------------------------------
   class tInterrupt_A_Enable : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x192,
         kId     = 40
      };
      tInterrupt_A_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kAI_SC_TC_Interrupt_EnableId         = 1,
         kAI_START1_Interrupt_EnableId        = 2,
         kAI_START2_Interrupt_EnableId        = 3,
         kAI_START_Interrupt_EnableId         = 4,
         kAI_STOP_Interrupt_EnableId          = 5,
         kAI_Error_Interrupt_EnableId         = 6,
         kG0_TC_Interrupt_EnableId            = 7,
         kAI_FIFO_Interrupt_EnableId          = 8,
         kG0_Gate_Interrupt_EnableId          = 9
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_A_Enable& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_A_Enable& setAI_SC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_SC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_SC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_START1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_START2_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START2_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START2_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START2_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_START_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_START_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_START_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_START_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_STOP_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_STOP_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_STOP_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_STOP_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_Error_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Error_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Error_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Error_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setG0_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG0_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readG0_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setAI_FIFO_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_FIFO_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_FIFO_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_FIFO_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_A_Enable& setG0_Gate_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG0_Gate_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_Gate_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readG0_Gate_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_B_Ack
   //---------------------------------------------------------------------------
   class tInterrupt_B_Ack : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x106,
         kId     = 41
      };
      tInterrupt_B_Ack();


      typedef enum {
         kRegisterId                          = 0,
         kG1_Gate_Error_ConfirmId             = 2,
         kG1_TC_Error_ConfirmId               = 3,
         kAO_BC_TC_Trigger_Error_ConfirmId    = 4,
         kAO_BC_TC_Error_ConfirmId            = 5,
         kAO_UC_TC_Interrupt_AckId            = 8,
         kAO_BC_TC_Interrupt_AckId            = 9,
         kAO_START1_Interrupt_AckId           = 10,
         kAO_UPDATE_Interrupt_AckId           = 11,
         kAO_START_Interrupt_AckId            = 12,
         kAO_STOP_Interrupt_AckId             = 13,
         kAO_Error_Interrupt_AckId            = 14,
         kG1_TC_Interrupt_AckId               = 15,
         kG1_Gate_Interrupt_AckId             = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_B_Ack& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_B_Ack& setG1_Gate_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_Gate_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_Gate_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_Gate_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setG1_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_BC_TC_Trigger_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_Trigger_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_TC_Trigger_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_TC_Trigger_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_BC_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_TC_Error_Confirm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_TC_Error_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_UC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_BC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_BC_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_START1_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_UPDATE_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UPDATE_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_UPDATE_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_START_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_START_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_START_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_STOP_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_STOP_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_STOP_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_STOP_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setAO_Error_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Error_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Error_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Error_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setG1_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_TC_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_TC_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Ack& setG1_Gate_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_Gate_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_Gate_Interrupt_Ack(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_Gate_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_Control
   //---------------------------------------------------------------------------
   class tInterrupt_Control : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x176,
         kId     = 42
      };
      tInterrupt_Control();


      typedef enum {
         kRegisterId                          = 0,
         kInterrupt_Group_A_EnableId          = 10,
         kInterrupt_Group_B_EnableId          = 12
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_Control& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_Control& setInterrupt_Group_A_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getInterrupt_Group_A_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeInterrupt_Group_A_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readInterrupt_Group_A_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Control& setInterrupt_Group_B_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getInterrupt_Group_B_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeInterrupt_Group_B_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readInterrupt_Group_B_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_B_Enable
   //---------------------------------------------------------------------------
   class tInterrupt_B_Enable : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x196,
         kId     = 43
      };
      tInterrupt_B_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kAO_BC_TC_Interrupt_EnableId         = 1,
         kAO_START1_Interrupt_EnableId        = 2,
         kAO_UPDATE_Interrupt_EnableId        = 3,
         kAO_START_Interrupt_EnableId         = 4,
         kAO_STOP_Interrupt_EnableId          = 5,
         kAO_Error_Interrupt_EnableId         = 6,
         kAO_UC_TC_Interrupt_EnableId         = 7,
         kAO_FIFO_Interrupt_EnableId          = 9,
         kG1_TC_Interrupt_EnableId            = 10,
         kG1_Gate_Interrupt_EnableId          = 11,
         kPass_Thru_1_Interrupt_EnableId      = 12
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_B_Enable& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_B_Enable& setAO_BC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_BC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_BC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_BC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_START1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_START1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_START1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_UPDATE_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_UPDATE_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UPDATE_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_UPDATE_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_START_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_START_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_START_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_START_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_STOP_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_STOP_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_STOP_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_STOP_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_Error_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_Error_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Error_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_Error_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_UC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_UC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_UC_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_UC_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setAO_FIFO_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_FIFO_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_FIFO_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_FIFO_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setG1_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG1_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_TC_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readG1_TC_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setG1_Gate_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getG1_Gate_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_Gate_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readG1_Gate_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_B_Enable& setPass_Thru_1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getPass_Thru_1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePass_Thru_1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readPass_Thru_1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // IO_Bidirection_Pin
   //---------------------------------------------------------------------------
   class tIO_Bidirection_Pin : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x172,
         kId     = 44
      };
      tIO_Bidirection_Pin();


      typedef enum {
         kRegisterId                          = 0,
         kPFI0_Pin_DirId                      = 1,
         kPFI1_Pin_DirId                      = 2,
         kPFI2_Pin_DirId                      = 3,
         kPFI3_Pin_DirId                      = 4,
         kPFI4_Pin_DirId                      = 5,
         kPFI5_Pin_DirId                      = 6,
         kPFI6_Pin_DirId                      = 7,
         kPFI7_Pin_DirId                      = 8,
         kPFI8_Pin_DirId                      = 9,
         kPFI9_Pin_DirId                      = 10,
         kPFI10_Pin_DirId                     = 11,
         kPFI11_Pin_DirId                     = 12,
         kPFI12_Pin_DirId                     = 13,
         kPFI13_Pin_DirId                     = 14,
         kPFI14_Pin_DirId                     = 15,
         kPFI15_Pin_DirId                     = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tIO_Bidirection_Pin& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI0_Pin_DirInput             = 0,
         kPFI0_Pin_DirOutput            = 1,
      } tPFI0_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI0_Pin_Dir(tPFI0_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI0_Pin_Dir getPFI0_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI0_Pin_Dir(tPFI0_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI0_Pin_Dir readPFI0_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI1_Pin_DirInput             = 0,
         kPFI1_Pin_DirOutput            = 1,
      } tPFI1_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI1_Pin_Dir(tPFI1_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI1_Pin_Dir getPFI1_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI1_Pin_Dir(tPFI1_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI1_Pin_Dir readPFI1_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI2_Pin_DirInput             = 0,
         kPFI2_Pin_DirOutput            = 1,
      } tPFI2_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI2_Pin_Dir(tPFI2_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI2_Pin_Dir getPFI2_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI2_Pin_Dir(tPFI2_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI2_Pin_Dir readPFI2_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI3_Pin_DirInput             = 0,
         kPFI3_Pin_DirOutput            = 1,
      } tPFI3_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI3_Pin_Dir(tPFI3_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI3_Pin_Dir getPFI3_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI3_Pin_Dir(tPFI3_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI3_Pin_Dir readPFI3_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI4_Pin_DirInput             = 0,
         kPFI4_Pin_DirOutput            = 1,
      } tPFI4_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI4_Pin_Dir(tPFI4_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI4_Pin_Dir getPFI4_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI4_Pin_Dir(tPFI4_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI4_Pin_Dir readPFI4_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI5_Pin_DirInput             = 0,
         kPFI5_Pin_DirOutput            = 1,
      } tPFI5_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI5_Pin_Dir(tPFI5_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI5_Pin_Dir getPFI5_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI5_Pin_Dir(tPFI5_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI5_Pin_Dir readPFI5_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI6_Pin_DirInput             = 0,
         kPFI6_Pin_DirOutput            = 1,
      } tPFI6_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI6_Pin_Dir(tPFI6_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI6_Pin_Dir getPFI6_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI6_Pin_Dir(tPFI6_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI6_Pin_Dir readPFI6_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI7_Pin_DirInput             = 0,
         kPFI7_Pin_DirOutput            = 1,
      } tPFI7_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI7_Pin_Dir(tPFI7_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI7_Pin_Dir getPFI7_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI7_Pin_Dir(tPFI7_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI7_Pin_Dir readPFI7_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI8_Pin_DirInput             = 0,
         kPFI8_Pin_DirOutput            = 1,
      } tPFI8_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI8_Pin_Dir(tPFI8_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI8_Pin_Dir getPFI8_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI8_Pin_Dir(tPFI8_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI8_Pin_Dir readPFI8_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI9_Pin_DirInput             = 0,
         kPFI9_Pin_DirOutput            = 1,
      } tPFI9_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI9_Pin_Dir(tPFI9_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI9_Pin_Dir getPFI9_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI9_Pin_Dir(tPFI9_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI9_Pin_Dir readPFI9_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI10_Pin_DirInput             = 0,
         kPFI10_Pin_DirOutput            = 1,
      } tPFI10_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI10_Pin_Dir(tPFI10_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI10_Pin_Dir getPFI10_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI10_Pin_Dir(tPFI10_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI10_Pin_Dir readPFI10_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI11_Pin_DirInput             = 0,
         kPFI11_Pin_DirOutput            = 1,
      } tPFI11_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI11_Pin_Dir(tPFI11_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI11_Pin_Dir getPFI11_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI11_Pin_Dir(tPFI11_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI11_Pin_Dir readPFI11_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI12_Pin_DirInput             = 0,
         kPFI12_Pin_DirOutput            = 1,
      } tPFI12_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI12_Pin_Dir(tPFI12_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI12_Pin_Dir getPFI12_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI12_Pin_Dir(tPFI12_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI12_Pin_Dir readPFI12_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI13_Pin_DirInput             = 0,
         kPFI13_Pin_DirOutput            = 1,
      } tPFI13_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI13_Pin_Dir(tPFI13_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI13_Pin_Dir getPFI13_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI13_Pin_Dir(tPFI13_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI13_Pin_Dir readPFI13_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI14_Pin_DirInput             = 0,
         kPFI14_Pin_DirOutput            = 1,
      } tPFI14_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI14_Pin_Dir(tPFI14_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI14_Pin_Dir getPFI14_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI14_Pin_Dir(tPFI14_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI14_Pin_Dir readPFI14_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI15_Pin_DirInput             = 0,
         kPFI15_Pin_DirOutput            = 1,
      } tPFI15_Pin_Dir;
      inline tIO_Bidirection_Pin& setPFI15_Pin_Dir(tPFI15_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI15_Pin_Dir getPFI15_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI15_Pin_Dir(tPFI15_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI15_Pin_Dir readPFI15_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Joint_Reset
   //---------------------------------------------------------------------------
   class tJoint_Reset : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x190,
         kId     = 45
      };
      tJoint_Reset();


      typedef enum {
         kRegisterId                          = 0,
         kAI_ResetId                          = 1,
         kAO_ResetId                          = 2,
         kG0_ResetId                          = 3,
         kG1_ResetId                          = 4,
         kAI_Configuration_StartId            = 5,
         kAO_Configuration_StartId            = 6,
         kAI_Configuration_EndId              = 9,
         kAO_Configuration_EndId              = 10,
         kSoftware_ResetId                    = 12
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tJoint_Reset& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tJoint_Reset& setAI_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setAO_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setG0_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setG1_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setAI_Configuration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Configuration_Start(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Configuration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Configuration_Start(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setAO_Configuration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Configuration_Start(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Configuration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Configuration_Start(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setAI_Configuration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Configuration_End(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Configuration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Configuration_End(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setAO_Configuration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Configuration_End(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Configuration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAO_Configuration_End(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Reset& setSoftware_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getSoftware_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSoftware_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readSoftware_Reset(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Joint_Status_2
   //---------------------------------------------------------------------------
   class tJoint_Status_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x13a,
         kId     = 46
      };
      tJoint_Status_2();


      typedef enum {
         kRegisterId                          = 0,
         kG0_Output_StId                      = 1,
         kG1_Output_StId                      = 2,
         kAO_STOP_StId                        = 3,
         kAI_EOC_StId                         = 5,
         kAO_TMRDACWRs_In_Progress_StId       = 6,
         kAI_Config_Memory_Empty_StId         = 7,
         kAI_Scan_In_Progress_StId            = 8,
         kGeneric_StatusId                    = 9,
         kG0_HW_Save_StId                     = 10,
         kG1_HW_Save_StId                     = 11,
         kG0_Permanent_Stale_Data_StId        = 12,
         kG1_Permanent_Stale_Data_StId        = 13
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tJoint_Status_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kG0_Output_StLow               = 0,
         kG0_Output_StHigh              = 1,
      } tG0_Output_St;
      inline tJoint_Status_2& setG0_Output_St(tG0_Output_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG0_Output_St getG0_Output_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG0_Output_St readG0_Output_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG1_Output_StLow               = 0,
         kG1_Output_StHigh              = 1,
      } tG1_Output_St;
      inline tJoint_Status_2& setG1_Output_St(tG1_Output_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG1_Output_St getG1_Output_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG1_Output_St readG1_Output_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setAO_STOP_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_STOP_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_STOP_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setAI_EOC_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_EOC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_EOC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setAO_TMRDACWRs_In_Progress_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_TMRDACWRs_In_Progress_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAO_TMRDACWRs_In_Progress_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setAI_Config_Memory_Empty_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Config_Memory_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_Config_Memory_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setAI_Scan_In_Progress_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Scan_In_Progress_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_Scan_In_Progress_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_2& setGeneric_Status(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGeneric_Status(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readGeneric_Status(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG0_HW_Save_StTracing           = 0,
         kG0_HW_Save_StLatched           = 1,
      } tG0_HW_Save_St;
      inline tJoint_Status_2& setG0_HW_Save_St(tG0_HW_Save_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG0_HW_Save_St getG0_HW_Save_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG0_HW_Save_St readG0_HW_Save_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG1_HW_Save_StTracing           = 0,
         kG1_HW_Save_StLatched           = 1,
      } tG1_HW_Save_St;
      inline tJoint_Status_2& setG1_HW_Save_St(tG1_HW_Save_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG1_HW_Save_St getG1_HW_Save_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG1_HW_Save_St readG1_HW_Save_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG0_Permanent_Stale_Data_StNo_Error          = 0,
         kG0_Permanent_Stale_Data_StError             = 1,
      } tG0_Permanent_Stale_Data_St;
      inline tJoint_Status_2& setG0_Permanent_Stale_Data_St(tG0_Permanent_Stale_Data_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG0_Permanent_Stale_Data_St getG0_Permanent_Stale_Data_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG0_Permanent_Stale_Data_St readG0_Permanent_Stale_Data_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG1_Permanent_Stale_Data_StNo_Error          = 0,
         kG1_Permanent_Stale_Data_StError             = 1,
      } tG1_Permanent_Stale_Data_St;
      inline tJoint_Status_2& setG1_Permanent_Stale_Data_St(tG1_Permanent_Stale_Data_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG1_Permanent_Stale_Data_St getG1_Permanent_Stale_Data_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG1_Permanent_Stale_Data_St readG1_Permanent_Stale_Data_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Joint_Status_1
   //---------------------------------------------------------------------------
   class tJoint_Status_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x136,
         kId     = 47
      };
      tJoint_Status_1();


      typedef enum {
         kRegisterId                          = 0,
         kG0_Bank_StId                        = 1,
         kG1_Bank_StId                        = 2,
         kG0_Gate_StId                        = 3,
         kG1_Gate_StId                        = 4,
         kAI_SC_Gate_StId                     = 5,
         kAI_Start_Stop_Gate_StId             = 6,
         kAO_BC_Gate_StId                     = 7,
         kAO_Start_Stop_Gate_StId             = 8,
         kAI_SI2_Q_StId                       = 9,
         kAI_External_Gate_StId               = 10,
         kAO_External_Gate_StId               = 11,
         kDIO_Serial_IO_In_Progress_StId      = 12,
         kAO_UC_Q_StId                        = 14,
         kAI_Last_Shiftin_StId                = 15
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tJoint_Status_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kG0_Bank_StBank_X            = 0,
         kG0_Bank_StBank_Y            = 1,
      } tG0_Bank_St;
      inline tJoint_Status_1& setG0_Bank_St(tG0_Bank_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG0_Bank_St getG0_Bank_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG0_Bank_St readG0_Bank_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG1_Bank_StBank_X            = 0,
         kG1_Bank_StBank_Y            = 1,
      } tG1_Bank_St;
      inline tJoint_Status_1& setG1_Bank_St(tG1_Bank_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG1_Bank_St getG1_Bank_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG1_Bank_St readG1_Bank_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG0_Gate_StInactive          = 0,
         kG0_Gate_StActive            = 1,
      } tG0_Gate_St;
      inline tJoint_Status_1& setG0_Gate_St(tG0_Gate_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG0_Gate_St getG0_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG0_Gate_St readG0_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kG1_Gate_StInactive          = 0,
         kG1_Gate_StActive            = 1,
      } tG1_Gate_St;
      inline tJoint_Status_1& setG1_Gate_St(tG1_Gate_St fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tG1_Gate_St getG1_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tG1_Gate_St readG1_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAI_SC_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SC_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_SC_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAI_Start_Stop_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Start_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_Start_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAO_BC_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_BC_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_BC_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAO_Start_Stop_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_Start_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_Start_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAI_SI2_Q_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_SI2_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_SI2_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAI_External_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_External_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_External_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAO_External_Gate_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_External_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_External_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setDIO_Serial_IO_In_Progress_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getDIO_Serial_IO_In_Progress_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readDIO_Serial_IO_In_Progress_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAO_UC_Q_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAO_UC_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAO_UC_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tJoint_Status_1& setAI_Last_Shiftin_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Last_Shiftin_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readAI_Last_Shiftin_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // RTSI_Shared_MUX
   //---------------------------------------------------------------------------
   class tRTSI_Shared_MUX : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1a2,
         kId     = 48
      };
      tRTSI_Shared_MUX();


      typedef enum {
         kRegisterId                          = 0,
         kRTSI_Shared_MUX_0_Output_SelectId   = 1,
         kRTSI_Shared_MUX_1_Output_SelectId   = 2,
         kRTSI_Shared_MUX_2_Output_SelectId   = 3,
         kRTSI_Shared_MUX_3_Output_SelectId   = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tRTSI_Shared_MUX& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI0  = 0,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI1  = 1,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI2  = 2,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI3  = 3,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI4  = 4,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_PFI5  = 5,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_AO_Gate_RTSI          = 6,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_AI_Gate_RTSI          = 7,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_Freq_Out      = 8,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_G1_Out    = 9,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_G1_Selected_Gate              = 10,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_G1_Selected_Source                = 11,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_G1_Z  = 12,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_G0_Z  = 13,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_Analog_Trigger            = 14,
         kRTSI_Shared_MUX_0_Output_SelectMUX_Out_Sel_AI_Start_Pulse            = 15,
      } tRTSI_Shared_MUX_0_Output_Select;
      inline tRTSI_Shared_MUX& setRTSI_Shared_MUX_0_Output_Select(tRTSI_Shared_MUX_0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Shared_MUX_0_Output_Select getRTSI_Shared_MUX_0_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Shared_MUX_0_Output_Select(tRTSI_Shared_MUX_0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Shared_MUX_0_Output_Select readRTSI_Shared_MUX_0_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI0  = 0,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI1  = 1,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI2  = 2,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI3  = 3,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI4  = 4,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_PFI5  = 5,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_AO_Gate_RTSI          = 6,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_AI_Gate_RTSI          = 7,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_Freq_Out      = 8,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_G1_Out    = 9,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_G1_Selected_Gate              = 10,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_G1_Selected_Source                = 11,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_G1_Z  = 12,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_G0_Z  = 13,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_Analog_Trigger            = 14,
         kRTSI_Shared_MUX_1_Output_SelectMUX_Out_Sel_AI_Start_Pulse            = 15,
      } tRTSI_Shared_MUX_1_Output_Select;
      inline tRTSI_Shared_MUX& setRTSI_Shared_MUX_1_Output_Select(tRTSI_Shared_MUX_1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Shared_MUX_1_Output_Select getRTSI_Shared_MUX_1_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Shared_MUX_1_Output_Select(tRTSI_Shared_MUX_1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Shared_MUX_1_Output_Select readRTSI_Shared_MUX_1_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI0  = 0,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI1  = 1,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI2  = 2,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI3  = 3,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI4  = 4,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_PFI5  = 5,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_AO_Gate_RTSI          = 6,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_AI_Gate_RTSI          = 7,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_Freq_Out      = 8,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_G1_Out    = 9,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_G1_Selected_Gate              = 10,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_G1_Selected_Source                = 11,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_G1_Z  = 12,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_G0_Z  = 13,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_Analog_Trigger            = 14,
         kRTSI_Shared_MUX_2_Output_SelectMUX_Out_Sel_AI_Start_Pulse            = 15,
      } tRTSI_Shared_MUX_2_Output_Select;
      inline tRTSI_Shared_MUX& setRTSI_Shared_MUX_2_Output_Select(tRTSI_Shared_MUX_2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Shared_MUX_2_Output_Select getRTSI_Shared_MUX_2_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Shared_MUX_2_Output_Select(tRTSI_Shared_MUX_2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Shared_MUX_2_Output_Select readRTSI_Shared_MUX_2_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI0  = 0,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI1  = 1,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI2  = 2,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI3  = 3,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI4  = 4,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_PFI5  = 5,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_AO_Gate_RTSI          = 6,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_AI_Gate_RTSI          = 7,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_Freq_Out      = 8,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_G1_Out    = 9,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_G1_Selected_Gate              = 10,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_G1_Selected_Source                = 11,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_G1_Z  = 12,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_G0_Z  = 13,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_Analog_Trigger            = 14,
         kRTSI_Shared_MUX_3_Output_SelectMUX_Out_Sel_AI_Start_Pulse            = 15,
      } tRTSI_Shared_MUX_3_Output_Select;
      inline tRTSI_Shared_MUX& setRTSI_Shared_MUX_3_Output_Select(tRTSI_Shared_MUX_3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Shared_MUX_3_Output_Select getRTSI_Shared_MUX_3_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Shared_MUX_3_Output_Select(tRTSI_Shared_MUX_3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Shared_MUX_3_Output_Select readRTSI_Shared_MUX_3_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // RTSI_Trig_A_Output
   //---------------------------------------------------------------------------
   class tRTSI_Trig_A_Output : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x19e,
         kId     = 49
      };
      tRTSI_Trig_A_Output();


      typedef enum {
         kRegisterId                          = 0,
         kRTSI0_Output_SelectId               = 1,
         kRTSI1_Output_SelectId               = 2,
         kRTSI2_Output_SelectId               = 3,
         kRTSI3_Output_SelectId               = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tRTSI_Trig_A_Output& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kRTSI0_Output_SelectADR_START1        = 0,
         kRTSI0_Output_SelectADR_START2        = 1,
         kRTSI0_Output_SelectSCLKG             = 2,
         kRTSI0_Output_SelectDACUPDN           = 3,
         kRTSI0_Output_SelectDA_START1         = 4,
         kRTSI0_Output_SelectG_SRC_0           = 5,
         kRTSI0_Output_SelectG_GATE_0          = 6,
         kRTSI0_Output_SelectRGOUT0            = 7,
         kRTSI0_Output_SelectRTSI_BRD_0        = 8,
         kRTSI0_Output_SelectRTSI_BRD_1        = 9,
         kRTSI0_Output_SelectRTSI_BRD_2        = 10,
         kRTSI0_Output_SelectRTSI_BRD_3        = 11,
         kRTSI0_Output_SelectRTSI_OSC          = 12,
      } tRTSI0_Output_Select;
      inline tRTSI_Trig_A_Output& setRTSI0_Output_Select(tRTSI0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI0_Output_Select getRTSI0_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI0_Output_Select(tRTSI0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI0_Output_Select readRTSI0_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI1_Output_SelectADR_START1        = 0,
         kRTSI1_Output_SelectADR_START2        = 1,
         kRTSI1_Output_SelectSCLKG             = 2,
         kRTSI1_Output_SelectDACUPDN           = 3,
         kRTSI1_Output_SelectDA_START1         = 4,
         kRTSI1_Output_SelectG_SRC_0           = 5,
         kRTSI1_Output_SelectG_GATE_0          = 6,
         kRTSI1_Output_SelectRGOUT0            = 7,
         kRTSI1_Output_SelectRTSI_BRD_0        = 8,
         kRTSI1_Output_SelectRTSI_BRD_1        = 9,
         kRTSI1_Output_SelectRTSI_BRD_2        = 10,
         kRTSI1_Output_SelectRTSI_BRD_3        = 11,
         kRTSI1_Output_SelectRTSI_OSC          = 12,
      } tRTSI1_Output_Select;
      inline tRTSI_Trig_A_Output& setRTSI1_Output_Select(tRTSI1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI1_Output_Select getRTSI1_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI1_Output_Select(tRTSI1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI1_Output_Select readRTSI1_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI2_Output_SelectADR_START1        = 0,
         kRTSI2_Output_SelectADR_START2        = 1,
         kRTSI2_Output_SelectSCLKG             = 2,
         kRTSI2_Output_SelectDACUPDN           = 3,
         kRTSI2_Output_SelectDA_START1         = 4,
         kRTSI2_Output_SelectG_SRC_0           = 5,
         kRTSI2_Output_SelectG_GATE_0          = 6,
         kRTSI2_Output_SelectRGOUT0            = 7,
         kRTSI2_Output_SelectRTSI_BRD_0        = 8,
         kRTSI2_Output_SelectRTSI_BRD_1        = 9,
         kRTSI2_Output_SelectRTSI_BRD_2        = 10,
         kRTSI2_Output_SelectRTSI_BRD_3        = 11,
         kRTSI2_Output_SelectRTSI_OSC          = 12,
      } tRTSI2_Output_Select;
      inline tRTSI_Trig_A_Output& setRTSI2_Output_Select(tRTSI2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI2_Output_Select getRTSI2_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI2_Output_Select(tRTSI2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI2_Output_Select readRTSI2_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI3_Output_SelectADR_START1        = 0,
         kRTSI3_Output_SelectADR_START2        = 1,
         kRTSI3_Output_SelectSCLKG             = 2,
         kRTSI3_Output_SelectDACUPDN           = 3,
         kRTSI3_Output_SelectDA_START1         = 4,
         kRTSI3_Output_SelectG_SRC_0           = 5,
         kRTSI3_Output_SelectG_GATE_0          = 6,
         kRTSI3_Output_SelectRGOUT0            = 7,
         kRTSI3_Output_SelectRTSI_BRD_0        = 8,
         kRTSI3_Output_SelectRTSI_BRD_1        = 9,
         kRTSI3_Output_SelectRTSI_BRD_2        = 10,
         kRTSI3_Output_SelectRTSI_BRD_3        = 11,
         kRTSI3_Output_SelectRTSI_OSC          = 12,
      } tRTSI3_Output_Select;
      inline tRTSI_Trig_A_Output& setRTSI3_Output_Select(tRTSI3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI3_Output_Select getRTSI3_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI3_Output_Select(tRTSI3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI3_Output_Select readRTSI3_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // RTSI_Trig_Direction
   //---------------------------------------------------------------------------
   class tRTSI_Trig_Direction : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x174,
         kId     = 50
      };
      tRTSI_Trig_Direction();


      typedef enum {
         kRegisterId                          = 0,
         kDrive_RTSI_OSCId                    = 1,
         kUse_RTSI_OSCId                      = 2,
         kRTSI_Sub_Selection_1Id              = 3,
         kRTSI0_Pin_DirId                     = 9,
         kRTSI1_Pin_DirId                     = 10,
         kRTSI2_Pin_DirId                     = 11,
         kRTSI3_Pin_DirId                     = 12,
         kRTSI4_Pin_DirId                     = 13,
         kRTSI5_Pin_DirId                     = 14,
         kRTSI6_Pin_DirId                     = 15,
         kRTSI7_Pin_DirId                     = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tRTSI_Trig_Direction& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tRTSI_Trig_Direction& setDrive_RTSI_OSC(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getDrive_RTSI_OSC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDrive_RTSI_OSC(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readDrive_RTSI_OSC(nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Trig_Direction& setUse_RTSI_OSC(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getUse_RTSI_OSC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUse_RTSI_OSC(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readUse_RTSI_OSC(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI_Sub_Selection_1G_OUT_0           = 0,
         kRTSI_Sub_Selection_1G_OUT_0_RTSI_IO_Pin     = 1,
      } tRTSI_Sub_Selection_1;
      inline tRTSI_Trig_Direction& setRTSI_Sub_Selection_1(tRTSI_Sub_Selection_1 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Sub_Selection_1 getRTSI_Sub_Selection_1(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Sub_Selection_1(tRTSI_Sub_Selection_1 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Sub_Selection_1 readRTSI_Sub_Selection_1(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI0_Pin_DirInput             = 0,
         kRTSI0_Pin_DirOutput            = 1,
      } tRTSI0_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI0_Pin_Dir(tRTSI0_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI0_Pin_Dir getRTSI0_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI0_Pin_Dir(tRTSI0_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI0_Pin_Dir readRTSI0_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI1_Pin_DirInput             = 0,
         kRTSI1_Pin_DirOutput            = 1,
      } tRTSI1_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI1_Pin_Dir(tRTSI1_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI1_Pin_Dir getRTSI1_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI1_Pin_Dir(tRTSI1_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI1_Pin_Dir readRTSI1_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI2_Pin_DirInput             = 0,
         kRTSI2_Pin_DirOutput            = 1,
      } tRTSI2_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI2_Pin_Dir(tRTSI2_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI2_Pin_Dir getRTSI2_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI2_Pin_Dir(tRTSI2_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI2_Pin_Dir readRTSI2_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI3_Pin_DirInput             = 0,
         kRTSI3_Pin_DirOutput            = 1,
      } tRTSI3_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI3_Pin_Dir(tRTSI3_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI3_Pin_Dir getRTSI3_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI3_Pin_Dir(tRTSI3_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI3_Pin_Dir readRTSI3_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI4_Pin_DirInput             = 0,
         kRTSI4_Pin_DirOutput            = 1,
      } tRTSI4_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI4_Pin_Dir(tRTSI4_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI4_Pin_Dir getRTSI4_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI4_Pin_Dir(tRTSI4_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI4_Pin_Dir readRTSI4_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI5_Pin_DirInput             = 0,
         kRTSI5_Pin_DirOutput            = 1,
      } tRTSI5_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI5_Pin_Dir(tRTSI5_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI5_Pin_Dir getRTSI5_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI5_Pin_Dir(tRTSI5_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI5_Pin_Dir readRTSI5_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI6_Pin_DirInput             = 0,
         kRTSI6_Pin_DirOutput            = 1,
      } tRTSI6_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI6_Pin_Dir(tRTSI6_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI6_Pin_Dir getRTSI6_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI6_Pin_Dir(tRTSI6_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI6_Pin_Dir readRTSI6_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI7_Pin_DirInput             = 0,
         kRTSI7_Pin_DirOutput            = 1,
      } tRTSI7_Pin_Dir;
      inline tRTSI_Trig_Direction& setRTSI7_Pin_Dir(tRTSI7_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI7_Pin_Dir getRTSI7_Pin_Dir(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI7_Pin_Dir(tRTSI7_Pin_Dir fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI7_Pin_Dir readRTSI7_Pin_Dir(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // RTSI_Trig_B_Output
   //---------------------------------------------------------------------------
   class tRTSI_Trig_B_Output : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1a0,
         kId     = 51
      };
      tRTSI_Trig_B_Output();


      typedef enum {
         kRegisterId                          = 0,
         kRTSI4_Output_SelectId               = 1,
         kRTSI5_Output_SelectId               = 2,
         kRTSI6_Output_SelectId               = 3,
         kRTSI7_Output_SelectId               = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tRTSI_Trig_B_Output& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kRTSI4_Output_SelectADR_START1        = 0,
         kRTSI4_Output_SelectADR_START2        = 1,
         kRTSI4_Output_SelectSCLKG             = 2,
         kRTSI4_Output_SelectDACUPDN           = 3,
         kRTSI4_Output_SelectDA_START1         = 4,
         kRTSI4_Output_SelectG_SRC_0           = 5,
         kRTSI4_Output_SelectG_GATE_0          = 6,
         kRTSI4_Output_SelectRGOUT0            = 7,
         kRTSI4_Output_SelectRTSI_BRD_0        = 8,
         kRTSI4_Output_SelectRTSI_BRD_1        = 9,
         kRTSI4_Output_SelectRTSI_BRD_2        = 10,
         kRTSI4_Output_SelectRTSI_BRD_3        = 11,
         kRTSI4_Output_SelectRTSI_OSC          = 12,
      } tRTSI4_Output_Select;
      inline tRTSI_Trig_B_Output& setRTSI4_Output_Select(tRTSI4_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI4_Output_Select getRTSI4_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI4_Output_Select(tRTSI4_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI4_Output_Select readRTSI4_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI5_Output_SelectADR_START1        = 0,
         kRTSI5_Output_SelectADR_START2        = 1,
         kRTSI5_Output_SelectSCLKG             = 2,
         kRTSI5_Output_SelectDACUPDN           = 3,
         kRTSI5_Output_SelectDA_START1         = 4,
         kRTSI5_Output_SelectG_SRC_0           = 5,
         kRTSI5_Output_SelectG_GATE_0          = 6,
         kRTSI5_Output_SelectRGOUT0            = 7,
         kRTSI5_Output_SelectRTSI_BRD_0        = 8,
         kRTSI5_Output_SelectRTSI_BRD_1        = 9,
         kRTSI5_Output_SelectRTSI_BRD_2        = 10,
         kRTSI5_Output_SelectRTSI_BRD_3        = 11,
         kRTSI5_Output_SelectRTSI_OSC          = 12,
      } tRTSI5_Output_Select;
      inline tRTSI_Trig_B_Output& setRTSI5_Output_Select(tRTSI5_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI5_Output_Select getRTSI5_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI5_Output_Select(tRTSI5_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI5_Output_Select readRTSI5_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI6_Output_SelectADR_START1        = 0,
         kRTSI6_Output_SelectADR_START2        = 1,
         kRTSI6_Output_SelectSCLKG             = 2,
         kRTSI6_Output_SelectDACUPDN           = 3,
         kRTSI6_Output_SelectDA_START1         = 4,
         kRTSI6_Output_SelectG_SRC_0           = 5,
         kRTSI6_Output_SelectG_GATE_0          = 6,
         kRTSI6_Output_SelectRGOUT0            = 7,
         kRTSI6_Output_SelectRTSI_BRD_0        = 8,
         kRTSI6_Output_SelectRTSI_BRD_1        = 9,
         kRTSI6_Output_SelectRTSI_BRD_2        = 10,
         kRTSI6_Output_SelectRTSI_BRD_3        = 11,
         kRTSI6_Output_SelectRTSI_OSC          = 12,
      } tRTSI6_Output_Select;
      inline tRTSI_Trig_B_Output& setRTSI6_Output_Select(tRTSI6_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI6_Output_Select getRTSI6_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI6_Output_Select(tRTSI6_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI6_Output_Select readRTSI6_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI7_Output_SelectADR_START1        = 0,
         kRTSI7_Output_SelectADR_START2        = 1,
         kRTSI7_Output_SelectSCLKG             = 2,
         kRTSI7_Output_SelectDACUPDN           = 3,
         kRTSI7_Output_SelectDA_START1         = 4,
         kRTSI7_Output_SelectG_SRC_0           = 5,
         kRTSI7_Output_SelectG_GATE_0          = 6,
         kRTSI7_Output_SelectRGOUT0            = 7,
         kRTSI7_Output_SelectRTSI_BRD_0        = 8,
         kRTSI7_Output_SelectRTSI_BRD_1        = 9,
         kRTSI7_Output_SelectRTSI_BRD_2        = 10,
         kRTSI7_Output_SelectRTSI_BRD_3        = 11,
         kRTSI7_Output_SelectRTSI_OSC          = 12,
      } tRTSI7_Output_Select;
      inline tRTSI_Trig_B_Output& setRTSI7_Output_Select(tRTSI7_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI7_Output_Select getRTSI7_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI7_Output_Select(tRTSI7_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI7_Output_Select readRTSI7_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // G0_DMA_Config
   //---------------------------------------------------------------------------
   class tG0_DMA_Config : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1b8,
         kId     = 52
      };
      tG0_DMA_Config();


      typedef enum {
         kRegisterId                          = 0,
         kG0_DMA_EnableId                     = 1,
         kG0_DMA_WriteId                      = 2,
         kG0_DMA_Int_EnableId                 = 3,
         kG0_DMA_ResetId                      = 4,
         kG0_DMA_BankSW_ErrorId               = 5
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tG0_DMA_Config& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tG0_DMA_Config& setG0_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_DMA_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Config& setG0_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_Write(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_DMA_Write(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Config& setG0_DMA_Int_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_Int_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_Int_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_DMA_Int_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Config& setG0_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_DMA_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Config& setG0_DMA_BankSW_Error(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_BankSW_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_BankSW_Error(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG0_DMA_BankSW_Error(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // G1_DMA_Config
   //---------------------------------------------------------------------------
   class tG1_DMA_Config : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1ba,
         kId     = 53
      };
      tG1_DMA_Config();


      typedef enum {
         kRegisterId                          = 0,
         kG1_DMA_EnableId                     = 1,
         kG1_DMA_WriteId                      = 2,
         kG1_DMA_Int_EnableId                 = 3,
         kG1_DMA_ResetId                      = 4,
         kG1_DMA_BankSW_ErrorId               = 5
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tG1_DMA_Config& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tG1_DMA_Config& setG1_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_DMA_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Config& setG1_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_Write(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_DMA_Write(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Config& setG1_DMA_Int_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_Int_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_Int_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_DMA_Int_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Config& setG1_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_DMA_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Config& setG1_DMA_BankSW_Error(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_BankSW_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_BankSW_Error(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readG1_DMA_BankSW_Error(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // G0_DMA_Status
   //---------------------------------------------------------------------------
   class tG0_DMA_Status : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1b8,
         kId     = 54
      };
      tG0_DMA_Status();


      typedef enum {
         kRegisterId                          = 0,
         kG0_PstatId                          = 1,
         kG0_DMA_ReadbankId                   = 7,
         kG0_DRQ_Error_StId                   = 8,
         kG0_DRQ_StId                         = 9
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tG0_DMA_Status& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tG0_DMA_Status& setG0_Pstat(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_Pstat(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG0_Pstat(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Status& setG0_DMA_Readbank(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DMA_Readbank(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG0_DMA_Readbank(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Status& setG0_DRQ_Error_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DRQ_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG0_DRQ_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_DMA_Status& setG0_DRQ_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG0_DRQ_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG0_DRQ_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // G1_DMA_Status
   //---------------------------------------------------------------------------
   class tG1_DMA_Status : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1ba,
         kId     = 55
      };
      tG1_DMA_Status();


      typedef enum {
         kRegisterId                          = 0,
         kG1_PstatId                          = 1,
         kG1_DMA_ReadbankId                   = 7,
         kG1_DRQ_Error_StId                   = 8,
         kG1_DRQ_StId                         = 9
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tG1_DMA_Status& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tG1_DMA_Status& setG1_Pstat(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_Pstat(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_Pstat(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Status& setG1_DMA_Readbank(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DMA_Readbank(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_DMA_Readbank(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Status& setG1_DRQ_Error_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DRQ_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_DRQ_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tG1_DMA_Status& setG1_DRQ_St(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getG1_DRQ_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readG1_DRQ_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDIO_DMA_Select
   //---------------------------------------------------------------------------
   class tCDIO_DMA_Select : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x7,
         kId     = 56
      };
      tCDIO_DMA_Select();


      typedef enum {
         kRegisterId                          = 0,
         kCDI_DMA_SelectId                    = 1,
         kCDO_DMA_SelectId                    = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDIO_DMA_Select& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDIO_DMA_Select& setCDI_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getCDI_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readCDI_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_DMA_Select& setCDO_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getCDO_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readCDO_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Control
   //---------------------------------------------------------------------------
   class tSCXI_Control : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x13,
         kId     = 57
      };
      tSCXI_Control();


      typedef enum {
         kRegisterId                          = 0,
         kSCXI_SW_SPIClkId                    = 1,
         kSCXI_Back_Plane_MISO_EnableId       = 2,
         kSCXI_Front_Panel_MISO_EnableId      = 3,
         kSCXI_IntrId                         = 4,
         kSCXI_D_AId                          = 5,
         kSCXI_HW_Serial_TimebaseId           = 6,
         kSCXI_HW_Serial_StartId              = 7,
         kSCXI_HW_Serial_EnableId             = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Control& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSCXI_Control& setSCXI_SW_SPIClk(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getSCXI_SW_SPIClk(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_SW_SPIClk(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readSCXI_SW_SPIClk(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_Back_Plane_MISO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getSCXI_Back_Plane_MISO_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Back_Plane_MISO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSCXI_Back_Plane_MISO_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_Front_Panel_MISO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getSCXI_Front_Panel_MISO_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Front_Panel_MISO_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSCXI_Front_Panel_MISO_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_Intr(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getSCXI_Intr(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Intr(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readSCXI_Intr(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_D_A(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getSCXI_D_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_D_A(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readSCXI_D_A(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_HW_Serial_Timebase100kHz            = 0,
         kSCXI_HW_Serial_Timebase1MHz              = 1,
      } tSCXI_HW_Serial_Timebase;
      inline tSCXI_Control& setSCXI_HW_Serial_Timebase(tSCXI_HW_Serial_Timebase fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_HW_Serial_Timebase getSCXI_HW_Serial_Timebase(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_HW_Serial_Timebase(tSCXI_HW_Serial_Timebase fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_HW_Serial_Timebase readSCXI_HW_Serial_Timebase(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_HW_Serial_Start(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getSCXI_HW_Serial_Start(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_HW_Serial_Start(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readSCXI_HW_Serial_Start(nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Control& setSCXI_HW_Serial_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getSCXI_HW_Serial_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_HW_Serial_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSCXI_HW_Serial_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Mode_1
   //---------------------------------------------------------------------------
   class tAI_Mode_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x118,
         kId     = 58
      };
      tAI_Mode_1();


      typedef enum {
         kRegisterId                          = 0,
         kAI_Trigger_OnceId                   = 1,
         kAI_ContinuousId                     = 2,
         kAI_Start_StopId                     = 4,
         kAI_SI_Source_PolarityId             = 5,
         kAI_CONVERT_Source_PolarityId        = 6,
         kAI_SI_Source_SelectId               = 7,
         kAI_CONVERT_Source_SelectId          = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Mode_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Mode_1& setAI_Trigger_Once(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Trigger_Once(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Trigger_Once(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Trigger_Once(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_1& setAI_Continuous(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Continuous(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Continuous(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Continuous(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Mode_1& setAI_Start_Stop(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Start_Stop(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Start_Stop(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Start_Stop(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI_Source_PolarityRising_Edge       = 0,
         kAI_SI_Source_PolarityFalling_Edge      = 1,
      } tAI_SI_Source_Polarity;
      inline tAI_Mode_1& setAI_SI_Source_Polarity(tAI_SI_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI_Source_Polarity getAI_SI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Source_Polarity(tAI_SI_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI_Source_Polarity readAI_SI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_CONVERT_Source_PolarityFalling_Edge      = 0,
         kAI_CONVERT_Source_PolarityRising_Edge       = 1,
      } tAI_CONVERT_Source_Polarity;
      inline tAI_Mode_1& setAI_CONVERT_Source_Polarity(tAI_CONVERT_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_CONVERT_Source_Polarity getAI_CONVERT_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_CONVERT_Source_Polarity(tAI_CONVERT_Source_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_CONVERT_Source_Polarity readAI_CONVERT_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_SI_Source_SelectGround            = 0,
         kAI_SI_Source_SelectPFI0              = 1,
         kAI_SI_Source_SelectPFI1              = 2,
         kAI_SI_Source_SelectPFI2              = 3,
         kAI_SI_Source_SelectPFI3              = 4,
         kAI_SI_Source_SelectPFI4              = 5,
         kAI_SI_Source_SelectPFI5              = 6,
         kAI_SI_Source_SelectPFI6              = 7,
         kAI_SI_Source_SelectPFI7              = 8,
         kAI_SI_Source_SelectPFI8              = 9,
         kAI_SI_Source_SelectPFI9              = 10,
         kAI_SI_Source_SelectRTSI0             = 11,
         kAI_SI_Source_SelectRTSI1             = 12,
         kAI_SI_Source_SelectRTSI2             = 13,
         kAI_SI_Source_SelectRTSI3             = 14,
         kAI_SI_Source_SelectRTSI4             = 15,
         kAI_SI_Source_SelectRTSI5             = 16,
         kAI_SI_Source_SelectRTSI6             = 17,
         kAI_SI_Source_SelectINTIMEBASE2       = 19,
         kAI_SI_Source_SelectStar_Trigger      = 20,
         kAI_SI_Source_SelectPFI10             = 21,
         kAI_SI_Source_SelectPFI11             = 22,
         kAI_SI_Source_SelectPFI12             = 23,
         kAI_SI_Source_SelectPFI13             = 24,
         kAI_SI_Source_SelectPFI14             = 25,
         kAI_SI_Source_SelectPFI15             = 26,
         kAI_SI_Source_SelectRTSI7             = 27,
         kAI_SI_Source_SelectINTIMEBASE1       = 28,
         kAI_SI_Source_SelectPXI_Clk10         = 29,
         kAI_SI_Source_SelectAnalog_Trigger    = 30,
         kAI_SI_Source_SelectLow               = 31,
      } tAI_SI_Source_Select;
      inline tAI_Mode_1& setAI_SI_Source_Select(tAI_SI_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_SI_Source_Select getAI_SI_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_SI_Source_Select(tAI_SI_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_SI_Source_Select readAI_SI_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_CONVERT_Source_SelectSI2TC             = 0,
         kAI_CONVERT_Source_SelectPFI0              = 1,
         kAI_CONVERT_Source_SelectPFI1              = 2,
         kAI_CONVERT_Source_SelectPFI2              = 3,
         kAI_CONVERT_Source_SelectPFI3              = 4,
         kAI_CONVERT_Source_SelectPFI4              = 5,
         kAI_CONVERT_Source_SelectPFI5              = 6,
         kAI_CONVERT_Source_SelectPFI6              = 7,
         kAI_CONVERT_Source_SelectPFI7              = 8,
         kAI_CONVERT_Source_SelectPFI8              = 9,
         kAI_CONVERT_Source_SelectPFI9              = 10,
         kAI_CONVERT_Source_SelectRTSI0             = 11,
         kAI_CONVERT_Source_SelectRTSI1             = 12,
         kAI_CONVERT_Source_SelectRTSI2             = 13,
         kAI_CONVERT_Source_SelectRTSI3             = 14,
         kAI_CONVERT_Source_SelectRTSI4             = 15,
         kAI_CONVERT_Source_SelectRTSI5             = 16,
         kAI_CONVERT_Source_SelectRTSI6             = 17,
         kAI_CONVERT_Source_SelectGPCtr1_Out        = 18,
         kAI_CONVERT_Source_SelectGPCtr0_Out        = 19,
         kAI_CONVERT_Source_SelectStar_Trigger      = 20,
         kAI_CONVERT_Source_SelectPFI10             = 21,
         kAI_CONVERT_Source_SelectPFI11             = 22,
         kAI_CONVERT_Source_SelectPFI12             = 23,
         kAI_CONVERT_Source_SelectPFI13             = 24,
         kAI_CONVERT_Source_SelectPFI14             = 25,
         kAI_CONVERT_Source_SelectPFI15             = 26,
         kAI_CONVERT_Source_SelectRTSI7             = 27,
         kAI_CONVERT_Source_SelectAnalog_Trigger    = 30,
         kAI_CONVERT_Source_SelectLow               = 31,
      } tAI_CONVERT_Source_Select;
      inline tAI_Mode_1& setAI_CONVERT_Source_Select(tAI_CONVERT_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_CONVERT_Source_Select getAI_CONVERT_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_CONVERT_Source_Select(tAI_CONVERT_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_CONVERT_Source_Select readAI_CONVERT_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_DIV_Load_A
   //---------------------------------------------------------------------------
   class tAI_DIV_Load_A : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x180,
         kId     = 59
      };
      tAI_DIV_Load_A();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_DIV_Load_A& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_DIV_Load_A& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Serial_Data_In
   //---------------------------------------------------------------------------
   class tSCXI_Serial_Data_In : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x9,
         kId     = 60
      };
      tSCXI_Serial_Data_In();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Serial_Data_In& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSCXI_Serial_Data_In& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Serial_Data_Out
   //---------------------------------------------------------------------------
   class tSCXI_Serial_Data_Out : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x11,
         kId     = 61
      };
      tSCXI_Serial_Data_Out();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Serial_Data_Out& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSCXI_Serial_Data_Out& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Status
   //---------------------------------------------------------------------------
   class tSCXI_Status : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x7,
         kId     = 62
      };
      tSCXI_Status();


      typedef enum {
         kRegisterId                          = 0,
         kSCXI_Shift_In_ProgId                = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Status& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSCXI_Status& setSCXI_Shift_In_Prog(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getSCXI_Shift_In_Prog(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readSCXI_Shift_In_Prog(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Output_Enable
   //---------------------------------------------------------------------------
   class tSCXI_Output_Enable : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x15,
         kId     = 63
      };
      tSCXI_Output_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kSCXI_Dedicated_Output_EnableId      = 1,
         kSCXI_Trig1_Output_EnableId          = 2,
         kSCXI_Trig0_Output_EnableId          = 3,
         kSCXI_Trig1_Output_SelectId          = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Output_Enable& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kSCXI_Dedicated_Output_EnableInput             = 0,
         kSCXI_Dedicated_Output_EnableOutput            = 1,
      } tSCXI_Dedicated_Output_Enable;
      inline tSCXI_Output_Enable& setSCXI_Dedicated_Output_Enable(tSCXI_Dedicated_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_Dedicated_Output_Enable getSCXI_Dedicated_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Dedicated_Output_Enable(tSCXI_Dedicated_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Dedicated_Output_Enable readSCXI_Dedicated_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_Trig1_Output_EnableInput             = 0,
         kSCXI_Trig1_Output_EnableOutput            = 1,
      } tSCXI_Trig1_Output_Enable;
      inline tSCXI_Output_Enable& setSCXI_Trig1_Output_Enable(tSCXI_Trig1_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_Trig1_Output_Enable getSCXI_Trig1_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Trig1_Output_Enable(tSCXI_Trig1_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Trig1_Output_Enable readSCXI_Trig1_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_Trig0_Output_EnableInput             = 0,
         kSCXI_Trig0_Output_EnableOutput            = 1,
      } tSCXI_Trig0_Output_Enable;
      inline tSCXI_Output_Enable& setSCXI_Trig0_Output_Enable(tSCXI_Trig0_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_Trig0_Output_Enable getSCXI_Trig0_Output_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Trig0_Output_Enable(tSCXI_Trig0_Output_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Trig0_Output_Enable readSCXI_Trig0_Output_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_Trig1_Output_SelectPFI0              = 0,
         kSCXI_Trig1_Output_SelectPFI1              = 1,
         kSCXI_Trig1_Output_SelectPFI2              = 2,
         kSCXI_Trig1_Output_SelectPFI3              = 3,
         kSCXI_Trig1_Output_SelectPFI4              = 4,
         kSCXI_Trig1_Output_SelectPFI5              = 5,
         kSCXI_Trig1_Output_SelectPFI6              = 6,
         kSCXI_Trig1_Output_SelectPFI7              = 7,
         kSCXI_Trig1_Output_SelectPFI8              = 8,
         kSCXI_Trig1_Output_SelectPFI9              = 9,
         kSCXI_Trig1_Output_SelectPFI10             = 10,
         kSCXI_Trig1_Output_SelectPFI11             = 11,
         kSCXI_Trig1_Output_SelectPFI12             = 12,
         kSCXI_Trig1_Output_SelectPFI13             = 13,
         kSCXI_Trig1_Output_SelectPFI14             = 14,
         kSCXI_Trig1_Output_SelectPFI15             = 15,
         kSCXI_Trig1_Output_SelectRTSI0             = 16,
         kSCXI_Trig1_Output_SelectRTSI1             = 17,
         kSCXI_Trig1_Output_SelectRTSI2             = 18,
         kSCXI_Trig1_Output_SelectRTSI3             = 19,
         kSCXI_Trig1_Output_SelectRTSI4             = 20,
         kSCXI_Trig1_Output_SelectRTSI5             = 21,
         kSCXI_Trig1_Output_SelectRTSI6             = 22,
         kSCXI_Trig1_Output_SelectRTSI7             = 23,
         kSCXI_Trig1_Output_SelectAI_Start          = 24,
         kSCXI_Trig1_Output_SelectLow               = 31,
      } tSCXI_Trig1_Output_Select;
      inline tSCXI_Output_Enable& setSCXI_Trig1_Output_Select(tSCXI_Trig1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_Trig1_Output_Select getSCXI_Trig1_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Trig1_Output_Select(tSCXI_Trig1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Trig1_Output_Select readSCXI_Trig1_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_DIO_Enable
   //---------------------------------------------------------------------------
   class tSCXI_DIO_Enable : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x21c,
         kId     = 64
      };
      tSCXI_DIO_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kSCXI_DIO_MOSI_EnableId              = 1,
         kSCXI_DIO_D_A_EnableId               = 2,
         kSCXI_DIO_Intr_EnableId              = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_DIO_Enable& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kSCXI_DIO_MOSI_EnableInput             = 0,
         kSCXI_DIO_MOSI_EnableOutput            = 1,
      } tSCXI_DIO_MOSI_Enable;
      inline tSCXI_DIO_Enable& setSCXI_DIO_MOSI_Enable(tSCXI_DIO_MOSI_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_DIO_MOSI_Enable getSCXI_DIO_MOSI_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_DIO_MOSI_Enable(tSCXI_DIO_MOSI_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_DIO_MOSI_Enable readSCXI_DIO_MOSI_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_DIO_D_A_EnableInput             = 0,
         kSCXI_DIO_D_A_EnableOutput            = 1,
      } tSCXI_DIO_D_A_Enable;
      inline tSCXI_DIO_Enable& setSCXI_DIO_D_A_Enable(tSCXI_DIO_D_A_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_DIO_D_A_Enable getSCXI_DIO_D_A_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_DIO_D_A_Enable(tSCXI_DIO_D_A_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_DIO_D_A_Enable readSCXI_DIO_D_A_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kSCXI_DIO_Intr_EnableInput             = 0,
         kSCXI_DIO_Intr_EnableOutput            = 1,
      } tSCXI_DIO_Intr_Enable;
      inline tSCXI_DIO_Enable& setSCXI_DIO_Intr_Enable(tSCXI_DIO_Intr_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_DIO_Intr_Enable getSCXI_DIO_Intr_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_DIO_Intr_Enable(tSCXI_DIO_Intr_Enable fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_DIO_Intr_Enable readSCXI_DIO_Intr_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Static_Digital_Output
   //---------------------------------------------------------------------------
   class tStatic_Digital_Output : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x24,
         kId     = 65
      };
      tStatic_Digital_Output();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tStatic_Digital_Output& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatic_Digital_Output& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Static_Digital_Input
   //---------------------------------------------------------------------------
   class tStatic_Digital_Input : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x24,
         kId     = 66
      };
      tStatic_Digital_Input();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tStatic_Digital_Input& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatic_Digital_Input& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Direction
   //---------------------------------------------------------------------------
   class tDIO_Direction : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x28,
         kId     = 67
      };
      tDIO_Direction();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Direction& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Direction& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Enable
   //---------------------------------------------------------------------------
   class tAO_Serial_Interrupt_Enable : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xa0,
         kId     = 68
      };
      tAO_Serial_Interrupt_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kAO_MUDS_0_Interrupt_EnableId        = 1,
         kAO_MUDS_1_Interrupt_EnableId        = 2,
         kAO_MUDS_2_Interrupt_EnableId        = 3,
         kAO_MUDS_3_Interrupt_EnableId        = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Enable& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Enable& setAO_MUDS_0_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_0_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_0_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_MUDS_0_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Enable& setAO_MUDS_1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_1_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_MUDS_1_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Enable& setAO_MUDS_2_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_2_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_2_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_MUDS_2_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Enable& setAO_MUDS_3_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_3_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_3_Interrupt_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_MUDS_3_Interrupt_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Ack
   //---------------------------------------------------------------------------
   class tAO_Serial_Interrupt_Ack : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xa1,
         kId     = 69
      };
      tAO_Serial_Interrupt_Ack();


      typedef enum {
         kRegisterId                          = 0,
         kAO_MUDS_0_Interrupt_AckId           = 1,
         kAO_MUDS_1_Interrupt_AckId           = 2,
         kAO_MUDS_2_Interrupt_AckId           = 3,
         kAO_MUDS_3_Interrupt_AckId           = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Ack& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Ack& setAO_MUDS_0_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_MUDS_0_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_0_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_MUDS_0_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Ack& setAO_MUDS_1_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_MUDS_1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_1_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_MUDS_1_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Ack& setAO_MUDS_2_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_MUDS_2_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_2_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_MUDS_2_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Ack& setAO_MUDS_3_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_MUDS_3_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_MUDS_3_Interrupt_Ack(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_MUDS_3_Interrupt_Ack(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Status
   //---------------------------------------------------------------------------
   class tAO_Serial_Interrupt_Status : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xa1,
         kId     = 70
      };
      tAO_Serial_Interrupt_Status();


      typedef enum {
         kRegisterId                          = 0,
         kAO_MUDS_0_Interrupt_StId            = 1,
         kAO_MUDS_1_Interrupt_StId            = 2,
         kAO_MUDS_2_Interrupt_StId            = 3,
         kAO_MUDS_3_Interrupt_StId            = 4
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Status& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Serial_Interrupt_Status& setAO_MUDS_0_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_0_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAO_MUDS_0_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Status& setAO_MUDS_1_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_1_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAO_MUDS_1_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Status& setAO_MUDS_2_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_2_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAO_MUDS_2_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Serial_Interrupt_Status& setAO_MUDS_3_Interrupt_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_MUDS_3_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readAO_MUDS_3_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_C_Enable
   //---------------------------------------------------------------------------
   class tInterrupt_C_Enable : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x88,
         kId     = 71
      };
      tInterrupt_C_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kInterrupt_Group_C_EnableId          = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_C_Enable& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_C_Enable& setInterrupt_Group_C_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getInterrupt_Group_C_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeInterrupt_Group_C_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readInterrupt_Group_C_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Interrupt_C_Status
   //---------------------------------------------------------------------------
   class tInterrupt_C_Status : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x88,
         kId     = 72
      };
      tInterrupt_C_Status();


      typedef enum {
         kRegisterId                          = 0,
         kInterrupt_Group_C_StatusId          = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_C_Status& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_C_Status& setInterrupt_Group_C_Status(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getInterrupt_Group_C_Status(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readInterrupt_Group_C_Status(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Analog_Trigger_Control
   //---------------------------------------------------------------------------
   class tAnalog_Trigger_Control : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x8c,
         kId     = 73
      };
      tAnalog_Trigger_Control();


      typedef enum {
         kRegisterId                          = 0,
         kAnalog_Trigger_SelectId             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAnalog_Trigger_Control& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kAnalog_Trigger_SelectAI_Chan           = 0,
         kAnalog_Trigger_SelectAPFI0             = 1,
         kAnalog_Trigger_SelectAPFI1             = 2,
         kAnalog_Trigger_SelectGround            = 3,
      } tAnalog_Trigger_Select;
      inline tAnalog_Trigger_Control& setAnalog_Trigger_Select(tAnalog_Trigger_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAnalog_Trigger_Select getAnalog_Trigger_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAnalog_Trigger_Select(tAnalog_Trigger_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAnalog_Trigger_Select readAnalog_Trigger_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_FIFO_Data
   //---------------------------------------------------------------------------
   class tAI_FIFO_Data : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1c,
         kId     = 74
      };
      tAI_FIFO_Data();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tAI_FIFO_Data& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_FIFO_Data& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_FIFO_Clear
   //---------------------------------------------------------------------------
   class tAI_FIFO_Clear : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1a6,
         kId     = 75
      };
      tAI_FIFO_Clear();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_FIFO_Clear& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_FIFO_Clear& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_AO_Select
   //---------------------------------------------------------------------------
   class tAI_AO_Select : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x9,
         kId     = 76
      };
      tAI_AO_Select();


      typedef enum {
         kRegisterId                          = 0,
         kAI_DMA_SelectId                     = 1,
         kAO_DMA_SelectId                     = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_AO_Select& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_AO_Select& setAI_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAI_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAI_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_AO_Select& setAO_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Config_FIFO_Data
   //---------------------------------------------------------------------------
   class tAI_Config_FIFO_Data : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x5e,
         kId     = 77
      };
      tAI_Config_FIFO_Data();


      typedef enum {
         kRegisterId                          = 0,
         kAI_Config_ChannelId                 = 1,
         kAI_Config_BankId                    = 2,
         kAI_Config_Channel_TypeId            = 3,
         kAI_Config_GainId                    = 4,
         kAI_Config_PolarityId                = 5,
         kAI_Config_DitherId                  = 6,
         kAI_Config_Last_ChannelId            = 7
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Config_FIFO_Data& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Config_FIFO_Data& setAI_Config_Channel(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Config_Channel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Channel(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Config_Channel(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Data& setAI_Config_Bank(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Config_Bank(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Bank(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Config_Bank(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_Config_Channel_TypeCalibration       = 0,
         kAI_Config_Channel_TypeDifferential      = 1,
         kAI_Config_Channel_TypeNRSE              = 2,
         kAI_Config_Channel_TypeRSE               = 3,
         kAI_Config_Channel_TypeAux               = 5,
         kAI_Config_Channel_TypeGhost             = 7,
      } tAI_Config_Channel_Type;
      inline tAI_Config_FIFO_Data& setAI_Config_Channel_Type(tAI_Config_Channel_Type fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_Config_Channel_Type getAI_Config_Channel_Type(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Channel_Type(tAI_Config_Channel_Type fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_Channel_Type readAI_Config_Channel_Type(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Data& setAI_Config_Gain(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getAI_Config_Gain(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Gain(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readAI_Config_Gain(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAI_Config_PolarityBipolar           = 0,
         kAI_Config_PolarityUnipolar          = 1,
      } tAI_Config_Polarity;
      inline tAI_Config_FIFO_Data& setAI_Config_Polarity(tAI_Config_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAI_Config_Polarity getAI_Config_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Polarity(tAI_Config_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_Polarity readAI_Config_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Data& setAI_Config_Dither(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Config_Dither(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Dither(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Config_Dither(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Data& setAI_Config_Last_Channel(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Config_Last_Channel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Config_Last_Channel(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Config_Last_Channel(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Configuration_Memory_Clear
   //---------------------------------------------------------------------------
   class tConfiguration_Memory_Clear : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1a4,
         kId     = 78
      };
      tConfiguration_Memory_Clear();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tConfiguration_Memory_Clear& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tConfiguration_Memory_Clear& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_FIFO_Data
   //---------------------------------------------------------------------------
   class tAO_FIFO_Data : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xa4,
         kId     = 79
      };
      tAO_FIFO_Data();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_FIFO_Data& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_FIFO_Data& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_FIFO_Clear
   //---------------------------------------------------------------------------
   class tAO_FIFO_Clear : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1a8,
         kId     = 80
      };
      tAO_FIFO_Clear();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_FIFO_Clear& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_FIFO_Clear& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // G0_G1_Select
   //---------------------------------------------------------------------------
   class tG0_G1_Select : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xb,
         kId     = 81
      };
      tG0_G1_Select();


      typedef enum {
         kRegisterId                          = 0,
         kG0_DMA_SelectId                     = 1,
         kG1_DMA_SelectId                     = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tG0_G1_Select& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tG0_G1_Select& setG0_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getG0_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG0_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readG0_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tG0_G1_Select& setG1_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getG1_DMA_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeG1_DMA_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readG1_DMA_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Misc_Command
   //---------------------------------------------------------------------------
   class tMisc_Command : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xf,
         kId     = 82
      };
      tMisc_Command();


      typedef enum {
         kRegisterId                          = 0,
         kIntExtTrigId                        = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tMisc_Command& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kIntExtTrigTRIG1             = 0,
         kIntExtTrigPGIA2             = 1,
      } tIntExtTrig;
      inline tMisc_Command& setIntExtTrig(tIntExtTrig fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tIntExtTrig getIntExtTrig(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeIntExtTrig(tIntExtTrig fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tIntExtTrig readIntExtTrig(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Calibration
   //---------------------------------------------------------------------------
   class tAO_Calibration : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xa3,
         kId     = 83
      };
      tAO_Calibration();


      typedef enum {
         kRegisterId                          = 0,
         kAO_RefGroundId                      = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Calibration& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Calibration& setAO_RefGround(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAO_RefGround(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_RefGround(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAO_RefGround(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_1
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_1 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1d0,
         kId     = 84
      };
      tPFI_Output_Select_1();


      typedef enum {
         kRegisterId                          = 0,
         kPFI0_Output_SelectId                = 1,
         kPFI1_Output_SelectId                = 2,
         kPFI2_Output_SelectId                = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_1& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI0_Output_SelectPFI_Default_Out   = 0,
         kPFI0_Output_SelectAI_Start1_PFI     = 1,
         kPFI0_Output_SelectAI_Start2_PFI     = 2,
         kPFI0_Output_SelectAI_Convert        = 3,
         kPFI0_Output_SelectG1_Selected_SRC   = 4,
         kPFI0_Output_SelectG1_Selected_GATE  = 5,
         kPFI0_Output_SelectAO_UPDATE_N       = 6,
         kPFI0_Output_SelectAO_Start1_PFI     = 7,
         kPFI0_Output_SelectAI_Start_Pulse    = 8,
         kPFI0_Output_SelectG0_Selected_SRC   = 9,
         kPFI0_Output_SelectG0_Selected_GATE  = 10,
         kPFI0_Output_SelectExtStrobe         = 11,
         kPFI0_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI0_Output_SelectG0_Out            = 13,
         kPFI0_Output_SelectG1_Out            = 14,
         kPFI0_Output_SelectFreq_Out          = 15,
         kPFI0_Output_SelectPFI_DO            = 16,
         kPFI0_Output_SelectI_Atrig           = 17,
         kPFI0_Output_SelectRTSI_Pin0         = 18,
         kPFI0_Output_SelectRTSI_Pin1         = 19,
         kPFI0_Output_SelectRTSI_Pin2         = 20,
         kPFI0_Output_SelectRTSI_Pin3         = 21,
         kPFI0_Output_SelectRTSI_Pin4         = 22,
         kPFI0_Output_SelectRTSI_Pin5         = 23,
         kPFI0_Output_SelectRTSI_Pin6         = 24,
         kPFI0_Output_SelectRTSI_Pin7         = 25,
         kPFI0_Output_SelectStar_Trig_In      = 26,
         kPFI0_Output_SelectSCXI_Trig1        = 27,
         kPFI0_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI0_Output_SelectCDI_Sample        = 29,
         kPFI0_Output_SelectCDO_Update        = 30,
      } tPFI0_Output_Select;
      inline tPFI_Output_Select_1& setPFI0_Output_Select(tPFI0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI0_Output_Select getPFI0_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI0_Output_Select(tPFI0_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI0_Output_Select readPFI0_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI1_Output_SelectPFI_Default_Out   = 0,
         kPFI1_Output_SelectAI_Start1_PFI     = 1,
         kPFI1_Output_SelectAI_Start2_PFI     = 2,
         kPFI1_Output_SelectAI_Convert        = 3,
         kPFI1_Output_SelectG1_Selected_SRC   = 4,
         kPFI1_Output_SelectG1_Selected_GATE  = 5,
         kPFI1_Output_SelectAO_UPDATE_N       = 6,
         kPFI1_Output_SelectAO_Start1_PFI     = 7,
         kPFI1_Output_SelectAI_Start_Pulse    = 8,
         kPFI1_Output_SelectG0_Selected_SRC   = 9,
         kPFI1_Output_SelectG0_Selected_GATE  = 10,
         kPFI1_Output_SelectExtStrobe         = 11,
         kPFI1_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI1_Output_SelectG0_Out            = 13,
         kPFI1_Output_SelectG1_Out            = 14,
         kPFI1_Output_SelectFreq_Out          = 15,
         kPFI1_Output_SelectPFI_DO            = 16,
         kPFI1_Output_SelectI_Atrig           = 17,
         kPFI1_Output_SelectRTSI_Pin0         = 18,
         kPFI1_Output_SelectRTSI_Pin1         = 19,
         kPFI1_Output_SelectRTSI_Pin2         = 20,
         kPFI1_Output_SelectRTSI_Pin3         = 21,
         kPFI1_Output_SelectRTSI_Pin4         = 22,
         kPFI1_Output_SelectRTSI_Pin5         = 23,
         kPFI1_Output_SelectRTSI_Pin6         = 24,
         kPFI1_Output_SelectRTSI_Pin7         = 25,
         kPFI1_Output_SelectStar_Trig_In      = 26,
         kPFI1_Output_SelectSCXI_Trig1        = 27,
         kPFI1_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI1_Output_SelectCDI_Sample        = 29,
         kPFI1_Output_SelectCDO_Update        = 30,
      } tPFI1_Output_Select;
      inline tPFI_Output_Select_1& setPFI1_Output_Select(tPFI1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI1_Output_Select getPFI1_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI1_Output_Select(tPFI1_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI1_Output_Select readPFI1_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI2_Output_SelectPFI_Default_Out   = 0,
         kPFI2_Output_SelectAI_Start1_PFI     = 1,
         kPFI2_Output_SelectAI_Start2_PFI     = 2,
         kPFI2_Output_SelectAI_Convert        = 3,
         kPFI2_Output_SelectG1_Selected_SRC   = 4,
         kPFI2_Output_SelectG1_Selected_GATE  = 5,
         kPFI2_Output_SelectAO_UPDATE_N       = 6,
         kPFI2_Output_SelectAO_Start1_PFI     = 7,
         kPFI2_Output_SelectAI_Start_Pulse    = 8,
         kPFI2_Output_SelectG0_Selected_SRC   = 9,
         kPFI2_Output_SelectG0_Selected_GATE  = 10,
         kPFI2_Output_SelectExtStrobe         = 11,
         kPFI2_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI2_Output_SelectG0_Out            = 13,
         kPFI2_Output_SelectG1_Out            = 14,
         kPFI2_Output_SelectFreq_Out          = 15,
         kPFI2_Output_SelectPFI_DO            = 16,
         kPFI2_Output_SelectI_Atrig           = 17,
         kPFI2_Output_SelectRTSI_Pin0         = 18,
         kPFI2_Output_SelectRTSI_Pin1         = 19,
         kPFI2_Output_SelectRTSI_Pin2         = 20,
         kPFI2_Output_SelectRTSI_Pin3         = 21,
         kPFI2_Output_SelectRTSI_Pin4         = 22,
         kPFI2_Output_SelectRTSI_Pin5         = 23,
         kPFI2_Output_SelectRTSI_Pin6         = 24,
         kPFI2_Output_SelectRTSI_Pin7         = 25,
         kPFI2_Output_SelectStar_Trig_In      = 26,
         kPFI2_Output_SelectSCXI_Trig1        = 27,
         kPFI2_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI2_Output_SelectCDI_Sample        = 29,
         kPFI2_Output_SelectCDO_Update        = 30,
      } tPFI2_Output_Select;
      inline tPFI_Output_Select_1& setPFI2_Output_Select(tPFI2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI2_Output_Select getPFI2_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI2_Output_Select(tPFI2_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI2_Output_Select readPFI2_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_2
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1d2,
         kId     = 85
      };
      tPFI_Output_Select_2();


      typedef enum {
         kRegisterId                          = 0,
         kPFI3_Output_SelectId                = 1,
         kPFI4_Output_SelectId                = 2,
         kPFI5_Output_SelectId                = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI3_Output_SelectPFI_Default_Out   = 0,
         kPFI3_Output_SelectAI_Start1_PFI     = 1,
         kPFI3_Output_SelectAI_Start2_PFI     = 2,
         kPFI3_Output_SelectAI_Convert        = 3,
         kPFI3_Output_SelectG1_Selected_SRC   = 4,
         kPFI3_Output_SelectG1_Selected_GATE  = 5,
         kPFI3_Output_SelectAO_UPDATE_N       = 6,
         kPFI3_Output_SelectAO_Start1_PFI     = 7,
         kPFI3_Output_SelectAI_Start_Pulse    = 8,
         kPFI3_Output_SelectG0_Selected_SRC   = 9,
         kPFI3_Output_SelectG0_Selected_GATE  = 10,
         kPFI3_Output_SelectExtStrobe         = 11,
         kPFI3_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI3_Output_SelectG0_Out            = 13,
         kPFI3_Output_SelectG1_Out            = 14,
         kPFI3_Output_SelectFreq_Out          = 15,
         kPFI3_Output_SelectPFI_DO            = 16,
         kPFI3_Output_SelectI_Atrig           = 17,
         kPFI3_Output_SelectRTSI_Pin0         = 18,
         kPFI3_Output_SelectRTSI_Pin1         = 19,
         kPFI3_Output_SelectRTSI_Pin2         = 20,
         kPFI3_Output_SelectRTSI_Pin3         = 21,
         kPFI3_Output_SelectRTSI_Pin4         = 22,
         kPFI3_Output_SelectRTSI_Pin5         = 23,
         kPFI3_Output_SelectRTSI_Pin6         = 24,
         kPFI3_Output_SelectRTSI_Pin7         = 25,
         kPFI3_Output_SelectStar_Trig_In      = 26,
         kPFI3_Output_SelectSCXI_Trig1        = 27,
         kPFI3_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI3_Output_SelectCDI_Sample        = 29,
         kPFI3_Output_SelectCDO_Update        = 30,
      } tPFI3_Output_Select;
      inline tPFI_Output_Select_2& setPFI3_Output_Select(tPFI3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI3_Output_Select getPFI3_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI3_Output_Select(tPFI3_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI3_Output_Select readPFI3_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI4_Output_SelectPFI_Default_Out   = 0,
         kPFI4_Output_SelectAI_Start1_PFI     = 1,
         kPFI4_Output_SelectAI_Start2_PFI     = 2,
         kPFI4_Output_SelectAI_Convert        = 3,
         kPFI4_Output_SelectG1_Selected_SRC   = 4,
         kPFI4_Output_SelectG1_Selected_GATE  = 5,
         kPFI4_Output_SelectAO_UPDATE_N       = 6,
         kPFI4_Output_SelectAO_Start1_PFI     = 7,
         kPFI4_Output_SelectAI_Start_Pulse    = 8,
         kPFI4_Output_SelectG0_Selected_SRC   = 9,
         kPFI4_Output_SelectG0_Selected_GATE  = 10,
         kPFI4_Output_SelectExtStrobe         = 11,
         kPFI4_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI4_Output_SelectG0_Out            = 13,
         kPFI4_Output_SelectG1_Out            = 14,
         kPFI4_Output_SelectFreq_Out          = 15,
         kPFI4_Output_SelectPFI_DO            = 16,
         kPFI4_Output_SelectI_Atrig           = 17,
         kPFI4_Output_SelectRTSI_Pin0         = 18,
         kPFI4_Output_SelectRTSI_Pin1         = 19,
         kPFI4_Output_SelectRTSI_Pin2         = 20,
         kPFI4_Output_SelectRTSI_Pin3         = 21,
         kPFI4_Output_SelectRTSI_Pin4         = 22,
         kPFI4_Output_SelectRTSI_Pin5         = 23,
         kPFI4_Output_SelectRTSI_Pin6         = 24,
         kPFI4_Output_SelectRTSI_Pin7         = 25,
         kPFI4_Output_SelectStar_Trig_In      = 26,
         kPFI4_Output_SelectSCXI_Trig1        = 27,
         kPFI4_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI4_Output_SelectCDI_Sample        = 29,
         kPFI4_Output_SelectCDO_Update        = 30,
      } tPFI4_Output_Select;
      inline tPFI_Output_Select_2& setPFI4_Output_Select(tPFI4_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI4_Output_Select getPFI4_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI4_Output_Select(tPFI4_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI4_Output_Select readPFI4_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI5_Output_SelectPFI_Default_Out   = 0,
         kPFI5_Output_SelectAI_Start1_PFI     = 1,
         kPFI5_Output_SelectAI_Start2_PFI     = 2,
         kPFI5_Output_SelectAI_Convert        = 3,
         kPFI5_Output_SelectG1_Selected_SRC   = 4,
         kPFI5_Output_SelectG1_Selected_GATE  = 5,
         kPFI5_Output_SelectAO_UPDATE_N       = 6,
         kPFI5_Output_SelectAO_Start1_PFI     = 7,
         kPFI5_Output_SelectAI_Start_Pulse    = 8,
         kPFI5_Output_SelectG0_Selected_SRC   = 9,
         kPFI5_Output_SelectG0_Selected_GATE  = 10,
         kPFI5_Output_SelectExtStrobe         = 11,
         kPFI5_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI5_Output_SelectG0_Out            = 13,
         kPFI5_Output_SelectG1_Out            = 14,
         kPFI5_Output_SelectFreq_Out          = 15,
         kPFI5_Output_SelectPFI_DO            = 16,
         kPFI5_Output_SelectI_Atrig           = 17,
         kPFI5_Output_SelectRTSI_Pin0         = 18,
         kPFI5_Output_SelectRTSI_Pin1         = 19,
         kPFI5_Output_SelectRTSI_Pin2         = 20,
         kPFI5_Output_SelectRTSI_Pin3         = 21,
         kPFI5_Output_SelectRTSI_Pin4         = 22,
         kPFI5_Output_SelectRTSI_Pin5         = 23,
         kPFI5_Output_SelectRTSI_Pin6         = 24,
         kPFI5_Output_SelectRTSI_Pin7         = 25,
         kPFI5_Output_SelectStar_Trig_In      = 26,
         kPFI5_Output_SelectSCXI_Trig1        = 27,
         kPFI5_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI5_Output_SelectCDI_Sample        = 29,
         kPFI5_Output_SelectCDO_Update        = 30,
      } tPFI5_Output_Select;
      inline tPFI_Output_Select_2& setPFI5_Output_Select(tPFI5_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI5_Output_Select getPFI5_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI5_Output_Select(tPFI5_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI5_Output_Select readPFI5_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_3
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_3 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1d4,
         kId     = 86
      };
      tPFI_Output_Select_3();


      typedef enum {
         kRegisterId                          = 0,
         kPFI6_Output_SelectId                = 1,
         kPFI7_Output_SelectId                = 2,
         kPFI8_Output_SelectId                = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_3& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI6_Output_SelectPFI_Default_Out   = 0,
         kPFI6_Output_SelectAI_Start1_PFI     = 1,
         kPFI6_Output_SelectAI_Start2_PFI     = 2,
         kPFI6_Output_SelectAI_Convert        = 3,
         kPFI6_Output_SelectG1_Selected_SRC   = 4,
         kPFI6_Output_SelectG1_Selected_GATE  = 5,
         kPFI6_Output_SelectAO_UPDATE_N       = 6,
         kPFI6_Output_SelectAO_Start1_PFI     = 7,
         kPFI6_Output_SelectAI_Start_Pulse    = 8,
         kPFI6_Output_SelectG0_Selected_SRC   = 9,
         kPFI6_Output_SelectG0_Selected_GATE  = 10,
         kPFI6_Output_SelectExtStrobe         = 11,
         kPFI6_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI6_Output_SelectG0_Out            = 13,
         kPFI6_Output_SelectG1_Out            = 14,
         kPFI6_Output_SelectFreq_Out          = 15,
         kPFI6_Output_SelectPFI_DO            = 16,
         kPFI6_Output_SelectI_Atrig           = 17,
         kPFI6_Output_SelectRTSI_Pin0         = 18,
         kPFI6_Output_SelectRTSI_Pin1         = 19,
         kPFI6_Output_SelectRTSI_Pin2         = 20,
         kPFI6_Output_SelectRTSI_Pin3         = 21,
         kPFI6_Output_SelectRTSI_Pin4         = 22,
         kPFI6_Output_SelectRTSI_Pin5         = 23,
         kPFI6_Output_SelectRTSI_Pin6         = 24,
         kPFI6_Output_SelectRTSI_Pin7         = 25,
         kPFI6_Output_SelectStar_Trig_In      = 26,
         kPFI6_Output_SelectSCXI_Trig1        = 27,
         kPFI6_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI6_Output_SelectCDI_Sample        = 29,
         kPFI6_Output_SelectCDO_Update        = 30,
      } tPFI6_Output_Select;
      inline tPFI_Output_Select_3& setPFI6_Output_Select(tPFI6_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI6_Output_Select getPFI6_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI6_Output_Select(tPFI6_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI6_Output_Select readPFI6_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI7_Output_SelectPFI_Default_Out   = 0,
         kPFI7_Output_SelectAI_Start1_PFI     = 1,
         kPFI7_Output_SelectAI_Start2_PFI     = 2,
         kPFI7_Output_SelectAI_Convert        = 3,
         kPFI7_Output_SelectG1_Selected_SRC   = 4,
         kPFI7_Output_SelectG1_Selected_GATE  = 5,
         kPFI7_Output_SelectAO_UPDATE_N       = 6,
         kPFI7_Output_SelectAO_Start1_PFI     = 7,
         kPFI7_Output_SelectAI_Start_Pulse    = 8,
         kPFI7_Output_SelectG0_Selected_SRC   = 9,
         kPFI7_Output_SelectG0_Selected_GATE  = 10,
         kPFI7_Output_SelectExtStrobe         = 11,
         kPFI7_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI7_Output_SelectG0_Out            = 13,
         kPFI7_Output_SelectG1_Out            = 14,
         kPFI7_Output_SelectFreq_Out          = 15,
         kPFI7_Output_SelectPFI_DO            = 16,
         kPFI7_Output_SelectI_Atrig           = 17,
         kPFI7_Output_SelectRTSI_Pin0         = 18,
         kPFI7_Output_SelectRTSI_Pin1         = 19,
         kPFI7_Output_SelectRTSI_Pin2         = 20,
         kPFI7_Output_SelectRTSI_Pin3         = 21,
         kPFI7_Output_SelectRTSI_Pin4         = 22,
         kPFI7_Output_SelectRTSI_Pin5         = 23,
         kPFI7_Output_SelectRTSI_Pin6         = 24,
         kPFI7_Output_SelectRTSI_Pin7         = 25,
         kPFI7_Output_SelectStar_Trig_In      = 26,
         kPFI7_Output_SelectSCXI_Trig1        = 27,
         kPFI7_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI7_Output_SelectCDI_Sample        = 29,
         kPFI7_Output_SelectCDO_Update        = 30,
      } tPFI7_Output_Select;
      inline tPFI_Output_Select_3& setPFI7_Output_Select(tPFI7_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI7_Output_Select getPFI7_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI7_Output_Select(tPFI7_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI7_Output_Select readPFI7_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI8_Output_SelectPFI_Default_Out   = 0,
         kPFI8_Output_SelectAI_Start1_PFI     = 1,
         kPFI8_Output_SelectAI_Start2_PFI     = 2,
         kPFI8_Output_SelectAI_Convert        = 3,
         kPFI8_Output_SelectG1_Selected_SRC   = 4,
         kPFI8_Output_SelectG1_Selected_GATE  = 5,
         kPFI8_Output_SelectAO_UPDATE_N       = 6,
         kPFI8_Output_SelectAO_Start1_PFI     = 7,
         kPFI8_Output_SelectAI_Start_Pulse    = 8,
         kPFI8_Output_SelectG0_Selected_SRC   = 9,
         kPFI8_Output_SelectG0_Selected_GATE  = 10,
         kPFI8_Output_SelectExtStrobe         = 11,
         kPFI8_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI8_Output_SelectG0_Out            = 13,
         kPFI8_Output_SelectG1_Out            = 14,
         kPFI8_Output_SelectFreq_Out          = 15,
         kPFI8_Output_SelectPFI_DO            = 16,
         kPFI8_Output_SelectI_Atrig           = 17,
         kPFI8_Output_SelectRTSI_Pin0         = 18,
         kPFI8_Output_SelectRTSI_Pin1         = 19,
         kPFI8_Output_SelectRTSI_Pin2         = 20,
         kPFI8_Output_SelectRTSI_Pin3         = 21,
         kPFI8_Output_SelectRTSI_Pin4         = 22,
         kPFI8_Output_SelectRTSI_Pin5         = 23,
         kPFI8_Output_SelectRTSI_Pin6         = 24,
         kPFI8_Output_SelectRTSI_Pin7         = 25,
         kPFI8_Output_SelectStar_Trig_In      = 26,
         kPFI8_Output_SelectSCXI_Trig1        = 27,
         kPFI8_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI8_Output_SelectCDI_Sample        = 29,
         kPFI8_Output_SelectCDO_Update        = 30,
      } tPFI8_Output_Select;
      inline tPFI_Output_Select_3& setPFI8_Output_Select(tPFI8_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI8_Output_Select getPFI8_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI8_Output_Select(tPFI8_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI8_Output_Select readPFI8_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_4
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_4 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1d6,
         kId     = 87
      };
      tPFI_Output_Select_4();


      typedef enum {
         kRegisterId                          = 0,
         kPFI9_Output_SelectId                = 1,
         kPFI10_Output_SelectId               = 2,
         kPFI11_Output_SelectId               = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_4& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI9_Output_SelectPFI_Default_Out   = 0,
         kPFI9_Output_SelectAI_Start1_PFI     = 1,
         kPFI9_Output_SelectAI_Start2_PFI     = 2,
         kPFI9_Output_SelectAI_Convert        = 3,
         kPFI9_Output_SelectG1_Selected_SRC   = 4,
         kPFI9_Output_SelectG1_Selected_GATE  = 5,
         kPFI9_Output_SelectAO_UPDATE_N       = 6,
         kPFI9_Output_SelectAO_Start1_PFI     = 7,
         kPFI9_Output_SelectAI_Start_Pulse    = 8,
         kPFI9_Output_SelectG0_Selected_SRC   = 9,
         kPFI9_Output_SelectG0_Selected_GATE  = 10,
         kPFI9_Output_SelectExtStrobe         = 11,
         kPFI9_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI9_Output_SelectG0_Out            = 13,
         kPFI9_Output_SelectG1_Out            = 14,
         kPFI9_Output_SelectFreq_Out          = 15,
         kPFI9_Output_SelectPFI_DO            = 16,
         kPFI9_Output_SelectI_Atrig           = 17,
         kPFI9_Output_SelectRTSI_Pin0         = 18,
         kPFI9_Output_SelectRTSI_Pin1         = 19,
         kPFI9_Output_SelectRTSI_Pin2         = 20,
         kPFI9_Output_SelectRTSI_Pin3         = 21,
         kPFI9_Output_SelectRTSI_Pin4         = 22,
         kPFI9_Output_SelectRTSI_Pin5         = 23,
         kPFI9_Output_SelectRTSI_Pin6         = 24,
         kPFI9_Output_SelectRTSI_Pin7         = 25,
         kPFI9_Output_SelectStar_Trig_In      = 26,
         kPFI9_Output_SelectSCXI_Trig1        = 27,
         kPFI9_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI9_Output_SelectCDI_Sample        = 29,
         kPFI9_Output_SelectCDO_Update        = 30,
      } tPFI9_Output_Select;
      inline tPFI_Output_Select_4& setPFI9_Output_Select(tPFI9_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI9_Output_Select getPFI9_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI9_Output_Select(tPFI9_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI9_Output_Select readPFI9_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI10_Output_SelectPFI_Default_Out   = 0,
         kPFI10_Output_SelectAI_Start1_PFI     = 1,
         kPFI10_Output_SelectAI_Start2_PFI     = 2,
         kPFI10_Output_SelectAI_Convert        = 3,
         kPFI10_Output_SelectG1_Selected_SRC   = 4,
         kPFI10_Output_SelectG1_Selected_GATE  = 5,
         kPFI10_Output_SelectAO_UPDATE_N       = 6,
         kPFI10_Output_SelectAO_Start1_PFI     = 7,
         kPFI10_Output_SelectAI_Start_Pulse    = 8,
         kPFI10_Output_SelectG0_Selected_SRC   = 9,
         kPFI10_Output_SelectG0_Selected_GATE  = 10,
         kPFI10_Output_SelectExtStrobe         = 11,
         kPFI10_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI10_Output_SelectG0_Out            = 13,
         kPFI10_Output_SelectG1_Out            = 14,
         kPFI10_Output_SelectFreq_Out          = 15,
         kPFI10_Output_SelectPFI_DO            = 16,
         kPFI10_Output_SelectI_Atrig           = 17,
         kPFI10_Output_SelectRTSI_Pin0         = 18,
         kPFI10_Output_SelectRTSI_Pin1         = 19,
         kPFI10_Output_SelectRTSI_Pin2         = 20,
         kPFI10_Output_SelectRTSI_Pin3         = 21,
         kPFI10_Output_SelectRTSI_Pin4         = 22,
         kPFI10_Output_SelectRTSI_Pin5         = 23,
         kPFI10_Output_SelectRTSI_Pin6         = 24,
         kPFI10_Output_SelectRTSI_Pin7         = 25,
         kPFI10_Output_SelectStar_Trig_In      = 26,
         kPFI10_Output_SelectSCXI_Trig1        = 27,
         kPFI10_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI10_Output_SelectCDI_Sample        = 29,
         kPFI10_Output_SelectCDO_Update        = 30,
      } tPFI10_Output_Select;
      inline tPFI_Output_Select_4& setPFI10_Output_Select(tPFI10_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI10_Output_Select getPFI10_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI10_Output_Select(tPFI10_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI10_Output_Select readPFI10_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI11_Output_SelectPFI_Default_Out   = 0,
         kPFI11_Output_SelectAI_Start1_PFI     = 1,
         kPFI11_Output_SelectAI_Start2_PFI     = 2,
         kPFI11_Output_SelectAI_Convert        = 3,
         kPFI11_Output_SelectG1_Selected_SRC   = 4,
         kPFI11_Output_SelectG1_Selected_GATE  = 5,
         kPFI11_Output_SelectAO_UPDATE_N       = 6,
         kPFI11_Output_SelectAO_Start1_PFI     = 7,
         kPFI11_Output_SelectAI_Start_Pulse    = 8,
         kPFI11_Output_SelectG0_Selected_SRC   = 9,
         kPFI11_Output_SelectG0_Selected_GATE  = 10,
         kPFI11_Output_SelectExtStrobe         = 11,
         kPFI11_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI11_Output_SelectG0_Out            = 13,
         kPFI11_Output_SelectG1_Out            = 14,
         kPFI11_Output_SelectFreq_Out          = 15,
         kPFI11_Output_SelectPFI_DO            = 16,
         kPFI11_Output_SelectI_Atrig           = 17,
         kPFI11_Output_SelectRTSI_Pin0         = 18,
         kPFI11_Output_SelectRTSI_Pin1         = 19,
         kPFI11_Output_SelectRTSI_Pin2         = 20,
         kPFI11_Output_SelectRTSI_Pin3         = 21,
         kPFI11_Output_SelectRTSI_Pin4         = 22,
         kPFI11_Output_SelectRTSI_Pin5         = 23,
         kPFI11_Output_SelectRTSI_Pin6         = 24,
         kPFI11_Output_SelectRTSI_Pin7         = 25,
         kPFI11_Output_SelectStar_Trig_In      = 26,
         kPFI11_Output_SelectSCXI_Trig1        = 27,
         kPFI11_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI11_Output_SelectCDI_Sample        = 29,
         kPFI11_Output_SelectCDO_Update        = 30,
      } tPFI11_Output_Select;
      inline tPFI_Output_Select_4& setPFI11_Output_Select(tPFI11_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI11_Output_Select getPFI11_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI11_Output_Select(tPFI11_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI11_Output_Select readPFI11_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_5
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_5 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1d8,
         kId     = 88
      };
      tPFI_Output_Select_5();


      typedef enum {
         kRegisterId                          = 0,
         kPFI12_Output_SelectId               = 1,
         kPFI13_Output_SelectId               = 2,
         kPFI14_Output_SelectId               = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_5& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI12_Output_SelectPFI_Default_Out   = 0,
         kPFI12_Output_SelectAI_Start1_PFI     = 1,
         kPFI12_Output_SelectAI_Start2_PFI     = 2,
         kPFI12_Output_SelectAI_Convert        = 3,
         kPFI12_Output_SelectG1_Selected_SRC   = 4,
         kPFI12_Output_SelectG1_Selected_GATE  = 5,
         kPFI12_Output_SelectAO_UPDATE_N       = 6,
         kPFI12_Output_SelectAO_Start1_PFI     = 7,
         kPFI12_Output_SelectAI_Start_Pulse    = 8,
         kPFI12_Output_SelectG0_Selected_SRC   = 9,
         kPFI12_Output_SelectG0_Selected_GATE  = 10,
         kPFI12_Output_SelectExtStrobe         = 11,
         kPFI12_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI12_Output_SelectG0_Out            = 13,
         kPFI12_Output_SelectG1_Out            = 14,
         kPFI12_Output_SelectFreq_Out          = 15,
         kPFI12_Output_SelectPFI_DO            = 16,
         kPFI12_Output_SelectI_Atrig           = 17,
         kPFI12_Output_SelectRTSI_Pin0         = 18,
         kPFI12_Output_SelectRTSI_Pin1         = 19,
         kPFI12_Output_SelectRTSI_Pin2         = 20,
         kPFI12_Output_SelectRTSI_Pin3         = 21,
         kPFI12_Output_SelectRTSI_Pin4         = 22,
         kPFI12_Output_SelectRTSI_Pin5         = 23,
         kPFI12_Output_SelectRTSI_Pin6         = 24,
         kPFI12_Output_SelectRTSI_Pin7         = 25,
         kPFI12_Output_SelectStar_Trig_In      = 26,
         kPFI12_Output_SelectSCXI_Trig1        = 27,
         kPFI12_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI12_Output_SelectCDI_Sample        = 29,
         kPFI12_Output_SelectCDO_Update        = 30,
      } tPFI12_Output_Select;
      inline tPFI_Output_Select_5& setPFI12_Output_Select(tPFI12_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI12_Output_Select getPFI12_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI12_Output_Select(tPFI12_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI12_Output_Select readPFI12_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI13_Output_SelectPFI_Default_Out   = 0,
         kPFI13_Output_SelectAI_Start1_PFI     = 1,
         kPFI13_Output_SelectAI_Start2_PFI     = 2,
         kPFI13_Output_SelectAI_Convert        = 3,
         kPFI13_Output_SelectG1_Selected_SRC   = 4,
         kPFI13_Output_SelectG1_Selected_GATE  = 5,
         kPFI13_Output_SelectAO_UPDATE_N       = 6,
         kPFI13_Output_SelectAO_Start1_PFI     = 7,
         kPFI13_Output_SelectAI_Start_Pulse    = 8,
         kPFI13_Output_SelectG0_Selected_SRC   = 9,
         kPFI13_Output_SelectG0_Selected_GATE  = 10,
         kPFI13_Output_SelectExtStrobe         = 11,
         kPFI13_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI13_Output_SelectG0_Out            = 13,
         kPFI13_Output_SelectG1_Out            = 14,
         kPFI13_Output_SelectFreq_Out          = 15,
         kPFI13_Output_SelectPFI_DO            = 16,
         kPFI13_Output_SelectI_Atrig           = 17,
         kPFI13_Output_SelectRTSI_Pin0         = 18,
         kPFI13_Output_SelectRTSI_Pin1         = 19,
         kPFI13_Output_SelectRTSI_Pin2         = 20,
         kPFI13_Output_SelectRTSI_Pin3         = 21,
         kPFI13_Output_SelectRTSI_Pin4         = 22,
         kPFI13_Output_SelectRTSI_Pin5         = 23,
         kPFI13_Output_SelectRTSI_Pin6         = 24,
         kPFI13_Output_SelectRTSI_Pin7         = 25,
         kPFI13_Output_SelectStar_Trig_In      = 26,
         kPFI13_Output_SelectSCXI_Trig1        = 27,
         kPFI13_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI13_Output_SelectCDI_Sample        = 29,
         kPFI13_Output_SelectCDO_Update        = 30,
      } tPFI13_Output_Select;
      inline tPFI_Output_Select_5& setPFI13_Output_Select(tPFI13_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI13_Output_Select getPFI13_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI13_Output_Select(tPFI13_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI13_Output_Select readPFI13_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI14_Output_SelectPFI_Default_Out   = 0,
         kPFI14_Output_SelectAI_Start1_PFI     = 1,
         kPFI14_Output_SelectAI_Start2_PFI     = 2,
         kPFI14_Output_SelectAI_Convert        = 3,
         kPFI14_Output_SelectG1_Selected_SRC   = 4,
         kPFI14_Output_SelectG1_Selected_GATE  = 5,
         kPFI14_Output_SelectAO_UPDATE_N       = 6,
         kPFI14_Output_SelectAO_Start1_PFI     = 7,
         kPFI14_Output_SelectAI_Start_Pulse    = 8,
         kPFI14_Output_SelectG0_Selected_SRC   = 9,
         kPFI14_Output_SelectG0_Selected_GATE  = 10,
         kPFI14_Output_SelectExtStrobe         = 11,
         kPFI14_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI14_Output_SelectG0_Out            = 13,
         kPFI14_Output_SelectG1_Out            = 14,
         kPFI14_Output_SelectFreq_Out          = 15,
         kPFI14_Output_SelectPFI_DO            = 16,
         kPFI14_Output_SelectI_Atrig           = 17,
         kPFI14_Output_SelectRTSI_Pin0         = 18,
         kPFI14_Output_SelectRTSI_Pin1         = 19,
         kPFI14_Output_SelectRTSI_Pin2         = 20,
         kPFI14_Output_SelectRTSI_Pin3         = 21,
         kPFI14_Output_SelectRTSI_Pin4         = 22,
         kPFI14_Output_SelectRTSI_Pin5         = 23,
         kPFI14_Output_SelectRTSI_Pin6         = 24,
         kPFI14_Output_SelectRTSI_Pin7         = 25,
         kPFI14_Output_SelectStar_Trig_In      = 26,
         kPFI14_Output_SelectSCXI_Trig1        = 27,
         kPFI14_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI14_Output_SelectCDI_Sample        = 29,
         kPFI14_Output_SelectCDO_Update        = 30,
      } tPFI14_Output_Select;
      inline tPFI_Output_Select_5& setPFI14_Output_Select(tPFI14_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI14_Output_Select getPFI14_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI14_Output_Select(tPFI14_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI14_Output_Select readPFI14_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Output_Select_6
   //---------------------------------------------------------------------------
   class tPFI_Output_Select_6 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1da,
         kId     = 89
      };
      tPFI_Output_Select_6();


      typedef enum {
         kRegisterId                          = 0,
         kPFI15_Output_SelectId               = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Output_Select_6& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI15_Output_SelectPFI_Default_Out   = 0,
         kPFI15_Output_SelectAI_Start1_PFI     = 1,
         kPFI15_Output_SelectAI_Start2_PFI     = 2,
         kPFI15_Output_SelectAI_Convert        = 3,
         kPFI15_Output_SelectG1_Selected_SRC   = 4,
         kPFI15_Output_SelectG1_Selected_GATE  = 5,
         kPFI15_Output_SelectAO_UPDATE_N       = 6,
         kPFI15_Output_SelectAO_Start1_PFI     = 7,
         kPFI15_Output_SelectAI_Start_Pulse    = 8,
         kPFI15_Output_SelectG0_Selected_SRC   = 9,
         kPFI15_Output_SelectG0_Selected_GATE  = 10,
         kPFI15_Output_SelectExtStrobe         = 11,
         kPFI15_Output_SelectAI_ExternalMUX_Clk    = 12,
         kPFI15_Output_SelectG0_Out            = 13,
         kPFI15_Output_SelectG1_Out            = 14,
         kPFI15_Output_SelectFreq_Out          = 15,
         kPFI15_Output_SelectPFI_DO            = 16,
         kPFI15_Output_SelectI_Atrig           = 17,
         kPFI15_Output_SelectRTSI_Pin0         = 18,
         kPFI15_Output_SelectRTSI_Pin1         = 19,
         kPFI15_Output_SelectRTSI_Pin2         = 20,
         kPFI15_Output_SelectRTSI_Pin3         = 21,
         kPFI15_Output_SelectRTSI_Pin4         = 22,
         kPFI15_Output_SelectRTSI_Pin5         = 23,
         kPFI15_Output_SelectRTSI_Pin6         = 24,
         kPFI15_Output_SelectRTSI_Pin7         = 25,
         kPFI15_Output_SelectStar_Trig_In      = 26,
         kPFI15_Output_SelectSCXI_Trig1        = 27,
         kPFI15_Output_SelectDIO_ChangeDetect_RTSI       = 28,
         kPFI15_Output_SelectCDI_Sample        = 29,
         kPFI15_Output_SelectCDO_Update        = 30,
      } tPFI15_Output_Select;
      inline tPFI_Output_Select_6& setPFI15_Output_Select(tPFI15_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI15_Output_Select getPFI15_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI15_Output_Select(tPFI15_Output_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI15_Output_Select readPFI15_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_DI
   //---------------------------------------------------------------------------
   class tPFI_DI : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1dc,
         kId     = 90
      };
      tPFI_DI();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tPFI_DI& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPFI_DI& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_DO
   //---------------------------------------------------------------------------
   class tPFI_DO : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1de,
         kId     = 91
      };
      tPFI_DO();


      typedef enum {
         kRegisterId                          = 0,
         kLowerPortId                         = 1,
         kUpperPortId                         = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_DO& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPFI_DO& setLowerPort(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getLowerPort(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeLowerPort(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readLowerPort(nMDBG::tStatus2* statusChain = NULL);

      inline tPFI_DO& setUpperPort(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getUpperPort(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUpperPort(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readUpperPort(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PFI_Filter
   //---------------------------------------------------------------------------
   class tPFI_Filter : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xb0,
         kId     = 92
      };
      tPFI_Filter();


      typedef enum {
         kRegisterId                          = 0,
         kPFI0_Filter_SelectId                = 1,
         kPFI1_Filter_SelectId                = 2,
         kPFI2_Filter_SelectId                = 3,
         kPFI3_Filter_SelectId                = 4,
         kPFI4_Filter_SelectId                = 5,
         kPFI5_Filter_SelectId                = 6,
         kPFI6_Filter_SelectId                = 7,
         kPFI7_Filter_SelectId                = 8,
         kPFI8_Filter_SelectId                = 9,
         kPFI9_Filter_SelectId                = 10,
         kPFI10_Filter_SelectId               = 11,
         kPFI11_Filter_SelectId               = 12,
         kPFI12_Filter_SelectId               = 13,
         kPFI13_Filter_SelectId               = 14,
         kPFI14_Filter_SelectId               = 15,
         kPFI15_Filter_SelectId               = 16
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPFI_Filter& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPFI0_Filter_SelectNoFilter          = 0,
         kPFI0_Filter_SelectSmallFilter       = 1,
         kPFI0_Filter_SelectMediumFilter      = 2,
         kPFI0_Filter_SelectLargeFilter       = 3,
         kPFI0_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI0_Filter_Select;
      inline tPFI_Filter& setPFI0_Filter_Select(tPFI0_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI0_Filter_Select getPFI0_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI0_Filter_Select(tPFI0_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI0_Filter_Select readPFI0_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI1_Filter_SelectNoFilter          = 0,
         kPFI1_Filter_SelectSmallFilter       = 1,
         kPFI1_Filter_SelectMediumFilter      = 2,
         kPFI1_Filter_SelectLargeFilter       = 3,
         kPFI1_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI1_Filter_Select;
      inline tPFI_Filter& setPFI1_Filter_Select(tPFI1_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI1_Filter_Select getPFI1_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI1_Filter_Select(tPFI1_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI1_Filter_Select readPFI1_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI2_Filter_SelectNoFilter          = 0,
         kPFI2_Filter_SelectSmallFilter       = 1,
         kPFI2_Filter_SelectMediumFilter      = 2,
         kPFI2_Filter_SelectLargeFilter       = 3,
         kPFI2_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI2_Filter_Select;
      inline tPFI_Filter& setPFI2_Filter_Select(tPFI2_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI2_Filter_Select getPFI2_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI2_Filter_Select(tPFI2_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI2_Filter_Select readPFI2_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI3_Filter_SelectNoFilter          = 0,
         kPFI3_Filter_SelectSmallFilter       = 1,
         kPFI3_Filter_SelectMediumFilter      = 2,
         kPFI3_Filter_SelectLargeFilter       = 3,
         kPFI3_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI3_Filter_Select;
      inline tPFI_Filter& setPFI3_Filter_Select(tPFI3_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI3_Filter_Select getPFI3_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI3_Filter_Select(tPFI3_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI3_Filter_Select readPFI3_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI4_Filter_SelectNoFilter          = 0,
         kPFI4_Filter_SelectSmallFilter       = 1,
         kPFI4_Filter_SelectMediumFilter      = 2,
         kPFI4_Filter_SelectLargeFilter       = 3,
         kPFI4_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI4_Filter_Select;
      inline tPFI_Filter& setPFI4_Filter_Select(tPFI4_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI4_Filter_Select getPFI4_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI4_Filter_Select(tPFI4_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI4_Filter_Select readPFI4_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI5_Filter_SelectNoFilter          = 0,
         kPFI5_Filter_SelectSmallFilter       = 1,
         kPFI5_Filter_SelectMediumFilter      = 2,
         kPFI5_Filter_SelectLargeFilter       = 3,
         kPFI5_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI5_Filter_Select;
      inline tPFI_Filter& setPFI5_Filter_Select(tPFI5_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI5_Filter_Select getPFI5_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI5_Filter_Select(tPFI5_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI5_Filter_Select readPFI5_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI6_Filter_SelectNoFilter          = 0,
         kPFI6_Filter_SelectSmallFilter       = 1,
         kPFI6_Filter_SelectMediumFilter      = 2,
         kPFI6_Filter_SelectLargeFilter       = 3,
         kPFI6_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI6_Filter_Select;
      inline tPFI_Filter& setPFI6_Filter_Select(tPFI6_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI6_Filter_Select getPFI6_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI6_Filter_Select(tPFI6_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI6_Filter_Select readPFI6_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI7_Filter_SelectNoFilter          = 0,
         kPFI7_Filter_SelectSmallFilter       = 1,
         kPFI7_Filter_SelectMediumFilter      = 2,
         kPFI7_Filter_SelectLargeFilter       = 3,
         kPFI7_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI7_Filter_Select;
      inline tPFI_Filter& setPFI7_Filter_Select(tPFI7_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI7_Filter_Select getPFI7_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI7_Filter_Select(tPFI7_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI7_Filter_Select readPFI7_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI8_Filter_SelectNoFilter          = 0,
         kPFI8_Filter_SelectSmallFilter       = 1,
         kPFI8_Filter_SelectMediumFilter      = 2,
         kPFI8_Filter_SelectLargeFilter       = 3,
         kPFI8_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI8_Filter_Select;
      inline tPFI_Filter& setPFI8_Filter_Select(tPFI8_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI8_Filter_Select getPFI8_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI8_Filter_Select(tPFI8_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI8_Filter_Select readPFI8_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI9_Filter_SelectNoFilter          = 0,
         kPFI9_Filter_SelectSmallFilter       = 1,
         kPFI9_Filter_SelectMediumFilter      = 2,
         kPFI9_Filter_SelectLargeFilter       = 3,
         kPFI9_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI9_Filter_Select;
      inline tPFI_Filter& setPFI9_Filter_Select(tPFI9_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI9_Filter_Select getPFI9_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI9_Filter_Select(tPFI9_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI9_Filter_Select readPFI9_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI10_Filter_SelectNoFilter          = 0,
         kPFI10_Filter_SelectSmallFilter       = 1,
         kPFI10_Filter_SelectMediumFilter      = 2,
         kPFI10_Filter_SelectLargeFilter       = 3,
         kPFI10_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI10_Filter_Select;
      inline tPFI_Filter& setPFI10_Filter_Select(tPFI10_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI10_Filter_Select getPFI10_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI10_Filter_Select(tPFI10_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI10_Filter_Select readPFI10_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI11_Filter_SelectNoFilter          = 0,
         kPFI11_Filter_SelectSmallFilter       = 1,
         kPFI11_Filter_SelectMediumFilter      = 2,
         kPFI11_Filter_SelectLargeFilter       = 3,
         kPFI11_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI11_Filter_Select;
      inline tPFI_Filter& setPFI11_Filter_Select(tPFI11_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI11_Filter_Select getPFI11_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI11_Filter_Select(tPFI11_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI11_Filter_Select readPFI11_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI12_Filter_SelectNoFilter          = 0,
         kPFI12_Filter_SelectSmallFilter       = 1,
         kPFI12_Filter_SelectMediumFilter      = 2,
         kPFI12_Filter_SelectLargeFilter       = 3,
         kPFI12_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI12_Filter_Select;
      inline tPFI_Filter& setPFI12_Filter_Select(tPFI12_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI12_Filter_Select getPFI12_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI12_Filter_Select(tPFI12_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI12_Filter_Select readPFI12_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI13_Filter_SelectNoFilter          = 0,
         kPFI13_Filter_SelectSmallFilter       = 1,
         kPFI13_Filter_SelectMediumFilter      = 2,
         kPFI13_Filter_SelectLargeFilter       = 3,
         kPFI13_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI13_Filter_Select;
      inline tPFI_Filter& setPFI13_Filter_Select(tPFI13_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI13_Filter_Select getPFI13_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI13_Filter_Select(tPFI13_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI13_Filter_Select readPFI13_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI14_Filter_SelectNoFilter          = 0,
         kPFI14_Filter_SelectSmallFilter       = 1,
         kPFI14_Filter_SelectMediumFilter      = 2,
         kPFI14_Filter_SelectLargeFilter       = 3,
         kPFI14_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI14_Filter_Select;
      inline tPFI_Filter& setPFI14_Filter_Select(tPFI14_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI14_Filter_Select getPFI14_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI14_Filter_Select(tPFI14_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI14_Filter_Select readPFI14_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPFI15_Filter_SelectNoFilter          = 0,
         kPFI15_Filter_SelectSmallFilter       = 1,
         kPFI15_Filter_SelectMediumFilter      = 2,
         kPFI15_Filter_SelectLargeFilter       = 3,
         kPFI15_Filter_SelectIllegalFilterSetting      = 4,
      } tPFI15_Filter_Select;
      inline tPFI_Filter& setPFI15_Filter_Select(tPFI15_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPFI15_Filter_Select getPFI15_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePFI15_Filter_Select(tPFI15_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPFI15_Filter_Select readPFI15_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // RTSI_Filter
   //---------------------------------------------------------------------------
   class tRTSI_Filter : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xb4,
         kId     = 93
      };
      tRTSI_Filter();


      typedef enum {
         kRegisterId                          = 0,
         kRTSI0_Filter_SelectId               = 1,
         kRTSI1_Filter_SelectId               = 2,
         kRTSI2_Filter_SelectId               = 3,
         kRTSI3_Filter_SelectId               = 4,
         kRTSI4_Filter_SelectId               = 5,
         kRTSI5_Filter_SelectId               = 6,
         kRTSI6_Filter_SelectId               = 7,
         kRTSI7_Filter_SelectId               = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tRTSI_Filter& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kRTSI0_Filter_SelectNoFilter          = 0,
         kRTSI0_Filter_SelectSmallFilter       = 1,
         kRTSI0_Filter_SelectMediumFilter      = 2,
         kRTSI0_Filter_SelectLargeFilter       = 3,
         kRTSI0_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI0_Filter_Select;
      inline tRTSI_Filter& setRTSI0_Filter_Select(tRTSI0_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI0_Filter_Select getRTSI0_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI0_Filter_Select(tRTSI0_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI0_Filter_Select readRTSI0_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI1_Filter_SelectNoFilter          = 0,
         kRTSI1_Filter_SelectSmallFilter       = 1,
         kRTSI1_Filter_SelectMediumFilter      = 2,
         kRTSI1_Filter_SelectLargeFilter       = 3,
         kRTSI1_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI1_Filter_Select;
      inline tRTSI_Filter& setRTSI1_Filter_Select(tRTSI1_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI1_Filter_Select getRTSI1_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI1_Filter_Select(tRTSI1_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI1_Filter_Select readRTSI1_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI2_Filter_SelectNoFilter          = 0,
         kRTSI2_Filter_SelectSmallFilter       = 1,
         kRTSI2_Filter_SelectMediumFilter      = 2,
         kRTSI2_Filter_SelectLargeFilter       = 3,
         kRTSI2_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI2_Filter_Select;
      inline tRTSI_Filter& setRTSI2_Filter_Select(tRTSI2_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI2_Filter_Select getRTSI2_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI2_Filter_Select(tRTSI2_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI2_Filter_Select readRTSI2_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI3_Filter_SelectNoFilter          = 0,
         kRTSI3_Filter_SelectSmallFilter       = 1,
         kRTSI3_Filter_SelectMediumFilter      = 2,
         kRTSI3_Filter_SelectLargeFilter       = 3,
         kRTSI3_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI3_Filter_Select;
      inline tRTSI_Filter& setRTSI3_Filter_Select(tRTSI3_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI3_Filter_Select getRTSI3_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI3_Filter_Select(tRTSI3_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI3_Filter_Select readRTSI3_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI4_Filter_SelectNoFilter          = 0,
         kRTSI4_Filter_SelectSmallFilter       = 1,
         kRTSI4_Filter_SelectMediumFilter      = 2,
         kRTSI4_Filter_SelectLargeFilter       = 3,
         kRTSI4_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI4_Filter_Select;
      inline tRTSI_Filter& setRTSI4_Filter_Select(tRTSI4_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI4_Filter_Select getRTSI4_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI4_Filter_Select(tRTSI4_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI4_Filter_Select readRTSI4_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI5_Filter_SelectNoFilter          = 0,
         kRTSI5_Filter_SelectSmallFilter       = 1,
         kRTSI5_Filter_SelectMediumFilter      = 2,
         kRTSI5_Filter_SelectLargeFilter       = 3,
         kRTSI5_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI5_Filter_Select;
      inline tRTSI_Filter& setRTSI5_Filter_Select(tRTSI5_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI5_Filter_Select getRTSI5_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI5_Filter_Select(tRTSI5_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI5_Filter_Select readRTSI5_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI6_Filter_SelectNoFilter          = 0,
         kRTSI6_Filter_SelectSmallFilter       = 1,
         kRTSI6_Filter_SelectMediumFilter      = 2,
         kRTSI6_Filter_SelectLargeFilter       = 3,
         kRTSI6_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI6_Filter_Select;
      inline tRTSI_Filter& setRTSI6_Filter_Select(tRTSI6_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI6_Filter_Select getRTSI6_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI6_Filter_Select(tRTSI6_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI6_Filter_Select readRTSI6_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI7_Filter_SelectNoFilter          = 0,
         kRTSI7_Filter_SelectSmallFilter       = 1,
         kRTSI7_Filter_SelectMediumFilter      = 2,
         kRTSI7_Filter_SelectLargeFilter       = 3,
         kRTSI7_Filter_SelectIllegalFilterSetting      = 4,
      } tRTSI7_Filter_Select;
      inline tRTSI_Filter& setRTSI7_Filter_Select(tRTSI7_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI7_Filter_Select getRTSI7_Filter_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI7_Filter_Select(tRTSI7_Filter_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI7_Filter_Select readRTSI7_Filter_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Clock_And_Fout2
   //---------------------------------------------------------------------------
   class tClock_And_Fout2 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1c4,
         kId     = 94
      };
      tClock_And_Fout2();


      typedef enum {
         kRegisterId                          = 0,
         kPLL_In_Source_SelectId              = 1,
         kTB1_SelectId                        = 2,
         kTB3_SelectId                        = 3,
         kRTSI_Clock_FreqId                   = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tClock_And_Fout2& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kPLL_In_Source_SelectOld_RTSI7         = 0,
         kPLL_In_Source_SelectRTSI0             = 11,
         kPLL_In_Source_SelectRTSI1             = 12,
         kPLL_In_Source_SelectRTSI2             = 13,
         kPLL_In_Source_SelectRTSI3             = 14,
         kPLL_In_Source_SelectRTSI4             = 15,
         kPLL_In_Source_SelectRTSI5             = 16,
         kPLL_In_Source_SelectRTSI6             = 17,
         kPLL_In_Source_SelectStar_Trigger      = 20,
         kPLL_In_Source_SelectRTSI7             = 27,
         kPLL_In_Source_SelectPXI_Clock10       = 29,
      } tPLL_In_Source_Select;
      inline tClock_And_Fout2& setPLL_In_Source_Select(tPLL_In_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPLL_In_Source_Select getPLL_In_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePLL_In_Source_Select(tPLL_In_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPLL_In_Source_Select readPLL_In_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kTB1_SelectSelect_OSC        = 0,
         kTB1_SelectSelect_PLL        = 1,
      } tTB1_Select;
      inline tClock_And_Fout2& setTB1_Select(tTB1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tTB1_Select getTB1_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeTB1_Select(tTB1_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tTB1_Select readTB1_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kTB3_SelectSelect_OSC        = 0,
         kTB3_SelectSelect_PLL        = 1,
      } tTB3_Select;
      inline tClock_And_Fout2& setTB3_Select(tTB3_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tTB3_Select getTB3_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeTB3_Select(tTB3_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tTB3_Select readTB3_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kRTSI_Clock_Freq20MHz             = 0,
         kRTSI_Clock_Freq10MHz             = 1,
      } tRTSI_Clock_Freq;
      inline tClock_And_Fout2& setRTSI_Clock_Freq(tRTSI_Clock_Freq fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tRTSI_Clock_Freq getRTSI_Clock_Freq(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeRTSI_Clock_Freq(tRTSI_Clock_Freq fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tRTSI_Clock_Freq readRTSI_Clock_Freq(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PLL_Control
   //---------------------------------------------------------------------------
   class tPLL_Control : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1c6,
         kId     = 95
      };
      tPLL_Control();


      typedef enum {
         kRegisterId                          = 0,
         kPLL_MultiplierId                    = 1,
         kPLL_DivisorId                       = 2,
         kPLL_EnableId                        = 3,
         kPLL_VCO_ModeId                      = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tPLL_Control& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPLL_Control& setPLL_Multiplier(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getPLL_Multiplier(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePLL_Multiplier(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readPLL_Multiplier(nMDBG::tStatus2* statusChain = NULL);

      inline tPLL_Control& setPLL_Divisor(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getPLL_Divisor(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePLL_Divisor(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readPLL_Divisor(nMDBG::tStatus2* statusChain = NULL);

      inline tPLL_Control& setPLL_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getPLL_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePLL_Enable(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readPLL_Enable(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kPLL_VCO_ModeMode1_200_325MHz  = 0,
         kPLL_VCO_ModeMode2_175_225MHz  = 1,
         kPLL_VCO_ModeMode3_100_225MHz  = 2,
         kPLL_VCO_ModeMode4_75_150MHz   = 3,
      } tPLL_VCO_Mode;
      inline tPLL_Control& setPLL_VCO_Mode(tPLL_VCO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tPLL_VCO_Mode getPLL_VCO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePLL_VCO_Mode(tPLL_VCO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tPLL_VCO_Mode readPLL_VCO_Mode(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // PLL_Status
   //---------------------------------------------------------------------------
   class tPLL_Status : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x1c8,
         kId     = 96
      };
      tPLL_Status();


      typedef enum {
         kRegisterId                          = 0,
         kPLL_LockedId                        = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tPLL_Status& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPLL_Status& setPLL_Locked(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getPLL_Locked(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readPLL_Locked(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AI_Config_FIFO_Bypass
   //---------------------------------------------------------------------------
   class tAI_Config_FIFO_Bypass : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x218,
         kId     = 97
      };
      tAI_Config_FIFO_Bypass();


      typedef enum {
         kRegisterId                          = 0,
         kAI_Bypass_ChannelId                 = 1,
         kAI_Bypass_BankId                    = 2,
         kAI_Bypass_Cal_Sel_PosId             = 3,
         kAI_Bypass_Cal_Sel_NegId             = 4,
         kAI_Bypass_Mode_MuxId                = 5,
         kAO_Bypass_AO_Cal_SelId              = 6,
         kAI_Bypass_GainId                    = 7,
         kAI_Bypass_DitherId                  = 8,
         kAI_Bypass_PolarityId                = 9,
         kAI_Bypass_Config_FIFOId             = 18
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAI_Config_FIFO_Bypass& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Channel(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Channel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Channel(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Channel(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Bank(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Bank(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Bank(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Bank(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Cal_Sel_Pos(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Cal_Sel_Pos(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Cal_Sel_Pos(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Cal_Sel_Pos(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Cal_Sel_Neg(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Cal_Sel_Neg(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Cal_Sel_Neg(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Cal_Sel_Neg(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Mode_Mux(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Mode_Mux(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Mode_Mux(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Mode_Mux(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAO_Bypass_AO_Cal_Sel(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAO_Bypass_AO_Cal_Sel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Bypass_AO_Cal_Sel(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAO_Bypass_AO_Cal_Sel(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Gain(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Gain(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Gain(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Gain(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Dither(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Bypass_Dither(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Dither(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Bypass_Dither(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Polarity(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getAI_Bypass_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Polarity(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAI_Bypass_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tAI_Config_FIFO_Bypass& setAI_Bypass_Config_FIFO(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getAI_Bypass_Config_FIFO(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAI_Bypass_Config_FIFO(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAI_Bypass_Config_FIFO(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDI_FIFO_Data
   //---------------------------------------------------------------------------
   class tCDI_FIFO_Data : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x220,
         kId     = 98
      };
      tCDI_FIFO_Data();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tCDI_FIFO_Data& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDI_FIFO_Data& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDO_FIFO_Data
   //---------------------------------------------------------------------------
   class tCDO_FIFO_Data : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x220,
         kId     = 99
      };
      tCDO_FIFO_Data();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDO_FIFO_Data& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDO_FIFO_Data& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDIO_Status
   //---------------------------------------------------------------------------
   class tCDIO_Status : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x224,
         kId     = 100
      };
      tCDIO_Status();


      typedef enum {
         kRegisterId                          = 0,
         kCDO_FIFO_Empty_StId                 = 1,
         kCDO_FIFO_Full_StId                  = 2,
         kCDO_FIFO_Request_StId               = 3,
         kCDO_Overrun_StId                    = 4,
         kCDO_Underflow_StId                  = 5,
         kCDI_FIFO_Empty_StId                 = 17,
         kCDI_FIFO_Full_StId                  = 18,
         kCDI_FIFO_Request_StId               = 19,
         kCDI_Overrun_StId                    = 20,
         kCDI_Overflow_StId                   = 21
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tCDIO_Status& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDIO_Status& setCDO_FIFO_Empty_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDO_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDO_FIFO_Full_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDO_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDO_FIFO_Request_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDO_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDO_Overrun_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_Overrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDO_Overrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDO_Underflow_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_Underflow_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDO_Underflow_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDI_FIFO_Empty_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDI_FIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDI_FIFO_Full_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDI_FIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDI_FIFO_Request_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDI_FIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDI_Overrun_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_Overrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDI_Overrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Status& setCDI_Overflow_St(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_Overflow_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline tBoolean readCDI_Overflow_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDIO_Command
   //---------------------------------------------------------------------------
   class tCDIO_Command : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x224,
         kId     = 101
      };
      tCDIO_Command();


      typedef enum {
         kRegisterId                          = 0,
         kCDO_DisarmId                        = 1,
         kCDO_ArmId                           = 2,
         kCDI_DisarmId                        = 3,
         kCDI_ArmId                           = 4,
         kCDO_ResetId                         = 5,
         kCDI_ResetId                         = 6,
         kCDO_Error_Interrupt_Enable_SetId    = 7,
         kCDO_Error_Interrupt_Enable_ClearId  = 8,
         kCDI_Error_Interrupt_Enable_SetId    = 9,
         kCDI_Error_Interrupt_Enable_ClearId  = 10,
         kCDO_FIFO_Request_Interrupt_Enable_SetId       = 11,
         kCDO_FIFO_Request_Interrupt_Enable_ClearId         = 12,
         kCDI_FIFO_Request_Interrupt_Enable_SetId       = 13,
         kCDI_FIFO_Request_Interrupt_Enable_ClearId         = 14,
         kCDO_Error_Interrupt_ConfirmId       = 15,
         kCDI_Error_Interrupt_ConfirmId       = 16,
         kCDO_Empty_FIFO_Interrupt_Enable_SetId     = 17,
         kCDO_Empty_FIFO_Interrupt_Enable_ClearId       = 18,
         kCDO_SW_UpdateId                     = 20,
         kCDI_SW_SampleId                     = 21
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDIO_Command& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDIO_Command& setCDO_Disarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Disarm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Disarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Disarm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Disarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Disarm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Disarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Disarm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Reset(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Reset(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Reset(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Reset(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Error_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Error_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Error_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Error_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Error_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Error_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Error_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Error_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Error_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Error_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Error_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Error_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Error_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Error_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Error_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Error_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_FIFO_Request_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_FIFO_Request_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_FIFO_Request_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_FIFO_Request_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_FIFO_Request_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_FIFO_Request_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_FIFO_Request_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_FIFO_Request_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_FIFO_Request_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_FIFO_Request_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_FIFO_Request_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_FIFO_Request_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_FIFO_Request_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_FIFO_Request_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_FIFO_Request_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_FIFO_Request_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Error_Interrupt_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Error_Interrupt_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Error_Interrupt_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Error_Interrupt_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_Error_Interrupt_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_Error_Interrupt_Confirm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Error_Interrupt_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_Error_Interrupt_Confirm(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Empty_FIFO_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Empty_FIFO_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Empty_FIFO_Interrupt_Enable_Set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Empty_FIFO_Interrupt_Enable_Set(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_Empty_FIFO_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_Empty_FIFO_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Empty_FIFO_Interrupt_Enable_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_Empty_FIFO_Interrupt_Enable_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDO_SW_Update(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDO_SW_Update(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_SW_Update(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDO_SW_Update(nMDBG::tStatus2* statusChain = NULL);

      inline tCDIO_Command& setCDI_SW_Sample(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getCDI_SW_Sample(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_SW_Sample(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCDI_SW_Sample(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDI_Mode
   //---------------------------------------------------------------------------
   class tCDI_Mode : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x228,
         kId     = 102
      };
      tCDI_Mode();


      typedef enum {
         kRegisterId                          = 0,
         kCDI_Sample_Source_SelectId          = 1,
         kCDI_Halt_On_ErrorId                 = 5,
         kCDI_PolarityId                      = 6,
         kCDI_FIFO_ModeId                     = 7,
         kCDI_Data_LaneId                     = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDI_Mode& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kCDI_Sample_Source_SelectGround            = 0,
         kCDI_Sample_Source_SelectPFI0              = 1,
         kCDI_Sample_Source_SelectPFI1              = 2,
         kCDI_Sample_Source_SelectPFI2              = 3,
         kCDI_Sample_Source_SelectPFI3              = 4,
         kCDI_Sample_Source_SelectPFI4              = 5,
         kCDI_Sample_Source_SelectPFI5              = 6,
         kCDI_Sample_Source_SelectPFI6              = 7,
         kCDI_Sample_Source_SelectPFI7              = 8,
         kCDI_Sample_Source_SelectPFI8              = 9,
         kCDI_Sample_Source_SelectPFI9              = 10,
         kCDI_Sample_Source_SelectRTSI0             = 11,
         kCDI_Sample_Source_SelectRTSI1             = 12,
         kCDI_Sample_Source_SelectRTSI2             = 13,
         kCDI_Sample_Source_SelectRTSI3             = 14,
         kCDI_Sample_Source_SelectRTSI4             = 15,
         kCDI_Sample_Source_SelectRTSI5             = 16,
         kCDI_Sample_Source_SelectRTSI6             = 17,
         kCDI_Sample_Source_SelectAI_Start          = 18,
         kCDI_Sample_Source_SelectAI_Convert        = 19,
         kCDI_Sample_Source_SelectPXI_Star_Trigger  = 20,
         kCDI_Sample_Source_SelectPFI10             = 21,
         kCDI_Sample_Source_SelectPFI11             = 22,
         kCDI_Sample_Source_SelectPFI12             = 23,
         kCDI_Sample_Source_SelectPFI13             = 24,
         kCDI_Sample_Source_SelectPFI14             = 25,
         kCDI_Sample_Source_SelectPFI15             = 26,
         kCDI_Sample_Source_SelectRTSI7             = 27,
         kCDI_Sample_Source_SelectG0_Out            = 28,
         kCDI_Sample_Source_SelectG1_Out            = 29,
         kCDI_Sample_Source_SelectAnalog_Trigger    = 30,
         kCDI_Sample_Source_SelectAO_Update         = 31,
         kCDI_Sample_Source_SelectFreq_Out          = 32,
         kCDI_Sample_Source_SelectDIO_Change_Detect_Irq       = 33,
      } tCDI_Sample_Source_Select;
      inline tCDI_Mode& setCDI_Sample_Source_Select(tCDI_Sample_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDI_Sample_Source_Select getCDI_Sample_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Sample_Source_Select(tCDI_Sample_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDI_Sample_Source_Select readCDI_Sample_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tCDI_Mode& setCDI_Halt_On_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDI_Halt_On_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Halt_On_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readCDI_Halt_On_Error(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDI_PolarityRising            = 0,
         kCDI_PolarityFalling           = 1,
      } tCDI_Polarity;
      inline tCDI_Mode& setCDI_Polarity(tCDI_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDI_Polarity getCDI_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Polarity(tCDI_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDI_Polarity readCDI_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDI_FIFO_ModeFIFO_Not_Empty    = 0,
         kCDI_FIFO_ModeFIFO_Half_Full    = 1,
      } tCDI_FIFO_Mode;
      inline tCDI_Mode& setCDI_FIFO_Mode(tCDI_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDI_FIFO_Mode getCDI_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_FIFO_Mode(tCDI_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDI_FIFO_Mode readCDI_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDI_Data_LaneCDIO_15_0         = 0,
         kCDI_Data_LaneCDIO_31_16        = 1,
         kCDI_Data_LaneCDIO_7_0          = 0,
         kCDI_Data_LaneCDIO_15_8         = 1,
         kCDI_Data_LaneCDIO_23_16        = 2,
         kCDI_Data_LaneCDIO_31_24        = 3,
      } tCDI_Data_Lane;
      inline tCDI_Mode& setCDI_Data_Lane(tCDI_Data_Lane fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDI_Data_Lane getCDI_Data_Lane(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDI_Data_Lane(tCDI_Data_Lane fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDI_Data_Lane readCDI_Data_Lane(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDO_Mode
   //---------------------------------------------------------------------------
   class tCDO_Mode : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x22c,
         kId     = 103
      };
      tCDO_Mode();


      typedef enum {
         kRegisterId                          = 0,
         kCDO_Update_Source_SelectId          = 1,
         kCDO_RetransmitId                    = 4,
         kCDO_Halt_On_ErrorId                 = 5,
         kCDO_PolarityId                      = 6,
         kCDO_FIFO_ModeId                     = 7,
         kCDO_Data_LaneId                     = 8
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDO_Mode& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kCDO_Update_Source_SelectGround            = 0,
         kCDO_Update_Source_SelectPFI0              = 1,
         kCDO_Update_Source_SelectPFI1              = 2,
         kCDO_Update_Source_SelectPFI2              = 3,
         kCDO_Update_Source_SelectPFI3              = 4,
         kCDO_Update_Source_SelectPFI4              = 5,
         kCDO_Update_Source_SelectPFI5              = 6,
         kCDO_Update_Source_SelectPFI6              = 7,
         kCDO_Update_Source_SelectPFI7              = 8,
         kCDO_Update_Source_SelectPFI8              = 9,
         kCDO_Update_Source_SelectPFI9              = 10,
         kCDO_Update_Source_SelectRTSI0             = 11,
         kCDO_Update_Source_SelectRTSI1             = 12,
         kCDO_Update_Source_SelectRTSI2             = 13,
         kCDO_Update_Source_SelectRTSI3             = 14,
         kCDO_Update_Source_SelectRTSI4             = 15,
         kCDO_Update_Source_SelectRTSI5             = 16,
         kCDO_Update_Source_SelectRTSI6             = 17,
         kCDO_Update_Source_SelectAI_Start          = 18,
         kCDO_Update_Source_SelectAI_Convert        = 19,
         kCDO_Update_Source_SelectPXI_Star_Trigger  = 20,
         kCDO_Update_Source_SelectPFI10             = 21,
         kCDO_Update_Source_SelectPFI11             = 22,
         kCDO_Update_Source_SelectPFI12             = 23,
         kCDO_Update_Source_SelectPFI13             = 24,
         kCDO_Update_Source_SelectPFI14             = 25,
         kCDO_Update_Source_SelectPFI15             = 26,
         kCDO_Update_Source_SelectRTSI7             = 27,
         kCDO_Update_Source_SelectG0_Out            = 28,
         kCDO_Update_Source_SelectG1_Out            = 29,
         kCDO_Update_Source_SelectAnalog_Trigger    = 30,
         kCDO_Update_Source_SelectAO_Update         = 31,
         kCDO_Update_Source_SelectFreq_Out          = 32,
         kCDO_Update_Source_SelectDIO_Change_Detect_Irq       = 33,
      } tCDO_Update_Source_Select;
      inline tCDO_Mode& setCDO_Update_Source_Select(tCDO_Update_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDO_Update_Source_Select getCDO_Update_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Update_Source_Select(tCDO_Update_Source_Select fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_Update_Source_Select readCDO_Update_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_Mode& setCDO_Retransmit(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_Retransmit(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Retransmit(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readCDO_Retransmit(nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_Mode& setCDO_Halt_On_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean getCDO_Halt_On_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Halt_On_Error(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readCDO_Halt_On_Error(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDO_PolarityRising            = 0,
         kCDO_PolarityFalling           = 1,
      } tCDO_Polarity;
      inline tCDO_Mode& setCDO_Polarity(tCDO_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDO_Polarity getCDO_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Polarity(tCDO_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_Polarity readCDO_Polarity(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDO_FIFO_ModeFIFO_Not_Full     = 0,
         kCDO_FIFO_ModeFIFO_Half_Full    = 1,
      } tCDO_FIFO_Mode;
      inline tCDO_Mode& setCDO_FIFO_Mode(tCDO_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDO_FIFO_Mode getCDO_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_FIFO_Mode(tCDO_FIFO_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_FIFO_Mode readCDO_FIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kCDO_Data_LaneCDIO_15_0         = 0,
         kCDO_Data_LaneCDIO_31_16        = 1,
         kCDO_Data_LaneCDIO_7_0          = 0,
         kCDO_Data_LaneCDIO_15_8         = 1,
         kCDO_Data_LaneCDIO_23_16        = 2,
         kCDO_Data_LaneCDIO_31_24        = 3,
      } tCDO_Data_Lane;
      inline tCDO_Mode& setCDO_Data_Lane(tCDO_Data_Lane fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tCDO_Data_Lane getCDO_Data_Lane(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeCDO_Data_Lane(tCDO_Data_Lane fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tCDO_Data_Lane readCDO_Data_Lane(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDI_Mask_Enable
   //---------------------------------------------------------------------------
   class tCDI_Mask_Enable : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x230,
         kId     = 104
      };
      tCDI_Mask_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDI_Mask_Enable& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDI_Mask_Enable& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // CDO_Mask_Enable
   //---------------------------------------------------------------------------
   class tCDO_Mask_Enable : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x234,
         kId     = 105
      };
      tCDO_Mask_Enable();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCDO_Mask_Enable& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCDO_Mask_Enable& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // SCXI_Legacy_Compatibility
   //---------------------------------------------------------------------------
   class tSCXI_Legacy_Compatibility : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0xbc,
         kId     = 106
      };
      tSCXI_Legacy_Compatibility();


      typedef enum {
         kRegisterId                          = 0,
         kSCXI_Force_AI_EXTMUX_CLK_WidthId    = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSCXI_Legacy_Compatibility& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      typedef enum {
         kSCXI_Force_AI_EXTMUX_CLK_Width250ns             = 0,
         kSCXI_Force_AI_EXTMUX_CLK_Width500ns             = 1,
      } tSCXI_Force_AI_EXTMUX_CLK_Width;
      inline tSCXI_Legacy_Compatibility& setSCXI_Force_AI_EXTMUX_CLK_Width(tSCXI_Force_AI_EXTMUX_CLK_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tSCXI_Force_AI_EXTMUX_CLK_Width getSCXI_Force_AI_EXTMUX_CLK_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCXI_Force_AI_EXTMUX_CLK_Width(tSCXI_Force_AI_EXTMUX_CLK_Width fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tSCXI_Force_AI_EXTMUX_CLK_Width readSCXI_Force_AI_EXTMUX_CLK_Width(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_0
   //---------------------------------------------------------------------------
   class tDIO_Reserved_0 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x240,
         kId     = 107
      };
      tDIO_Reserved_0();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_0& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_0& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_1
   //---------------------------------------------------------------------------
   class tDIO_Reserved_1 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x244,
         kId     = 108
      };
      tDIO_Reserved_1();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_1& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_1& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_2
   //---------------------------------------------------------------------------
   class tDIO_Reserved_2 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x240,
         kId     = 109
      };
      tDIO_Reserved_2();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_2& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_2& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_3
   //---------------------------------------------------------------------------
   class tDIO_Reserved_3 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x244,
         kId     = 110
      };
      tDIO_Reserved_3();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_3& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_3& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_4
   //---------------------------------------------------------------------------
   class tDIO_Reserved_4 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x248,
         kId     = 111
      };
      tDIO_Reserved_4();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_4& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_4& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_5
   //---------------------------------------------------------------------------
   class tDIO_Reserved_5 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x24c,
         kId     = 112
      };
      tDIO_Reserved_5();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_5& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_5& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_6
   //---------------------------------------------------------------------------
   class tDIO_Reserved_6 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x250,
         kId     = 113
      };
      tDIO_Reserved_6();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_6& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_6& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DIO_Reserved_7
   //---------------------------------------------------------------------------
   class tDIO_Reserved_7 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x254,
         kId     = 114
      };
      tDIO_Reserved_7();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIO_Reserved_7& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIO_Reserved_7& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // LB_Reserved_0
   //---------------------------------------------------------------------------
   class tLB_Reserved_0 : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x204,
         kId     = 115
      };
      tLB_Reserved_0();


      typedef enum {
         kRegisterId                          = 0,
         kValue0Id                            = 1,
         kValue1Id                            = 3
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tLB_Reserved_0& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tLB_Reserved_0& setValue0(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getValue0(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue0(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readValue0(nMDBG::tStatus2* statusChain = NULL);

      inline tLB_Reserved_0& setValue1(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getValue1(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue1(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readValue1(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // LB_Reserved_1
   //---------------------------------------------------------------------------
   class tLB_Reserved_1 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x200,
         kId     = 116
      };
      tLB_Reserved_1();


      typedef enum {
         kRegisterId                          = 0,
         kValueId                             = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tLB_Reserved_1& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tLB_Reserved_1& setValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getValue(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeValue(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readValue(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Waveform_Order
   //---------------------------------------------------------------------------
   class tAO_Waveform_Order : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tAO_Waveform_Order(u32 offset, u32 id);
      tAO_Waveform_Order();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Waveform_Order& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Waveform_Order& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // AO_Config_Bank
   //---------------------------------------------------------------------------
   class tAO_Config_Bank : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tAO_Config_Bank(u32 offset, u32 id);
      tAO_Config_Bank();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kAO_DAC_Offset_SelectId              = 1,
         kAO_DAC_Reference_SelectId           = 2,
         kAO_Update_ModeId                    = 3,
         kAO_DAC_PolarityId                   = 4
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAO_Config_Bank& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAO_Config_Bank& setAO_DAC_Offset_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_DAC_Offset_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DAC_Offset_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_DAC_Offset_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Config_Bank& setAO_DAC_Reference_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAO_DAC_Reference_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DAC_Reference_Select(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAO_DAC_Reference_Select(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_Update_ModeImmediate         = 0,
         kAO_Update_ModeTimed             = 1,
      } tAO_Update_Mode;
      inline tAO_Config_Bank& setAO_Update_Mode(tAO_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_Update_Mode getAO_Update_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_Update_Mode(tAO_Update_Mode fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_Update_Mode readAO_Update_Mode(nMDBG::tStatus2* statusChain = NULL);

      typedef enum {
         kAO_DAC_PolarityUnipolar          = 0,
         kAO_DAC_PolarityBipolar           = 1,
      } tAO_DAC_Polarity;
      inline tAO_Config_Bank& setAO_DAC_Polarity(tAO_DAC_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tAO_DAC_Polarity getAO_DAC_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAO_DAC_Polarity(tAO_DAC_Polarity fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tAO_DAC_Polarity readAO_DAC_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // DAC_Direct_Data
   //---------------------------------------------------------------------------
   class tDAC_Direct_Data : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tDAC_Direct_Data(u32 offset, u32 id);
      tDAC_Direct_Data();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDAC_Direct_Data& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDAC_Direct_Data& set(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Cal_PWM
   //---------------------------------------------------------------------------
   class tCal_PWM : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      enum {
         kOffset = 0x40,
         kId     = 153
      };
      tCal_PWM();


      typedef enum {
         kRegisterId                          = 0,
         kLow_TimeId                          = 1,
         kHigh_TimeId                         = 2
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tCal_PWM& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCal_PWM& setLow_Time(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getLow_Time(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeLow_Time(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readLow_Time(nMDBG::tStatus2* statusChain = NULL);

      inline tCal_PWM& setHigh_Time(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getHigh_Time(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeHigh_Time(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readHigh_Time(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Gen_PWM
   //---------------------------------------------------------------------------
   class tGen_PWM : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tGen_PWM(u32 offset, u32 id);
      tGen_PWM();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGen_PWM& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGen_PWM& set(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //---------------------------------------------------------------------------
   // Static_AI_Control
   //---------------------------------------------------------------------------
   class tStatic_AI_Control : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tMSeries tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tStatic_AI_Control(u32 offset, u32 id);
      tStatic_AI_Control();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                           = 1
      } tId;

      inline tMSeries* registerMap(void);

      inline void flushBus(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tStatic_AI_Control& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatic_AI_Control& set(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline tBoolean get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      inline void setRegisterMap(tMSeries* pMSeries);
      tMSeries* _MSeries;

      friend class tMSeries;

   };

   //----------------------------------------
   // Register Array Sizes
   //----------------------------------------
   enum {
      kAO_Waveform_OrderArraySize = 16,
      kAO_Config_BankArraySize = 4,
      kDAC_Direct_DataArraySize = 16,
      kGen_PWMArraySize = 7,
      kStatic_AI_ControlArraySize = 8
   };

   //---------------------------------------------------------------------------
   // AI_Command_1
   //---------------------------------------------------------------------------
   tAI_Command_1 AI_Command_1;

   //---------------------------------------------------------------------------
   // AI_Command_2
   //---------------------------------------------------------------------------
   tAI_Command_2 AI_Command_2;

   //---------------------------------------------------------------------------
   // AI_Mode_2
   //---------------------------------------------------------------------------
   tAI_Mode_2 AI_Mode_2;

   //---------------------------------------------------------------------------
   // AI_Mode_3
   //---------------------------------------------------------------------------
   tAI_Mode_3 AI_Mode_3;

   //---------------------------------------------------------------------------
   // AI_Personal
   //---------------------------------------------------------------------------
   tAI_Personal AI_Personal;

   //---------------------------------------------------------------------------
   // AI_Output_Control
   //---------------------------------------------------------------------------
   tAI_Output_Control AI_Output_Control;

   //---------------------------------------------------------------------------
   // AI_SC_Load_A
   //---------------------------------------------------------------------------
   tAI_SC_Load_A AI_SC_Load_A;

   //---------------------------------------------------------------------------
   // AI_SC_Load_B
   //---------------------------------------------------------------------------
   tAI_SC_Load_B AI_SC_Load_B;

   //---------------------------------------------------------------------------
   // AI_SC_Save
   //---------------------------------------------------------------------------
   tAI_SC_Save AI_SC_Save;

   //---------------------------------------------------------------------------
   // AI_SI_Load_A
   //---------------------------------------------------------------------------
   tAI_SI_Load_A AI_SI_Load_A;

   //---------------------------------------------------------------------------
   // AI_SI_Load_B
   //---------------------------------------------------------------------------
   tAI_SI_Load_B AI_SI_Load_B;

   //---------------------------------------------------------------------------
   // AI_SI_Save
   //---------------------------------------------------------------------------
   tAI_SI_Save AI_SI_Save;

   //---------------------------------------------------------------------------
   // AI_SI2_Load_A
   //---------------------------------------------------------------------------
   tAI_SI2_Load_A AI_SI2_Load_A;

   //---------------------------------------------------------------------------
   // AI_SI2_Load_B
   //---------------------------------------------------------------------------
   tAI_SI2_Load_B AI_SI2_Load_B;

   //---------------------------------------------------------------------------
   // AI_START_STOP_Select
   //---------------------------------------------------------------------------
   tAI_START_STOP_Select AI_START_STOP_Select;

   //---------------------------------------------------------------------------
   // AI_Status_1
   //---------------------------------------------------------------------------
   tAI_Status_1 AI_Status_1;

   //---------------------------------------------------------------------------
   // Analog_Trigger_Etc
   //---------------------------------------------------------------------------
   tAnalog_Trigger_Etc Analog_Trigger_Etc;

   //---------------------------------------------------------------------------
   // AI_Trigger_Select
   //---------------------------------------------------------------------------
   tAI_Trigger_Select AI_Trigger_Select;

   //---------------------------------------------------------------------------
   // AO_BC_Load_A
   //---------------------------------------------------------------------------
   tAO_BC_Load_A AO_BC_Load_A;

   //---------------------------------------------------------------------------
   // AO_BC_Load_B
   //---------------------------------------------------------------------------
   tAO_BC_Load_B AO_BC_Load_B;

   //---------------------------------------------------------------------------
   // AO_BC_Save
   //---------------------------------------------------------------------------
   tAO_BC_Save AO_BC_Save;

   //---------------------------------------------------------------------------
   // AO_Command_2
   //---------------------------------------------------------------------------
   tAO_Command_2 AO_Command_2;

   //---------------------------------------------------------------------------
   // AO_Command_1
   //---------------------------------------------------------------------------
   tAO_Command_1 AO_Command_1;

   //---------------------------------------------------------------------------
   // AO_Mode_1
   //---------------------------------------------------------------------------
   tAO_Mode_1 AO_Mode_1;

   //---------------------------------------------------------------------------
   // AO_Mode_2
   //---------------------------------------------------------------------------
   tAO_Mode_2 AO_Mode_2;

   //---------------------------------------------------------------------------
   // AO_Output_Control
   //---------------------------------------------------------------------------
   tAO_Output_Control AO_Output_Control;

   //---------------------------------------------------------------------------
   // AO_Mode_3
   //---------------------------------------------------------------------------
   tAO_Mode_3 AO_Mode_3;

   //---------------------------------------------------------------------------
   // AO_Personal
   //---------------------------------------------------------------------------
   tAO_Personal AO_Personal;

   //---------------------------------------------------------------------------
   // AO_START_Select
   //---------------------------------------------------------------------------
   tAO_START_Select AO_START_Select;

   //---------------------------------------------------------------------------
   // AO_Status_2
   //---------------------------------------------------------------------------
   tAO_Status_2 AO_Status_2;

   //---------------------------------------------------------------------------
   // AO_Status_1
   //---------------------------------------------------------------------------
   tAO_Status_1 AO_Status_1;

   //---------------------------------------------------------------------------
   // AO_Trigger_Select
   //---------------------------------------------------------------------------
   tAO_Trigger_Select AO_Trigger_Select;

   //---------------------------------------------------------------------------
   // AO_UC_Load_A
   //---------------------------------------------------------------------------
   tAO_UC_Load_A AO_UC_Load_A;

   //---------------------------------------------------------------------------
   // AO_UC_Load_B
   //---------------------------------------------------------------------------
   tAO_UC_Load_B AO_UC_Load_B;

   //---------------------------------------------------------------------------
   // AO_UC_Save
   //---------------------------------------------------------------------------
   tAO_UC_Save AO_UC_Save;

   //---------------------------------------------------------------------------
   // AO_UI_Load_A
   //---------------------------------------------------------------------------
   tAO_UI_Load_A AO_UI_Load_A;

   //---------------------------------------------------------------------------
   // AO_UI_Load_B
   //---------------------------------------------------------------------------
   tAO_UI_Load_B AO_UI_Load_B;

   //---------------------------------------------------------------------------
   // AO_UI_Save
   //---------------------------------------------------------------------------
   tAO_UI_Save AO_UI_Save;

   //---------------------------------------------------------------------------
   // Clock_and_FOUT
   //---------------------------------------------------------------------------
   tClock_and_FOUT Clock_and_FOUT;

   //---------------------------------------------------------------------------
   // Interrupt_A_Ack
   //---------------------------------------------------------------------------
   tInterrupt_A_Ack Interrupt_A_Ack;

   //---------------------------------------------------------------------------
   // Interrupt_A_Enable
   //---------------------------------------------------------------------------
   tInterrupt_A_Enable Interrupt_A_Enable;

   //---------------------------------------------------------------------------
   // Interrupt_B_Ack
   //---------------------------------------------------------------------------
   tInterrupt_B_Ack Interrupt_B_Ack;

   //---------------------------------------------------------------------------
   // Interrupt_Control
   //---------------------------------------------------------------------------
   tInterrupt_Control Interrupt_Control;

   //---------------------------------------------------------------------------
   // Interrupt_B_Enable
   //---------------------------------------------------------------------------
   tInterrupt_B_Enable Interrupt_B_Enable;

   //---------------------------------------------------------------------------
   // IO_Bidirection_Pin
   //---------------------------------------------------------------------------
   tIO_Bidirection_Pin IO_Bidirection_Pin;

   //---------------------------------------------------------------------------
   // Joint_Reset
   //---------------------------------------------------------------------------
   tJoint_Reset Joint_Reset;

   //---------------------------------------------------------------------------
   // Joint_Status_2
   //---------------------------------------------------------------------------
   tJoint_Status_2 Joint_Status_2;

   //---------------------------------------------------------------------------
   // Joint_Status_1
   //---------------------------------------------------------------------------
   tJoint_Status_1 Joint_Status_1;

   //---------------------------------------------------------------------------
   // RTSI_Shared_MUX
   //---------------------------------------------------------------------------
   tRTSI_Shared_MUX RTSI_Shared_MUX;

   //---------------------------------------------------------------------------
   // RTSI_Trig_A_Output
   //---------------------------------------------------------------------------
   tRTSI_Trig_A_Output RTSI_Trig_A_Output;

   //---------------------------------------------------------------------------
   // RTSI_Trig_Direction
   //---------------------------------------------------------------------------
   tRTSI_Trig_Direction RTSI_Trig_Direction;

   //---------------------------------------------------------------------------
   // RTSI_Trig_B_Output
   //---------------------------------------------------------------------------
   tRTSI_Trig_B_Output RTSI_Trig_B_Output;

   //---------------------------------------------------------------------------
   // G0_DMA_Config
   //---------------------------------------------------------------------------
   tG0_DMA_Config G0_DMA_Config;

   //---------------------------------------------------------------------------
   // G1_DMA_Config
   //---------------------------------------------------------------------------
   tG1_DMA_Config G1_DMA_Config;

   //---------------------------------------------------------------------------
   // G0_DMA_Status
   //---------------------------------------------------------------------------
   tG0_DMA_Status G0_DMA_Status;

   //---------------------------------------------------------------------------
   // G1_DMA_Status
   //---------------------------------------------------------------------------
   tG1_DMA_Status G1_DMA_Status;

   //---------------------------------------------------------------------------
   // CDIO_DMA_Select
   //---------------------------------------------------------------------------
   tCDIO_DMA_Select CDIO_DMA_Select;

   //---------------------------------------------------------------------------
   // SCXI_Control
   //---------------------------------------------------------------------------
   tSCXI_Control SCXI_Control;

   //---------------------------------------------------------------------------
   // AI_Mode_1
   //---------------------------------------------------------------------------
   tAI_Mode_1 AI_Mode_1;

   //---------------------------------------------------------------------------
   // AI_DIV_Load_A
   //---------------------------------------------------------------------------
   tAI_DIV_Load_A AI_DIV_Load_A;

   //---------------------------------------------------------------------------
   // SCXI_Serial_Data_In
   //---------------------------------------------------------------------------
   tSCXI_Serial_Data_In SCXI_Serial_Data_In;

   //---------------------------------------------------------------------------
   // SCXI_Serial_Data_Out
   //---------------------------------------------------------------------------
   tSCXI_Serial_Data_Out SCXI_Serial_Data_Out;

   //---------------------------------------------------------------------------
   // SCXI_Status
   //---------------------------------------------------------------------------
   tSCXI_Status SCXI_Status;

   //---------------------------------------------------------------------------
   // SCXI_Output_Enable
   //---------------------------------------------------------------------------
   tSCXI_Output_Enable SCXI_Output_Enable;

   //---------------------------------------------------------------------------
   // SCXI_DIO_Enable
   //---------------------------------------------------------------------------
   tSCXI_DIO_Enable SCXI_DIO_Enable;

   //---------------------------------------------------------------------------
   // Static_Digital_Output
   //---------------------------------------------------------------------------
   tStatic_Digital_Output Static_Digital_Output;

   //---------------------------------------------------------------------------
   // Static_Digital_Input
   //---------------------------------------------------------------------------
   tStatic_Digital_Input Static_Digital_Input;

   //---------------------------------------------------------------------------
   // DIO_Direction
   //---------------------------------------------------------------------------
   tDIO_Direction DIO_Direction;

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Enable
   //---------------------------------------------------------------------------
   tAO_Serial_Interrupt_Enable AO_Serial_Interrupt_Enable;

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Ack
   //---------------------------------------------------------------------------
   tAO_Serial_Interrupt_Ack AO_Serial_Interrupt_Ack;

   //---------------------------------------------------------------------------
   // AO_Serial_Interrupt_Status
   //---------------------------------------------------------------------------
   tAO_Serial_Interrupt_Status AO_Serial_Interrupt_Status;

   //---------------------------------------------------------------------------
   // Interrupt_C_Enable
   //---------------------------------------------------------------------------
   tInterrupt_C_Enable Interrupt_C_Enable;

   //---------------------------------------------------------------------------
   // Interrupt_C_Status
   //---------------------------------------------------------------------------
   tInterrupt_C_Status Interrupt_C_Status;

   //---------------------------------------------------------------------------
   // Analog_Trigger_Control
   //---------------------------------------------------------------------------
   tAnalog_Trigger_Control Analog_Trigger_Control;

   //---------------------------------------------------------------------------
   // AI_FIFO_Data
   //---------------------------------------------------------------------------
   tAI_FIFO_Data AI_FIFO_Data;

   //---------------------------------------------------------------------------
   // AI_FIFO_Clear
   //---------------------------------------------------------------------------
   tAI_FIFO_Clear AI_FIFO_Clear;

   //---------------------------------------------------------------------------
   // AI_AO_Select
   //---------------------------------------------------------------------------
   tAI_AO_Select AI_AO_Select;

   //---------------------------------------------------------------------------
   // AI_Config_FIFO_Data
   //---------------------------------------------------------------------------
   tAI_Config_FIFO_Data AI_Config_FIFO_Data;

   //---------------------------------------------------------------------------
   // Configuration_Memory_Clear
   //---------------------------------------------------------------------------
   tConfiguration_Memory_Clear Configuration_Memory_Clear;

   //---------------------------------------------------------------------------
   // AO_FIFO_Data
   //---------------------------------------------------------------------------
   tAO_FIFO_Data AO_FIFO_Data;

   //---------------------------------------------------------------------------
   // AO_FIFO_Clear
   //---------------------------------------------------------------------------
   tAO_FIFO_Clear AO_FIFO_Clear;

   //---------------------------------------------------------------------------
   // G0_G1_Select
   //---------------------------------------------------------------------------
   tG0_G1_Select G0_G1_Select;

   //---------------------------------------------------------------------------
   // Misc_Command
   //---------------------------------------------------------------------------
   tMisc_Command Misc_Command;

   //---------------------------------------------------------------------------
   // AO_Calibration
   //---------------------------------------------------------------------------
   tAO_Calibration AO_Calibration;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_1
   //---------------------------------------------------------------------------
   tPFI_Output_Select_1 PFI_Output_Select_1;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_2
   //---------------------------------------------------------------------------
   tPFI_Output_Select_2 PFI_Output_Select_2;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_3
   //---------------------------------------------------------------------------
   tPFI_Output_Select_3 PFI_Output_Select_3;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_4
   //---------------------------------------------------------------------------
   tPFI_Output_Select_4 PFI_Output_Select_4;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_5
   //---------------------------------------------------------------------------
   tPFI_Output_Select_5 PFI_Output_Select_5;

   //---------------------------------------------------------------------------
   // PFI_Output_Select_6
   //---------------------------------------------------------------------------
   tPFI_Output_Select_6 PFI_Output_Select_6;

   //---------------------------------------------------------------------------
   // PFI_DI
   //---------------------------------------------------------------------------
   tPFI_DI PFI_DI;

   //---------------------------------------------------------------------------
   // PFI_DO
   //---------------------------------------------------------------------------
   tPFI_DO PFI_DO;

   //---------------------------------------------------------------------------
   // PFI_Filter
   //---------------------------------------------------------------------------
   tPFI_Filter PFI_Filter;

   //---------------------------------------------------------------------------
   // RTSI_Filter
   //---------------------------------------------------------------------------
   tRTSI_Filter RTSI_Filter;

   //---------------------------------------------------------------------------
   // Clock_And_Fout2
   //---------------------------------------------------------------------------
   tClock_And_Fout2 Clock_And_Fout2;

   //---------------------------------------------------------------------------
   // PLL_Control
   //---------------------------------------------------------------------------
   tPLL_Control PLL_Control;

   //---------------------------------------------------------------------------
   // PLL_Status
   //---------------------------------------------------------------------------
   tPLL_Status PLL_Status;

   //---------------------------------------------------------------------------
   // AI_Config_FIFO_Bypass
   //---------------------------------------------------------------------------
   tAI_Config_FIFO_Bypass AI_Config_FIFO_Bypass;

   //---------------------------------------------------------------------------
   // CDI_FIFO_Data
   //---------------------------------------------------------------------------
   tCDI_FIFO_Data CDI_FIFO_Data;

   //---------------------------------------------------------------------------
   // CDO_FIFO_Data
   //---------------------------------------------------------------------------
   tCDO_FIFO_Data CDO_FIFO_Data;

   //---------------------------------------------------------------------------
   // CDIO_Status
   //---------------------------------------------------------------------------
   tCDIO_Status CDIO_Status;

   //---------------------------------------------------------------------------
   // CDIO_Command
   //---------------------------------------------------------------------------
   tCDIO_Command CDIO_Command;

   //---------------------------------------------------------------------------
   // CDI_Mode
   //---------------------------------------------------------------------------
   tCDI_Mode CDI_Mode;

   //---------------------------------------------------------------------------
   // CDO_Mode
   //---------------------------------------------------------------------------
   tCDO_Mode CDO_Mode;

   //---------------------------------------------------------------------------
   // CDI_Mask_Enable
   //---------------------------------------------------------------------------
   tCDI_Mask_Enable CDI_Mask_Enable;

   //---------------------------------------------------------------------------
   // CDO_Mask_Enable
   //---------------------------------------------------------------------------
   tCDO_Mask_Enable CDO_Mask_Enable;

   //---------------------------------------------------------------------------
   // SCXI_Legacy_Compatibility
   //---------------------------------------------------------------------------
   tSCXI_Legacy_Compatibility SCXI_Legacy_Compatibility;

   //---------------------------------------------------------------------------
   // DIO_Reserved_0
   //---------------------------------------------------------------------------
   tDIO_Reserved_0 DIO_Reserved_0;

   //---------------------------------------------------------------------------
   // DIO_Reserved_1
   //---------------------------------------------------------------------------
   tDIO_Reserved_1 DIO_Reserved_1;

   //---------------------------------------------------------------------------
   // DIO_Reserved_2
   //---------------------------------------------------------------------------
   tDIO_Reserved_2 DIO_Reserved_2;

   //---------------------------------------------------------------------------
   // DIO_Reserved_3
   //---------------------------------------------------------------------------
   tDIO_Reserved_3 DIO_Reserved_3;

   //---------------------------------------------------------------------------
   // DIO_Reserved_4
   //---------------------------------------------------------------------------
   tDIO_Reserved_4 DIO_Reserved_4;

   //---------------------------------------------------------------------------
   // DIO_Reserved_5
   //---------------------------------------------------------------------------
   tDIO_Reserved_5 DIO_Reserved_5;

   //---------------------------------------------------------------------------
   // DIO_Reserved_6
   //---------------------------------------------------------------------------
   tDIO_Reserved_6 DIO_Reserved_6;

   //---------------------------------------------------------------------------
   // DIO_Reserved_7
   //---------------------------------------------------------------------------
   tDIO_Reserved_7 DIO_Reserved_7;

   //---------------------------------------------------------------------------
   // LB_Reserved_0
   //---------------------------------------------------------------------------
   tLB_Reserved_0 LB_Reserved_0;

   //---------------------------------------------------------------------------
   // LB_Reserved_1
   //---------------------------------------------------------------------------
   tLB_Reserved_1 LB_Reserved_1;

   //---------------------------------------------------------------------------
   // AO_Waveform_Order
   //---------------------------------------------------------------------------
   tAO_Waveform_Order AO_Waveform_Order[kAO_Waveform_OrderArraySize];

   //---------------------------------------------------------------------------
   // AO_Config_Bank
   //---------------------------------------------------------------------------
   tAO_Config_Bank AO_Config_Bank[kAO_Config_BankArraySize];

   //---------------------------------------------------------------------------
   // DAC_Direct_Data
   //---------------------------------------------------------------------------
   tDAC_Direct_Data DAC_Direct_Data[kDAC_Direct_DataArraySize];

   //---------------------------------------------------------------------------
   // Cal_PWM
   //---------------------------------------------------------------------------
   tCal_PWM Cal_PWM;

   //---------------------------------------------------------------------------
   // Gen_PWM
   //---------------------------------------------------------------------------
   tGen_PWM Gen_PWM[kGen_PWMArraySize];

   //---------------------------------------------------------------------------
   // Static_AI_Control
   //---------------------------------------------------------------------------
   tStatic_AI_Control Static_AI_Control[kStatic_AI_ControlArraySize];

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kAI_Command_1Id                      = 0,
      kAI_CONVERT_PulseId                  = (tAI_Command_1::kAI_CONVERT_PulseId << 27) | kAI_Command_1Id,
      kAI_LOCALMUX_CLK_PulseId             = (tAI_Command_1::kAI_LOCALMUX_CLK_PulseId << 27) | kAI_Command_1Id,
      kAI_EXTMUX_CLK_PulseId               = (tAI_Command_1::kAI_EXTMUX_CLK_PulseId << 27) | kAI_Command_1Id,
      kAI_SCAN_IN_PROG_PulseId             = (tAI_Command_1::kAI_SCAN_IN_PROG_PulseId << 27) | kAI_Command_1Id,
      kAI_SC_LoadId                        = (tAI_Command_1::kAI_SC_LoadId << 27) | kAI_Command_1Id,
      kAI_SC_ArmId                         = (tAI_Command_1::kAI_SC_ArmId << 27) | kAI_Command_1Id,
      kAI_DIV_LoadId                       = (tAI_Command_1::kAI_DIV_LoadId << 27) | kAI_Command_1Id,
      kAI_DIV_ArmId                        = (tAI_Command_1::kAI_DIV_ArmId << 27) | kAI_Command_1Id,
      kAI_SI_LoadId                        = (tAI_Command_1::kAI_SI_LoadId << 27) | kAI_Command_1Id,
      kAI_SI_ArmId                         = (tAI_Command_1::kAI_SI_ArmId << 27) | kAI_Command_1Id,
      kAI_SI2_LoadId                       = (tAI_Command_1::kAI_SI2_LoadId << 27) | kAI_Command_1Id,
      kAI_SI2_ArmId                        = (tAI_Command_1::kAI_SI2_ArmId << 27) | kAI_Command_1Id,
      kAI_DisarmId                         = (tAI_Command_1::kAI_DisarmId << 27) | kAI_Command_1Id,
      kAI_Analog_Trigger_ResetId           = (tAI_Command_1::kAI_Analog_Trigger_ResetId << 27) | kAI_Command_1Id,

      kAI_Command_2Id                      = 1,
      kAI_START1_PulseId                   = (tAI_Command_2::kAI_START1_PulseId << 27) | kAI_Command_2Id,
      kAI_START2_PulseId                   = (tAI_Command_2::kAI_START2_PulseId << 27) | kAI_Command_2Id,
      kAI_START_PulseId                    = (tAI_Command_2::kAI_START_PulseId << 27) | kAI_Command_2Id,
      kAI_STOP_PulseId                     = (tAI_Command_2::kAI_STOP_PulseId << 27) | kAI_Command_2Id,
      kAI_SC_Switch_Load_On_TCId           = (tAI_Command_2::kAI_SC_Switch_Load_On_TCId << 27) | kAI_Command_2Id,
      kAI_SI_Switch_Load_On_TCId           = (tAI_Command_2::kAI_SI_Switch_Load_On_TCId << 27) | kAI_Command_2Id,
      kAI_SI_Switch_Load_On_STOPId         = (tAI_Command_2::kAI_SI_Switch_Load_On_STOPId << 27) | kAI_Command_2Id,
      kAI_SI_Switch_Load_On_SC_TCId        = (tAI_Command_2::kAI_SI_Switch_Load_On_SC_TCId << 27) | kAI_Command_2Id,
      kAI_SC_Save_TraceId                  = (tAI_Command_2::kAI_SC_Save_TraceId << 27) | kAI_Command_2Id,
      kAI_START1_DisableId                 = (tAI_Command_2::kAI_START1_DisableId << 27) | kAI_Command_2Id,
      kAI_End_On_End_Of_ScanId             = (tAI_Command_2::kAI_End_On_End_Of_ScanId << 27) | kAI_Command_2Id,
      kAI_End_On_SC_TCId                   = (tAI_Command_2::kAI_End_On_SC_TCId << 27) | kAI_Command_2Id,

      kAI_Mode_2Id                         = 2,
      kAI_SC_Write_SwitchId                = (tAI_Mode_2::kAI_SC_Write_SwitchId << 27) | kAI_Mode_2Id,
      kAI_SC_Reload_ModeId                 = (tAI_Mode_2::kAI_SC_Reload_ModeId << 27) | kAI_Mode_2Id,
      kAI_SC_Initial_Load_SourceId         = (tAI_Mode_2::kAI_SC_Initial_Load_SourceId << 27) | kAI_Mode_2Id,
      kAI_SI_Write_SwitchId                = (tAI_Mode_2::kAI_SI_Write_SwitchId << 27) | kAI_Mode_2Id,
      kAI_SI_Reload_ModeId                 = (tAI_Mode_2::kAI_SI_Reload_ModeId << 27) | kAI_Mode_2Id,
      kAI_SI_Initial_Load_SourceId         = (tAI_Mode_2::kAI_SI_Initial_Load_SourceId << 27) | kAI_Mode_2Id,
      kAI_SI2_Reload_ModeId                = (tAI_Mode_2::kAI_SI2_Reload_ModeId << 27) | kAI_Mode_2Id,
      kAI_SI2_Initial_Load_SourceId        = (tAI_Mode_2::kAI_SI2_Initial_Load_SourceId << 27) | kAI_Mode_2Id,
      kAI_External_MUX_PresentId           = (tAI_Mode_2::kAI_External_MUX_PresentId << 27) | kAI_Mode_2Id,
      kAI_Pre_TriggerId                    = (tAI_Mode_2::kAI_Pre_TriggerId << 27) | kAI_Mode_2Id,
      kAI_Start_Stop_Gate_EnableId         = (tAI_Mode_2::kAI_Start_Stop_Gate_EnableId << 27) | kAI_Mode_2Id,
      kAI_SC_Gate_EnableId                 = (tAI_Mode_2::kAI_SC_Gate_EnableId << 27) | kAI_Mode_2Id,

      kAI_Mode_3Id                         = 3,
      kAI_External_Gate_SelectId           = (tAI_Mode_3::kAI_External_Gate_SelectId << 27) | kAI_Mode_3Id,
      kAI_External_Gate_PolarityId         = (tAI_Mode_3::kAI_External_Gate_PolarityId << 27) | kAI_Mode_3Id,
      kAI_FIFO_ModeId                      = (tAI_Mode_3::kAI_FIFO_ModeId << 27) | kAI_Mode_3Id,
      kAI_External_Gate_ModeId             = (tAI_Mode_3::kAI_External_Gate_ModeId << 27) | kAI_Mode_3Id,
      kAI_Delayed_START1Id                 = (tAI_Mode_3::kAI_Delayed_START1Id << 27) | kAI_Mode_3Id,
      kAI_Delayed_START2Id                 = (tAI_Mode_3::kAI_Delayed_START2Id << 27) | kAI_Mode_3Id,
      kAI_SI2_Source_SelectId              = (tAI_Mode_3::kAI_SI2_Source_SelectId << 27) | kAI_Mode_3Id,
      kAI_Software_GateId                  = (tAI_Mode_3::kAI_Software_GateId << 27) | kAI_Mode_3Id,
      kAI_Delay_STARTId                    = (tAI_Mode_3::kAI_Delay_STARTId << 27) | kAI_Mode_3Id,
      kAI_Trigger_LengthId                 = (tAI_Mode_3::kAI_Trigger_LengthId << 27) | kAI_Mode_3Id,

      kAI_PersonalId                       = 4,
      kAI_EXTMUX_CLK_Pulse_WidthId         = (tAI_Personal::kAI_EXTMUX_CLK_Pulse_WidthId << 27) | kAI_PersonalId,
      kAI_CONVERT_Pulse_WidthId            = (tAI_Personal::kAI_CONVERT_Pulse_WidthId << 27) | kAI_PersonalId,

      kAI_Output_ControlId                 = 5,
      kAI_CONVERT_Output_SelectId          = (tAI_Output_Control::kAI_CONVERT_Output_SelectId << 27) | kAI_Output_ControlId,
      kAI_EXTMUX_CLK_Output_SelectId       = (tAI_Output_Control::kAI_EXTMUX_CLK_Output_SelectId << 27) | kAI_Output_ControlId,
      kAI_SCAN_IN_PROG_Output_SelectId     = (tAI_Output_Control::kAI_SCAN_IN_PROG_Output_SelectId << 27) | kAI_Output_ControlId,
      kAI_START_Output_SelectId            = (tAI_Output_Control::kAI_START_Output_SelectId << 27) | kAI_Output_ControlId,

      kAI_SC_Load_AId                      = 6,
      kAI_SC_Load_ADefaultId                                  = (tAI_SC_Load_A::kDefaultId << 27) | kAI_SC_Load_AId,

      kAI_SC_Load_BId                      = 7,
      kAI_SC_Load_BDefaultId                                  = (tAI_SC_Load_B::kDefaultId << 27) | kAI_SC_Load_BId,

      kAI_SC_SaveId                        = 8,
      kAI_SC_Save_ValueDefaultId                                  = (tAI_SC_Save::kDefaultId << 27) | kAI_SC_SaveId,

      kAI_SI_Load_AId                      = 9,
      kAI_SI_Load_ADefaultId                                  = (tAI_SI_Load_A::kDefaultId << 27) | kAI_SI_Load_AId,

      kAI_SI_Load_BId                      = 10,
      kAI_SI_Load_BDefaultId                                  = (tAI_SI_Load_B::kDefaultId << 27) | kAI_SI_Load_BId,

      kAI_SI_SaveId                        = 11,
      kAI_SI_Save_ValueDefaultId                                  = (tAI_SI_Save::kDefaultId << 27) | kAI_SI_SaveId,

      kAI_SI2_Load_AId                     = 12,
      kAI_SI2_Load_ADefaultId                                  = (tAI_SI2_Load_A::kDefaultId << 27) | kAI_SI2_Load_AId,

      kAI_SI2_Load_BId                     = 13,
      kAI_SI2_Load_BDefaultId                                  = (tAI_SI2_Load_B::kDefaultId << 27) | kAI_SI2_Load_BId,

      kAI_START_STOP_SelectId              = 14,
      kAI_START_SelectId                   = (tAI_START_STOP_Select::kAI_START_SelectId << 27) | kAI_START_STOP_SelectId,
      kAI_START_EdgeId                     = (tAI_START_STOP_Select::kAI_START_EdgeId << 27) | kAI_START_STOP_SelectId,
      kAI_START_SyncId                     = (tAI_START_STOP_Select::kAI_START_SyncId << 27) | kAI_START_STOP_SelectId,
      kAI_STOP_SelectId                    = (tAI_START_STOP_Select::kAI_STOP_SelectId << 27) | kAI_START_STOP_SelectId,
      kAI_STOP_EdgeId                      = (tAI_START_STOP_Select::kAI_STOP_EdgeId << 27) | kAI_START_STOP_SelectId,
      kAI_STOP_SyncId                      = (tAI_START_STOP_Select::kAI_STOP_SyncId << 27) | kAI_START_STOP_SelectId,
      kAI_STOP_PolarityId                  = (tAI_START_STOP_Select::kAI_STOP_PolarityId << 27) | kAI_START_STOP_SelectId,
      kAI_START_PolarityId                 = (tAI_START_STOP_Select::kAI_START_PolarityId << 27) | kAI_START_STOP_SelectId,

      kAI_Status_1Id                       = 15,
      kPass_Thru_0_Interrupt_StId          = (tAI_Status_1::kPass_Thru_0_Interrupt_StId << 27) | kAI_Status_1Id,
      kAI_FIFO_Request_StId                = (tAI_Status_1::kAI_FIFO_Request_StId << 27) | kAI_Status_1Id,
      kG0_Gate_Interrupt_StId              = (tAI_Status_1::kG0_Gate_Interrupt_StId << 27) | kAI_Status_1Id,
      kG0_TC_StId                          = (tAI_Status_1::kG0_TC_StId << 27) | kAI_Status_1Id,
      kAI_STOP_StId                        = (tAI_Status_1::kAI_STOP_StId << 27) | kAI_Status_1Id,
      kAI_START_StId                       = (tAI_Status_1::kAI_START_StId << 27) | kAI_Status_1Id,
      kAI_SC_TC_StId                       = (tAI_Status_1::kAI_SC_TC_StId << 27) | kAI_Status_1Id,
      kAI_START1_StId                      = (tAI_Status_1::kAI_START1_StId << 27) | kAI_Status_1Id,
      kAI_START2_StId                      = (tAI_Status_1::kAI_START2_StId << 27) | kAI_Status_1Id,
      kAI_SC_TC_Error_StId                 = (tAI_Status_1::kAI_SC_TC_Error_StId << 27) | kAI_Status_1Id,
      kAI_Overflow_StId                    = (tAI_Status_1::kAI_Overflow_StId << 27) | kAI_Status_1Id,
      kAI_Overrun_StId                     = (tAI_Status_1::kAI_Overrun_StId << 27) | kAI_Status_1Id,
      kAI_FIFO_Empty_StId                  = (tAI_Status_1::kAI_FIFO_Empty_StId << 27) | kAI_Status_1Id,
      kAI_FIFO_Half_Full_StId              = (tAI_Status_1::kAI_FIFO_Half_Full_StId << 27) | kAI_Status_1Id,
      kAI_FIFO_Full_StId                   = (tAI_Status_1::kAI_FIFO_Full_StId << 27) | kAI_Status_1Id,
      kInterrupt_Group_A_StatusId          = (tAI_Status_1::kInterrupt_Group_A_StatusId << 27) | kAI_Status_1Id,

      kAnalog_Trigger_EtcId                = 16,
      kAnalog_Trigger_ModeId               = (tAnalog_Trigger_Etc::kAnalog_Trigger_ModeId << 27) | kAnalog_Trigger_EtcId,
      kAnalog_Trigger_EnableId             = (tAnalog_Trigger_Etc::kAnalog_Trigger_EnableId << 27) | kAnalog_Trigger_EtcId,
      kAnalog_Trigger_ResetId              = (tAnalog_Trigger_Etc::kAnalog_Trigger_ResetId << 27) | kAnalog_Trigger_EtcId,
      kMisc_Counter_TCs_Output_EnableId    = (tAnalog_Trigger_Etc::kMisc_Counter_TCs_Output_EnableId << 27) | kAnalog_Trigger_EtcId,
      kGPFO_1_Output_SelectId              = (tAnalog_Trigger_Etc::kGPFO_1_Output_SelectId << 27) | kAnalog_Trigger_EtcId,
      kGPFO_0_Output_SelectId              = (tAnalog_Trigger_Etc::kGPFO_0_Output_SelectId << 27) | kAnalog_Trigger_EtcId,
      kGPFO_0_Output_EnableId              = (tAnalog_Trigger_Etc::kGPFO_0_Output_EnableId << 27) | kAnalog_Trigger_EtcId,
      kGPFO_1_Output_EnableId              = (tAnalog_Trigger_Etc::kGPFO_1_Output_EnableId << 27) | kAnalog_Trigger_EtcId,

      kAI_Trigger_SelectId                 = 17,
      kAI_START1_SelectId                  = (tAI_Trigger_Select::kAI_START1_SelectId << 27) | kAI_Trigger_SelectId,
      kAI_START1_EdgeId                    = (tAI_Trigger_Select::kAI_START1_EdgeId << 27) | kAI_Trigger_SelectId,
      kAI_START1_SyncId                    = (tAI_Trigger_Select::kAI_START1_SyncId << 27) | kAI_Trigger_SelectId,
      kAI_START2_SelectId                  = (tAI_Trigger_Select::kAI_START2_SelectId << 27) | kAI_Trigger_SelectId,
      kAI_START2_EdgeId                    = (tAI_Trigger_Select::kAI_START2_EdgeId << 27) | kAI_Trigger_SelectId,
      kAI_START2_SyncId                    = (tAI_Trigger_Select::kAI_START2_SyncId << 27) | kAI_Trigger_SelectId,
      kAI_START2_PolarityId                = (tAI_Trigger_Select::kAI_START2_PolarityId << 27) | kAI_Trigger_SelectId,
      kAI_START1_PolarityId                = (tAI_Trigger_Select::kAI_START1_PolarityId << 27) | kAI_Trigger_SelectId,

      kAO_BC_Load_AId                      = 18,
      kAO_BC_Load_ADefaultId                                  = (tAO_BC_Load_A::kDefaultId << 27) | kAO_BC_Load_AId,

      kAO_BC_Load_BId                      = 19,
      kAO_BC_Load_BDefaultId                                  = (tAO_BC_Load_B::kDefaultId << 27) | kAO_BC_Load_BId,

      kAO_BC_SaveId                        = 20,
      kAO_BC_SaveDefaultId                                  = (tAO_BC_Save::kDefaultId << 27) | kAO_BC_SaveId,

      kAO_Command_2Id                      = 21,
      kAO_START1_PulseId                   = (tAO_Command_2::kAO_START1_PulseId << 27) | kAO_Command_2Id,
      kAO_Mute_AId                         = (tAO_Command_2::kAO_Mute_AId << 27) | kAO_Command_2Id,
      kAO_Mute_BId                         = (tAO_Command_2::kAO_Mute_BId << 27) | kAO_Command_2Id,
      kAO_BC_Switch_Load_On_TCId           = (tAO_Command_2::kAO_BC_Switch_Load_On_TCId << 27) | kAO_Command_2Id,
      kAO_UC_Switch_Load_On_TCId           = (tAO_Command_2::kAO_UC_Switch_Load_On_TCId << 27) | kAO_Command_2Id,
      kAO_UC_Switch_Load_On_BC_TCId        = (tAO_Command_2::kAO_UC_Switch_Load_On_BC_TCId << 27) | kAO_Command_2Id,
      kAO_UI_Switch_Load_On_TCId           = (tAO_Command_2::kAO_UI_Switch_Load_On_TCId << 27) | kAO_Command_2Id,
      kAO_UI_Switch_Load_On_StopId         = (tAO_Command_2::kAO_UI_Switch_Load_On_StopId << 27) | kAO_Command_2Id,
      kAO_UI_Switch_Load_On_BC_TCId        = (tAO_Command_2::kAO_UI_Switch_Load_On_BC_TCId << 27) | kAO_Command_2Id,
      kAO_BC_Save_TraceId                  = (tAO_Command_2::kAO_BC_Save_TraceId << 27) | kAO_Command_2Id,
      kAO_BC_Gate_EnableId                 = (tAO_Command_2::kAO_BC_Gate_EnableId << 27) | kAO_Command_2Id,
      kAO_UC_Save_TraceId                  = (tAO_Command_2::kAO_UC_Save_TraceId << 27) | kAO_Command_2Id,
      kAO_Start_Stop_Gate_EnableId         = (tAO_Command_2::kAO_Start_Stop_Gate_EnableId << 27) | kAO_Command_2Id,
      kAO_End_On_UC_TCId                   = (tAO_Command_2::kAO_End_On_UC_TCId << 27) | kAO_Command_2Id,
      kAO_End_On_BC_TCId                   = (tAO_Command_2::kAO_End_On_BC_TCId << 27) | kAO_Command_2Id,

      kAO_Command_1Id                      = 22,
      kAO_UPDATE_PulseId                   = (tAO_Command_1::kAO_UPDATE_PulseId << 27) | kAO_Command_1Id,
      kAO_DAC0_Update_ModeId               = (tAO_Command_1::kAO_DAC0_Update_ModeId << 27) | kAO_Command_1Id,
      kAO_DAC1_Update_ModeId               = (tAO_Command_1::kAO_DAC1_Update_ModeId << 27) | kAO_Command_1Id,
      kAO_BC_LoadId                        = (tAO_Command_1::kAO_BC_LoadId << 27) | kAO_Command_1Id,
      kAO_BC_ArmId                         = (tAO_Command_1::kAO_BC_ArmId << 27) | kAO_Command_1Id,
      kAO_UC_LoadId                        = (tAO_Command_1::kAO_UC_LoadId << 27) | kAO_Command_1Id,
      kAO_UC_ArmId                         = (tAO_Command_1::kAO_UC_ArmId << 27) | kAO_Command_1Id,
      kAO_UI_LoadId                        = (tAO_Command_1::kAO_UI_LoadId << 27) | kAO_Command_1Id,
      kAO_UI_ArmId                         = (tAO_Command_1::kAO_UI_ArmId << 27) | kAO_Command_1Id,
      kAO_DisarmId                         = (tAO_Command_1::kAO_DisarmId << 27) | kAO_Command_1Id,
      kAO_START_PulseId                    = (tAO_Command_1::kAO_START_PulseId << 27) | kAO_Command_1Id,
      kAO_Analog_Trigger_ResetId           = (tAO_Command_1::kAO_Analog_Trigger_ResetId << 27) | kAO_Command_1Id,

      kAO_Mode_1Id                         = 23,
      kAO_Trigger_OnceId                   = (tAO_Mode_1::kAO_Trigger_OnceId << 27) | kAO_Mode_1Id,
      kAO_ContinuousId                     = (tAO_Mode_1::kAO_ContinuousId << 27) | kAO_Mode_1Id,
      kAO_UC_Switch_Load_Every_TCId        = (tAO_Mode_1::kAO_UC_Switch_Load_Every_TCId << 27) | kAO_Mode_1Id,
      kAO_UI_Source_PolarityId             = (tAO_Mode_1::kAO_UI_Source_PolarityId << 27) | kAO_Mode_1Id,
      kAO_UPDATE_Source_PolarityId         = (tAO_Mode_1::kAO_UPDATE_Source_PolarityId << 27) | kAO_Mode_1Id,
      kAO_Multiple_ChannelsId              = (tAO_Mode_1::kAO_Multiple_ChannelsId << 27) | kAO_Mode_1Id,
      kAO_UI_Source_SelectId               = (tAO_Mode_1::kAO_UI_Source_SelectId << 27) | kAO_Mode_1Id,
      kAO_UPDATE_Source_SelectId           = (tAO_Mode_1::kAO_UPDATE_Source_SelectId << 27) | kAO_Mode_1Id,

      kAO_Mode_2Id                         = 24,
      kAO_BC_Write_SwitchId                = (tAO_Mode_2::kAO_BC_Write_SwitchId << 27) | kAO_Mode_2Id,
      kAO_BC_Reload_ModeId                 = (tAO_Mode_2::kAO_BC_Reload_ModeId << 27) | kAO_Mode_2Id,
      kAO_BC_Initial_Load_SourceId         = (tAO_Mode_2::kAO_BC_Initial_Load_SourceId << 27) | kAO_Mode_2Id,
      kAO_UI_Write_SwitchId                = (tAO_Mode_2::kAO_UI_Write_SwitchId << 27) | kAO_Mode_2Id,
      kAO_UI_Reload_ModeId                 = (tAO_Mode_2::kAO_UI_Reload_ModeId << 27) | kAO_Mode_2Id,
      kAO_UI_Initial_Load_SourceId         = (tAO_Mode_2::kAO_UI_Initial_Load_SourceId << 27) | kAO_Mode_2Id,
      kAO_UC_Write_SwitchId                = (tAO_Mode_2::kAO_UC_Write_SwitchId << 27) | kAO_Mode_2Id,
      kAO_UC_Initial_Load_SourceId         = (tAO_Mode_2::kAO_UC_Initial_Load_SourceId << 27) | kAO_Mode_2Id,
      kAO_START1_DisableId                 = (tAO_Mode_2::kAO_START1_DisableId << 27) | kAO_Mode_2Id,
      kAO_FIFO_Retransmit_EnableId         = (tAO_Mode_2::kAO_FIFO_Retransmit_EnableId << 27) | kAO_Mode_2Id,
      kAO_FIFO_ModeId                      = (tAO_Mode_2::kAO_FIFO_ModeId << 27) | kAO_Mode_2Id,

      kAO_Output_ControlId                 = 25,
      kAO_UPDATE_Output_SelectId           = (tAO_Output_Control::kAO_UPDATE_Output_SelectId << 27) | kAO_Output_ControlId,
      kAO_External_Gate_PolarityId         = (tAO_Output_Control::kAO_External_Gate_PolarityId << 27) | kAO_Output_ControlId,
      kAO_Number_Of_ChannelsId             = (tAO_Output_Control::kAO_Number_Of_ChannelsId << 27) | kAO_Output_ControlId,
      kAO_External_Gate_SelectId           = (tAO_Output_Control::kAO_External_Gate_SelectId << 27) | kAO_Output_ControlId,
      kAO_External_Gate_EnableId           = (tAO_Output_Control::kAO_External_Gate_EnableId << 27) | kAO_Output_ControlId,

      kAO_Mode_3Id                         = 26,
      kAO_Last_Gate_DisableId              = (tAO_Mode_3::kAO_Last_Gate_DisableId << 27) | kAO_Mode_3Id,
      kAO_Software_GateId                  = (tAO_Mode_3::kAO_Software_GateId << 27) | kAO_Mode_3Id,
      kAO_Not_An_UPDATEId                  = (tAO_Mode_3::kAO_Not_An_UPDATEId << 27) | kAO_Mode_3Id,
      kAO_Stop_On_BC_TC_ErrorId            = (tAO_Mode_3::kAO_Stop_On_BC_TC_ErrorId << 27) | kAO_Mode_3Id,
      kAO_Stop_On_BC_TC_Trigger_ErrorId    = (tAO_Mode_3::kAO_Stop_On_BC_TC_Trigger_ErrorId << 27) | kAO_Mode_3Id,
      kAO_Stop_On_Overrun_ErrorId          = (tAO_Mode_3::kAO_Stop_On_Overrun_ErrorId << 27) | kAO_Mode_3Id,
      kAO_Trigger_LengthId                 = (tAO_Mode_3::kAO_Trigger_LengthId << 27) | kAO_Mode_3Id,
      kAO_UC_Switch_Load_Every_BC_TCId     = (tAO_Mode_3::kAO_UC_Switch_Load_Every_BC_TCId << 27) | kAO_Mode_3Id,

      kAO_PersonalId                       = 27,
      kAO_Interval_Buffer_ModeId           = (tAO_Personal::kAO_Interval_Buffer_ModeId << 27) | kAO_PersonalId,
      kAO_BC_Source_SelectId               = (tAO_Personal::kAO_BC_Source_SelectId << 27) | kAO_PersonalId,
      kAO_UPDATE_Pulse_WidthId             = (tAO_Personal::kAO_UPDATE_Pulse_WidthId << 27) | kAO_PersonalId,
      kAO_UPDATE_Pulse_TimebaseId          = (tAO_Personal::kAO_UPDATE_Pulse_TimebaseId << 27) | kAO_PersonalId,
      kAO_UPDATE_Original_PulseId          = (tAO_Personal::kAO_UPDATE_Original_PulseId << 27) | kAO_PersonalId,
      kAO_FIFO_EnableId                    = (tAO_Personal::kAO_FIFO_EnableId << 27) | kAO_PersonalId,
      kAO_TMRDACWR_Pulse_WidthId           = (tAO_Personal::kAO_TMRDACWR_Pulse_WidthId << 27) | kAO_PersonalId,
      kAO_Number_Of_DAC_PackagesId         = (tAO_Personal::kAO_Number_Of_DAC_PackagesId << 27) | kAO_PersonalId,
      kAO_Multiple_DACS_Per_PackageId      = (tAO_Personal::kAO_Multiple_DACS_Per_PackageId << 27) | kAO_PersonalId,

      kAO_START_SelectId                   = 28,
      kAO_START_SelectDefaultId                                  = (tAO_START_Select::kDefaultId << 27) | kAO_START_SelectId,
      kAO_START_EdgeId                     = (tAO_START_Select::kAO_START_EdgeId << 27) | kAO_START_SelectId,
      kAO_START_SyncId                     = (tAO_START_Select::kAO_START_SyncId << 27) | kAO_START_SelectId,
      kAO_AOFREQ_EnableId                  = (tAO_START_Select::kAO_AOFREQ_EnableId << 27) | kAO_START_SelectId,
      kAO_START_PolarityId                 = (tAO_START_Select::kAO_START_PolarityId << 27) | kAO_START_SelectId,

      kAO_Status_2Id                       = 29,
      kAO_BC_Armed_StId                    = (tAO_Status_2::kAO_BC_Armed_StId << 27) | kAO_Status_2Id,
      kAO_BC_Save_StId                     = (tAO_Status_2::kAO_BC_Save_StId << 27) | kAO_Status_2Id,
      kAO_BC_Q_StId                        = (tAO_Status_2::kAO_BC_Q_StId << 27) | kAO_Status_2Id,
      kAO_BC_TC_Trigger_Error_StId         = (tAO_Status_2::kAO_BC_TC_Trigger_Error_StId << 27) | kAO_Status_2Id,
      kAO_UI_Armed_StId                    = (tAO_Status_2::kAO_UI_Armed_StId << 27) | kAO_Status_2Id,
      kAO_UI_Next_Load_Source_StId         = (tAO_Status_2::kAO_UI_Next_Load_Source_StId << 27) | kAO_Status_2Id,
      kAO_UC_Save_StId                     = (tAO_Status_2::kAO_UC_Save_StId << 27) | kAO_Status_2Id,
      kAO_UI_Count_Enabled_StId            = (tAO_Status_2::kAO_UI_Count_Enabled_StId << 27) | kAO_Status_2Id,
      kAO_UI_Q_StId                        = (tAO_Status_2::kAO_UI_Q_StId << 27) | kAO_Status_2Id,
      kAO_UC_Armed_StId                    = (tAO_Status_2::kAO_UC_Armed_StId << 27) | kAO_Status_2Id,

      kAO_Status_1Id                       = 30,
      kPass_Thru_1_Interrupt_StId          = (tAO_Status_1::kPass_Thru_1_Interrupt_StId << 27) | kAO_Status_1Id,
      kAO_FIFO_Request_StId                = (tAO_Status_1::kAO_FIFO_Request_StId << 27) | kAO_Status_1Id,
      kG1_Gate_Interrupt_StId              = (tAO_Status_1::kG1_Gate_Interrupt_StId << 27) | kAO_Status_1Id,
      kG1_TC_StId                          = (tAO_Status_1::kG1_TC_StId << 27) | kAO_Status_1Id,
      kAO_UPDATE_StId                      = (tAO_Status_1::kAO_UPDATE_StId << 27) | kAO_Status_1Id,
      kAO_UC_TC_StId                       = (tAO_Status_1::kAO_UC_TC_StId << 27) | kAO_Status_1Id,
      kAO_BC_TC_StId                       = (tAO_Status_1::kAO_BC_TC_StId << 27) | kAO_Status_1Id,
      kAO_START1_StId                      = (tAO_Status_1::kAO_START1_StId << 27) | kAO_Status_1Id,
      kAO_Overrun_StId                     = (tAO_Status_1::kAO_Overrun_StId << 27) | kAO_Status_1Id,
      kAO_START_StId                       = (tAO_Status_1::kAO_START_StId << 27) | kAO_Status_1Id,
      kAO_BC_TC_Error_StId                 = (tAO_Status_1::kAO_BC_TC_Error_StId << 27) | kAO_Status_1Id,
      kAO_FIFO_Empty_StId                  = (tAO_Status_1::kAO_FIFO_Empty_StId << 27) | kAO_Status_1Id,
      kAO_FIFO_Half_Full_StId              = (tAO_Status_1::kAO_FIFO_Half_Full_StId << 27) | kAO_Status_1Id,
      kAO_FIFO_Full_StId                   = (tAO_Status_1::kAO_FIFO_Full_StId << 27) | kAO_Status_1Id,
      kInterrupt_Group_B_StatusId          = (tAO_Status_1::kInterrupt_Group_B_StatusId << 27) | kAO_Status_1Id,

      kAO_Trigger_SelectId                 = 31,
      kAO_START1_SelectId                  = (tAO_Trigger_Select::kAO_START1_SelectId << 27) | kAO_Trigger_SelectId,
      kAO_START1_EdgeId                    = (tAO_Trigger_Select::kAO_START1_EdgeId << 27) | kAO_Trigger_SelectId,
      kAO_START1_SyncId                    = (tAO_Trigger_Select::kAO_START1_SyncId << 27) | kAO_Trigger_SelectId,
      kAO_START1_PolarityId                = (tAO_Trigger_Select::kAO_START1_PolarityId << 27) | kAO_Trigger_SelectId,
      kAO_Delayed_START1Id                 = (tAO_Trigger_Select::kAO_Delayed_START1Id << 27) | kAO_Trigger_SelectId,

      kAO_UC_Load_AId                      = 32,
      kAO_UC_Load_ADefaultId                                  = (tAO_UC_Load_A::kDefaultId << 27) | kAO_UC_Load_AId,

      kAO_UC_Load_BId                      = 33,
      kAO_UC_Load_BDefaultId                                  = (tAO_UC_Load_B::kDefaultId << 27) | kAO_UC_Load_BId,

      kAO_UC_SaveId                        = 34,
      kAO_UC_SaveDefaultId                                  = (tAO_UC_Save::kDefaultId << 27) | kAO_UC_SaveId,

      kAO_UI_Load_AId                      = 35,
      kAO_UI_Load_ADefaultId                                  = (tAO_UI_Load_A::kDefaultId << 27) | kAO_UI_Load_AId,

      kAO_UI_Load_BId                      = 36,
      kAO_UI_Load_BDefaultId                                  = (tAO_UI_Load_B::kDefaultId << 27) | kAO_UI_Load_BId,

      kAO_UI_SaveId                        = 37,
      kAO_UI_SaveDefaultId                                  = (tAO_UI_Save::kDefaultId << 27) | kAO_UI_SaveId,

      kClock_and_FOUTId                    = 38,
      kFOUT_DividerId                      = (tClock_and_FOUT::kFOUT_DividerId << 27) | kClock_and_FOUTId,
      kClock_To_BoardId                    = (tClock_and_FOUT::kClock_To_BoardId << 27) | kClock_and_FOUTId,
      kClock_To_Board_Divide_By_2Id        = (tClock_and_FOUT::kClock_To_Board_Divide_By_2Id << 27) | kClock_and_FOUTId,
      kSlow_Internal_TimebaseId            = (tClock_and_FOUT::kSlow_Internal_TimebaseId << 27) | kClock_and_FOUTId,
      kDIO_Serial_Out_Divide_By_2Id        = (tClock_and_FOUT::kDIO_Serial_Out_Divide_By_2Id << 27) | kClock_and_FOUTId,
      kFOUT_Timebase_SelectId              = (tClock_and_FOUT::kFOUT_Timebase_SelectId << 27) | kClock_and_FOUTId,
      kFOUT_EnableId                       = (tClock_and_FOUT::kFOUT_EnableId << 27) | kClock_and_FOUTId,

      kInterrupt_A_AckId                   = 39,
      kG0_Gate_Error_ConfirmId             = (tInterrupt_A_Ack::kG0_Gate_Error_ConfirmId << 27) | kInterrupt_A_AckId,
      kG0_TC_Error_ConfirmId               = (tInterrupt_A_Ack::kG0_TC_Error_ConfirmId << 27) | kInterrupt_A_AckId,
      kAI_SC_TC_Error_ConfirmId            = (tInterrupt_A_Ack::kAI_SC_TC_Error_ConfirmId << 27) | kInterrupt_A_AckId,
      kAI_SC_TC_Interrupt_AckId            = (tInterrupt_A_Ack::kAI_SC_TC_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kAI_START1_Interrupt_AckId           = (tInterrupt_A_Ack::kAI_START1_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kAI_START2_Interrupt_AckId           = (tInterrupt_A_Ack::kAI_START2_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kAI_START_Interrupt_AckId            = (tInterrupt_A_Ack::kAI_START_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kAI_STOP_Interrupt_AckId             = (tInterrupt_A_Ack::kAI_STOP_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kAI_Error_Interrupt_AckId            = (tInterrupt_A_Ack::kAI_Error_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kG0_TC_Interrupt_AckId               = (tInterrupt_A_Ack::kG0_TC_Interrupt_AckId << 27) | kInterrupt_A_AckId,
      kG0_Gate_Interrupt_AckId             = (tInterrupt_A_Ack::kG0_Gate_Interrupt_AckId << 27) | kInterrupt_A_AckId,

      kInterrupt_A_EnableId                = 40,
      kAI_SC_TC_Interrupt_EnableId         = (tInterrupt_A_Enable::kAI_SC_TC_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_START1_Interrupt_EnableId        = (tInterrupt_A_Enable::kAI_START1_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_START2_Interrupt_EnableId        = (tInterrupt_A_Enable::kAI_START2_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_START_Interrupt_EnableId         = (tInterrupt_A_Enable::kAI_START_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_STOP_Interrupt_EnableId          = (tInterrupt_A_Enable::kAI_STOP_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_Error_Interrupt_EnableId         = (tInterrupt_A_Enable::kAI_Error_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kG0_TC_Interrupt_EnableId            = (tInterrupt_A_Enable::kG0_TC_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kAI_FIFO_Interrupt_EnableId          = (tInterrupt_A_Enable::kAI_FIFO_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,
      kG0_Gate_Interrupt_EnableId          = (tInterrupt_A_Enable::kG0_Gate_Interrupt_EnableId << 27) | kInterrupt_A_EnableId,

      kInterrupt_B_AckId                   = 41,
      kG1_Gate_Error_ConfirmId             = (tInterrupt_B_Ack::kG1_Gate_Error_ConfirmId << 27) | kInterrupt_B_AckId,
      kG1_TC_Error_ConfirmId               = (tInterrupt_B_Ack::kG1_TC_Error_ConfirmId << 27) | kInterrupt_B_AckId,
      kAO_BC_TC_Trigger_Error_ConfirmId    = (tInterrupt_B_Ack::kAO_BC_TC_Trigger_Error_ConfirmId << 27) | kInterrupt_B_AckId,
      kAO_BC_TC_Error_ConfirmId            = (tInterrupt_B_Ack::kAO_BC_TC_Error_ConfirmId << 27) | kInterrupt_B_AckId,
      kAO_UC_TC_Interrupt_AckId            = (tInterrupt_B_Ack::kAO_UC_TC_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_BC_TC_Interrupt_AckId            = (tInterrupt_B_Ack::kAO_BC_TC_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_START1_Interrupt_AckId           = (tInterrupt_B_Ack::kAO_START1_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_UPDATE_Interrupt_AckId           = (tInterrupt_B_Ack::kAO_UPDATE_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_START_Interrupt_AckId            = (tInterrupt_B_Ack::kAO_START_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_STOP_Interrupt_AckId             = (tInterrupt_B_Ack::kAO_STOP_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kAO_Error_Interrupt_AckId            = (tInterrupt_B_Ack::kAO_Error_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kG1_TC_Interrupt_AckId               = (tInterrupt_B_Ack::kG1_TC_Interrupt_AckId << 27) | kInterrupt_B_AckId,
      kG1_Gate_Interrupt_AckId             = (tInterrupt_B_Ack::kG1_Gate_Interrupt_AckId << 27) | kInterrupt_B_AckId,

      kInterrupt_ControlId                 = 42,
      kInterrupt_Group_A_EnableId          = (tInterrupt_Control::kInterrupt_Group_A_EnableId << 27) | kInterrupt_ControlId,
      kInterrupt_Group_B_EnableId          = (tInterrupt_Control::kInterrupt_Group_B_EnableId << 27) | kInterrupt_ControlId,

      kInterrupt_B_EnableId                = 43,
      kAO_BC_TC_Interrupt_EnableId         = (tInterrupt_B_Enable::kAO_BC_TC_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_START1_Interrupt_EnableId        = (tInterrupt_B_Enable::kAO_START1_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_UPDATE_Interrupt_EnableId        = (tInterrupt_B_Enable::kAO_UPDATE_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_START_Interrupt_EnableId         = (tInterrupt_B_Enable::kAO_START_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_STOP_Interrupt_EnableId          = (tInterrupt_B_Enable::kAO_STOP_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_Error_Interrupt_EnableId         = (tInterrupt_B_Enable::kAO_Error_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_UC_TC_Interrupt_EnableId         = (tInterrupt_B_Enable::kAO_UC_TC_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kAO_FIFO_Interrupt_EnableId          = (tInterrupt_B_Enable::kAO_FIFO_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kG1_TC_Interrupt_EnableId            = (tInterrupt_B_Enable::kG1_TC_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kG1_Gate_Interrupt_EnableId          = (tInterrupt_B_Enable::kG1_Gate_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,
      kPass_Thru_1_Interrupt_EnableId      = (tInterrupt_B_Enable::kPass_Thru_1_Interrupt_EnableId << 27) | kInterrupt_B_EnableId,

      kIO_Bidirection_PinId                = 44,
      kPFI0_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI0_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI1_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI1_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI2_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI2_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI3_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI3_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI4_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI4_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI5_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI5_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI6_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI6_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI7_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI7_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI8_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI8_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI9_Pin_DirId                      = (tIO_Bidirection_Pin::kPFI9_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI10_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI10_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI11_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI11_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI12_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI12_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI13_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI13_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI14_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI14_Pin_DirId << 27) | kIO_Bidirection_PinId,
      kPFI15_Pin_DirId                     = (tIO_Bidirection_Pin::kPFI15_Pin_DirId << 27) | kIO_Bidirection_PinId,

      kJoint_ResetId                       = 45,
      kAI_ResetId                          = (tJoint_Reset::kAI_ResetId << 27) | kJoint_ResetId,
      kAO_ResetId                          = (tJoint_Reset::kAO_ResetId << 27) | kJoint_ResetId,
      kG0_ResetId                          = (tJoint_Reset::kG0_ResetId << 27) | kJoint_ResetId,
      kG1_ResetId                          = (tJoint_Reset::kG1_ResetId << 27) | kJoint_ResetId,
      kAI_Configuration_StartId            = (tJoint_Reset::kAI_Configuration_StartId << 27) | kJoint_ResetId,
      kAO_Configuration_StartId            = (tJoint_Reset::kAO_Configuration_StartId << 27) | kJoint_ResetId,
      kAI_Configuration_EndId              = (tJoint_Reset::kAI_Configuration_EndId << 27) | kJoint_ResetId,
      kAO_Configuration_EndId              = (tJoint_Reset::kAO_Configuration_EndId << 27) | kJoint_ResetId,
      kSoftware_ResetId                    = (tJoint_Reset::kSoftware_ResetId << 27) | kJoint_ResetId,

      kJoint_Status_2Id                    = 46,
      kG0_Output_StId                      = (tJoint_Status_2::kG0_Output_StId << 27) | kJoint_Status_2Id,
      kG1_Output_StId                      = (tJoint_Status_2::kG1_Output_StId << 27) | kJoint_Status_2Id,
      kAO_STOP_StId                        = (tJoint_Status_2::kAO_STOP_StId << 27) | kJoint_Status_2Id,
      kAI_EOC_StId                         = (tJoint_Status_2::kAI_EOC_StId << 27) | kJoint_Status_2Id,
      kAO_TMRDACWRs_In_Progress_StId       = (tJoint_Status_2::kAO_TMRDACWRs_In_Progress_StId << 27) | kJoint_Status_2Id,
      kAI_Config_Memory_Empty_StId         = (tJoint_Status_2::kAI_Config_Memory_Empty_StId << 27) | kJoint_Status_2Id,
      kAI_Scan_In_Progress_StId            = (tJoint_Status_2::kAI_Scan_In_Progress_StId << 27) | kJoint_Status_2Id,
      kGeneric_StatusId                    = (tJoint_Status_2::kGeneric_StatusId << 27) | kJoint_Status_2Id,
      kG0_HW_Save_StId                     = (tJoint_Status_2::kG0_HW_Save_StId << 27) | kJoint_Status_2Id,
      kG1_HW_Save_StId                     = (tJoint_Status_2::kG1_HW_Save_StId << 27) | kJoint_Status_2Id,
      kG0_Permanent_Stale_Data_StId        = (tJoint_Status_2::kG0_Permanent_Stale_Data_StId << 27) | kJoint_Status_2Id,
      kG1_Permanent_Stale_Data_StId        = (tJoint_Status_2::kG1_Permanent_Stale_Data_StId << 27) | kJoint_Status_2Id,

      kJoint_Status_1Id                    = 47,
      kG0_Bank_StId                        = (tJoint_Status_1::kG0_Bank_StId << 27) | kJoint_Status_1Id,
      kG1_Bank_StId                        = (tJoint_Status_1::kG1_Bank_StId << 27) | kJoint_Status_1Id,
      kG0_Gate_StId                        = (tJoint_Status_1::kG0_Gate_StId << 27) | kJoint_Status_1Id,
      kG1_Gate_StId                        = (tJoint_Status_1::kG1_Gate_StId << 27) | kJoint_Status_1Id,
      kAI_SC_Gate_StId                     = (tJoint_Status_1::kAI_SC_Gate_StId << 27) | kJoint_Status_1Id,
      kAI_Start_Stop_Gate_StId             = (tJoint_Status_1::kAI_Start_Stop_Gate_StId << 27) | kJoint_Status_1Id,
      kAO_BC_Gate_StId                     = (tJoint_Status_1::kAO_BC_Gate_StId << 27) | kJoint_Status_1Id,
      kAO_Start_Stop_Gate_StId             = (tJoint_Status_1::kAO_Start_Stop_Gate_StId << 27) | kJoint_Status_1Id,
      kAI_SI2_Q_StId                       = (tJoint_Status_1::kAI_SI2_Q_StId << 27) | kJoint_Status_1Id,
      kAI_External_Gate_StId               = (tJoint_Status_1::kAI_External_Gate_StId << 27) | kJoint_Status_1Id,
      kAO_External_Gate_StId               = (tJoint_Status_1::kAO_External_Gate_StId << 27) | kJoint_Status_1Id,
      kDIO_Serial_IO_In_Progress_StId      = (tJoint_Status_1::kDIO_Serial_IO_In_Progress_StId << 27) | kJoint_Status_1Id,
      kAO_UC_Q_StId                        = (tJoint_Status_1::kAO_UC_Q_StId << 27) | kJoint_Status_1Id,
      kAI_Last_Shiftin_StId                = (tJoint_Status_1::kAI_Last_Shiftin_StId << 27) | kJoint_Status_1Id,

      kRTSI_Shared_MUXId                   = 48,
      kRTSI_Shared_MUX_0_Output_SelectId   = (tRTSI_Shared_MUX::kRTSI_Shared_MUX_0_Output_SelectId << 27) | kRTSI_Shared_MUXId,
      kRTSI_Shared_MUX_1_Output_SelectId   = (tRTSI_Shared_MUX::kRTSI_Shared_MUX_1_Output_SelectId << 27) | kRTSI_Shared_MUXId,
      kRTSI_Shared_MUX_2_Output_SelectId   = (tRTSI_Shared_MUX::kRTSI_Shared_MUX_2_Output_SelectId << 27) | kRTSI_Shared_MUXId,
      kRTSI_Shared_MUX_3_Output_SelectId   = (tRTSI_Shared_MUX::kRTSI_Shared_MUX_3_Output_SelectId << 27) | kRTSI_Shared_MUXId,

      kRTSI_Trig_A_OutputId                = 49,
      kRTSI0_Output_SelectId               = (tRTSI_Trig_A_Output::kRTSI0_Output_SelectId << 27) | kRTSI_Trig_A_OutputId,
      kRTSI1_Output_SelectId               = (tRTSI_Trig_A_Output::kRTSI1_Output_SelectId << 27) | kRTSI_Trig_A_OutputId,
      kRTSI2_Output_SelectId               = (tRTSI_Trig_A_Output::kRTSI2_Output_SelectId << 27) | kRTSI_Trig_A_OutputId,
      kRTSI3_Output_SelectId               = (tRTSI_Trig_A_Output::kRTSI3_Output_SelectId << 27) | kRTSI_Trig_A_OutputId,

      kRTSI_Trig_DirectionId               = 50,
      kDrive_RTSI_OSCId                    = (tRTSI_Trig_Direction::kDrive_RTSI_OSCId << 27) | kRTSI_Trig_DirectionId,
      kUse_RTSI_OSCId                      = (tRTSI_Trig_Direction::kUse_RTSI_OSCId << 27) | kRTSI_Trig_DirectionId,
      kRTSI_Sub_Selection_1Id              = (tRTSI_Trig_Direction::kRTSI_Sub_Selection_1Id << 27) | kRTSI_Trig_DirectionId,
      kRTSI0_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI0_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI1_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI1_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI2_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI2_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI3_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI3_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI4_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI4_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI5_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI5_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI6_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI6_Pin_DirId << 27) | kRTSI_Trig_DirectionId,
      kRTSI7_Pin_DirId                     = (tRTSI_Trig_Direction::kRTSI7_Pin_DirId << 27) | kRTSI_Trig_DirectionId,

      kRTSI_Trig_B_OutputId                = 51,
      kRTSI4_Output_SelectId               = (tRTSI_Trig_B_Output::kRTSI4_Output_SelectId << 27) | kRTSI_Trig_B_OutputId,
      kRTSI5_Output_SelectId               = (tRTSI_Trig_B_Output::kRTSI5_Output_SelectId << 27) | kRTSI_Trig_B_OutputId,
      kRTSI6_Output_SelectId               = (tRTSI_Trig_B_Output::kRTSI6_Output_SelectId << 27) | kRTSI_Trig_B_OutputId,
      kRTSI7_Output_SelectId               = (tRTSI_Trig_B_Output::kRTSI7_Output_SelectId << 27) | kRTSI_Trig_B_OutputId,

      kG0_DMA_ConfigId                     = 52,
      kG0_DMA_EnableId                     = (tG0_DMA_Config::kG0_DMA_EnableId << 27) | kG0_DMA_ConfigId,
      kG0_DMA_WriteId                      = (tG0_DMA_Config::kG0_DMA_WriteId << 27) | kG0_DMA_ConfigId,
      kG0_DMA_Int_EnableId                 = (tG0_DMA_Config::kG0_DMA_Int_EnableId << 27) | kG0_DMA_ConfigId,
      kG0_DMA_ResetId                      = (tG0_DMA_Config::kG0_DMA_ResetId << 27) | kG0_DMA_ConfigId,
      kG0_DMA_BankSW_ErrorId               = (tG0_DMA_Config::kG0_DMA_BankSW_ErrorId << 27) | kG0_DMA_ConfigId,

      kG1_DMA_ConfigId                     = 53,
      kG1_DMA_EnableId                     = (tG1_DMA_Config::kG1_DMA_EnableId << 27) | kG1_DMA_ConfigId,
      kG1_DMA_WriteId                      = (tG1_DMA_Config::kG1_DMA_WriteId << 27) | kG1_DMA_ConfigId,
      kG1_DMA_Int_EnableId                 = (tG1_DMA_Config::kG1_DMA_Int_EnableId << 27) | kG1_DMA_ConfigId,
      kG1_DMA_ResetId                      = (tG1_DMA_Config::kG1_DMA_ResetId << 27) | kG1_DMA_ConfigId,
      kG1_DMA_BankSW_ErrorId               = (tG1_DMA_Config::kG1_DMA_BankSW_ErrorId << 27) | kG1_DMA_ConfigId,

      kG0_DMA_StatusId                     = 54,
      kG0_PstatId                          = (tG0_DMA_Status::kG0_PstatId << 27) | kG0_DMA_StatusId,
      kG0_DMA_ReadbankId                   = (tG0_DMA_Status::kG0_DMA_ReadbankId << 27) | kG0_DMA_StatusId,
      kG0_DRQ_Error_StId                   = (tG0_DMA_Status::kG0_DRQ_Error_StId << 27) | kG0_DMA_StatusId,
      kG0_DRQ_StId                         = (tG0_DMA_Status::kG0_DRQ_StId << 27) | kG0_DMA_StatusId,

      kG1_DMA_StatusId                     = 55,
      kG1_PstatId                          = (tG1_DMA_Status::kG1_PstatId << 27) | kG1_DMA_StatusId,
      kG1_DMA_ReadbankId                   = (tG1_DMA_Status::kG1_DMA_ReadbankId << 27) | kG1_DMA_StatusId,
      kG1_DRQ_Error_StId                   = (tG1_DMA_Status::kG1_DRQ_Error_StId << 27) | kG1_DMA_StatusId,
      kG1_DRQ_StId                         = (tG1_DMA_Status::kG1_DRQ_StId << 27) | kG1_DMA_StatusId,

      kCDIO_DMA_SelectId                   = 56,
      kCDI_DMA_SelectId                    = (tCDIO_DMA_Select::kCDI_DMA_SelectId << 27) | kCDIO_DMA_SelectId,
      kCDO_DMA_SelectId                    = (tCDIO_DMA_Select::kCDO_DMA_SelectId << 27) | kCDIO_DMA_SelectId,

      kSCXI_ControlId                      = 57,
      kSCXI_SW_SPIClkId                    = (tSCXI_Control::kSCXI_SW_SPIClkId << 27) | kSCXI_ControlId,
      kSCXI_Back_Plane_MISO_EnableId       = (tSCXI_Control::kSCXI_Back_Plane_MISO_EnableId << 27) | kSCXI_ControlId,
      kSCXI_Front_Panel_MISO_EnableId      = (tSCXI_Control::kSCXI_Front_Panel_MISO_EnableId << 27) | kSCXI_ControlId,
      kSCXI_IntrId                         = (tSCXI_Control::kSCXI_IntrId << 27) | kSCXI_ControlId,
      kSCXI_D_AId                          = (tSCXI_Control::kSCXI_D_AId << 27) | kSCXI_ControlId,
      kSCXI_HW_Serial_TimebaseId           = (tSCXI_Control::kSCXI_HW_Serial_TimebaseId << 27) | kSCXI_ControlId,
      kSCXI_HW_Serial_StartId              = (tSCXI_Control::kSCXI_HW_Serial_StartId << 27) | kSCXI_ControlId,
      kSCXI_HW_Serial_EnableId             = (tSCXI_Control::kSCXI_HW_Serial_EnableId << 27) | kSCXI_ControlId,

      kAI_Mode_1Id                         = 58,
      kAI_Trigger_OnceId                   = (tAI_Mode_1::kAI_Trigger_OnceId << 27) | kAI_Mode_1Id,
      kAI_ContinuousId                     = (tAI_Mode_1::kAI_ContinuousId << 27) | kAI_Mode_1Id,
      kAI_Start_StopId                     = (tAI_Mode_1::kAI_Start_StopId << 27) | kAI_Mode_1Id,
      kAI_SI_Source_PolarityId             = (tAI_Mode_1::kAI_SI_Source_PolarityId << 27) | kAI_Mode_1Id,
      kAI_CONVERT_Source_PolarityId        = (tAI_Mode_1::kAI_CONVERT_Source_PolarityId << 27) | kAI_Mode_1Id,
      kAI_SI_Source_SelectId               = (tAI_Mode_1::kAI_SI_Source_SelectId << 27) | kAI_Mode_1Id,
      kAI_CONVERT_Source_SelectId          = (tAI_Mode_1::kAI_CONVERT_Source_SelectId << 27) | kAI_Mode_1Id,

      kAI_DIV_Load_AId                     = 59,
      kAI_DIV_Load_ADefaultId                                  = (tAI_DIV_Load_A::kDefaultId << 27) | kAI_DIV_Load_AId,

      kSCXI_Serial_Data_InId               = 60,
      kSCXI_Data_InDefaultId                                  = (tSCXI_Serial_Data_In::kDefaultId << 27) | kSCXI_Serial_Data_InId,

      kSCXI_Serial_Data_OutId              = 61,
      kSCXI_Data_OutDefaultId                                  = (tSCXI_Serial_Data_Out::kDefaultId << 27) | kSCXI_Serial_Data_OutId,

      kSCXI_StatusId                       = 62,
      kSCXI_Shift_In_ProgId                = (tSCXI_Status::kSCXI_Shift_In_ProgId << 27) | kSCXI_StatusId,

      kSCXI_Output_EnableId                = 63,
      kSCXI_Dedicated_Output_EnableId      = (tSCXI_Output_Enable::kSCXI_Dedicated_Output_EnableId << 27) | kSCXI_Output_EnableId,
      kSCXI_Trig1_Output_EnableId          = (tSCXI_Output_Enable::kSCXI_Trig1_Output_EnableId << 27) | kSCXI_Output_EnableId,
      kSCXI_Trig0_Output_EnableId          = (tSCXI_Output_Enable::kSCXI_Trig0_Output_EnableId << 27) | kSCXI_Output_EnableId,
      kSCXI_Trig1_Output_SelectId          = (tSCXI_Output_Enable::kSCXI_Trig1_Output_SelectId << 27) | kSCXI_Output_EnableId,

      kSCXI_DIO_EnableId                   = 64,
      kSCXI_DIO_MOSI_EnableId              = (tSCXI_DIO_Enable::kSCXI_DIO_MOSI_EnableId << 27) | kSCXI_DIO_EnableId,
      kSCXI_DIO_D_A_EnableId               = (tSCXI_DIO_Enable::kSCXI_DIO_D_A_EnableId << 27) | kSCXI_DIO_EnableId,
      kSCXI_DIO_Intr_EnableId              = (tSCXI_DIO_Enable::kSCXI_DIO_Intr_EnableId << 27) | kSCXI_DIO_EnableId,

      kStatic_Digital_OutputId             = 65,
      kDODefaultId                                  = (tStatic_Digital_Output::kDefaultId << 27) | kStatic_Digital_OutputId,

      kStatic_Digital_InputId              = 66,
      kDIDefaultId                                  = (tStatic_Digital_Input::kDefaultId << 27) | kStatic_Digital_InputId,

      kDIO_DirectionId                     = 67,
      kDIO_DirectionDefaultId                                  = (tDIO_Direction::kDefaultId << 27) | kDIO_DirectionId,

      kAO_Serial_Interrupt_EnableId        = 68,
      kAO_MUDS_0_Interrupt_EnableId        = (tAO_Serial_Interrupt_Enable::kAO_MUDS_0_Interrupt_EnableId << 27) | kAO_Serial_Interrupt_EnableId,
      kAO_MUDS_1_Interrupt_EnableId        = (tAO_Serial_Interrupt_Enable::kAO_MUDS_1_Interrupt_EnableId << 27) | kAO_Serial_Interrupt_EnableId,
      kAO_MUDS_2_Interrupt_EnableId        = (tAO_Serial_Interrupt_Enable::kAO_MUDS_2_Interrupt_EnableId << 27) | kAO_Serial_Interrupt_EnableId,
      kAO_MUDS_3_Interrupt_EnableId        = (tAO_Serial_Interrupt_Enable::kAO_MUDS_3_Interrupt_EnableId << 27) | kAO_Serial_Interrupt_EnableId,

      kAO_Serial_Interrupt_AckId           = 69,
      kAO_MUDS_0_Interrupt_AckId           = (tAO_Serial_Interrupt_Ack::kAO_MUDS_0_Interrupt_AckId << 27) | kAO_Serial_Interrupt_AckId,
      kAO_MUDS_1_Interrupt_AckId           = (tAO_Serial_Interrupt_Ack::kAO_MUDS_1_Interrupt_AckId << 27) | kAO_Serial_Interrupt_AckId,
      kAO_MUDS_2_Interrupt_AckId           = (tAO_Serial_Interrupt_Ack::kAO_MUDS_2_Interrupt_AckId << 27) | kAO_Serial_Interrupt_AckId,
      kAO_MUDS_3_Interrupt_AckId           = (tAO_Serial_Interrupt_Ack::kAO_MUDS_3_Interrupt_AckId << 27) | kAO_Serial_Interrupt_AckId,

      kAO_Serial_Interrupt_StatusId        = 70,
      kAO_MUDS_0_Interrupt_StId            = (tAO_Serial_Interrupt_Status::kAO_MUDS_0_Interrupt_StId << 27) | kAO_Serial_Interrupt_StatusId,
      kAO_MUDS_1_Interrupt_StId            = (tAO_Serial_Interrupt_Status::kAO_MUDS_1_Interrupt_StId << 27) | kAO_Serial_Interrupt_StatusId,
      kAO_MUDS_2_Interrupt_StId            = (tAO_Serial_Interrupt_Status::kAO_MUDS_2_Interrupt_StId << 27) | kAO_Serial_Interrupt_StatusId,
      kAO_MUDS_3_Interrupt_StId            = (tAO_Serial_Interrupt_Status::kAO_MUDS_3_Interrupt_StId << 27) | kAO_Serial_Interrupt_StatusId,

      kInterrupt_C_EnableId                = 71,
      kInterrupt_Group_C_EnableId          = (tInterrupt_C_Enable::kInterrupt_Group_C_EnableId << 27) | kInterrupt_C_EnableId,

      kInterrupt_C_StatusId                = 72,
      kInterrupt_Group_C_StatusId          = (tInterrupt_C_Status::kInterrupt_Group_C_StatusId << 27) | kInterrupt_C_StatusId,

      kAnalog_Trigger_ControlId            = 73,
      kAnalog_Trigger_SelectId             = (tAnalog_Trigger_Control::kAnalog_Trigger_SelectId << 27) | kAnalog_Trigger_ControlId,

      kAI_FIFO_DataId                      = 74,
      kAI_FIFO_DataDefaultId                                  = (tAI_FIFO_Data::kDefaultId << 27) | kAI_FIFO_DataId,

      kAI_FIFO_ClearId                     = 75,
      kAI_FIFO_ClearDefaultId                                  = (tAI_FIFO_Clear::kDefaultId << 27) | kAI_FIFO_ClearId,

      kAI_AO_SelectId                      = 76,
      kAI_DMA_SelectId                     = (tAI_AO_Select::kAI_DMA_SelectId << 27) | kAI_AO_SelectId,
      kAO_DMA_SelectId                     = (tAI_AO_Select::kAO_DMA_SelectId << 27) | kAI_AO_SelectId,

      kAI_Config_FIFO_DataId               = 77,
      kAI_Config_ChannelId                 = (tAI_Config_FIFO_Data::kAI_Config_ChannelId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_BankId                    = (tAI_Config_FIFO_Data::kAI_Config_BankId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_Channel_TypeId            = (tAI_Config_FIFO_Data::kAI_Config_Channel_TypeId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_GainId                    = (tAI_Config_FIFO_Data::kAI_Config_GainId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_PolarityId                = (tAI_Config_FIFO_Data::kAI_Config_PolarityId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_DitherId                  = (tAI_Config_FIFO_Data::kAI_Config_DitherId << 27) | kAI_Config_FIFO_DataId,
      kAI_Config_Last_ChannelId            = (tAI_Config_FIFO_Data::kAI_Config_Last_ChannelId << 27) | kAI_Config_FIFO_DataId,

      kConfiguration_Memory_ClearId        = 78,
      kAI_Configuration_Memory_ClearDefaultId                                  = (tConfiguration_Memory_Clear::kDefaultId << 27) | kConfiguration_Memory_ClearId,

      kAO_FIFO_DataId                      = 79,
      kAO_FIFO_DataDefaultId                                  = (tAO_FIFO_Data::kDefaultId << 27) | kAO_FIFO_DataId,

      kAO_FIFO_ClearId                     = 80,
      kAO_FIFO_ClearDefaultId                                  = (tAO_FIFO_Clear::kDefaultId << 27) | kAO_FIFO_ClearId,

      kG0_G1_SelectId                      = 81,
      kG0_DMA_SelectId                     = (tG0_G1_Select::kG0_DMA_SelectId << 27) | kG0_G1_SelectId,
      kG1_DMA_SelectId                     = (tG0_G1_Select::kG1_DMA_SelectId << 27) | kG0_G1_SelectId,

      kMisc_CommandId                      = 82,
      kIntExtTrigId                        = (tMisc_Command::kIntExtTrigId << 27) | kMisc_CommandId,

      kAO_CalibrationId                    = 83,
      kAO_RefGroundId                      = (tAO_Calibration::kAO_RefGroundId << 27) | kAO_CalibrationId,

      kPFI_Output_Select_1Id               = 84,
      kPFI0_Output_SelectId                = (tPFI_Output_Select_1::kPFI0_Output_SelectId << 27) | kPFI_Output_Select_1Id,
      kPFI1_Output_SelectId                = (tPFI_Output_Select_1::kPFI1_Output_SelectId << 27) | kPFI_Output_Select_1Id,
      kPFI2_Output_SelectId                = (tPFI_Output_Select_1::kPFI2_Output_SelectId << 27) | kPFI_Output_Select_1Id,

      kPFI_Output_Select_2Id               = 85,
      kPFI3_Output_SelectId                = (tPFI_Output_Select_2::kPFI3_Output_SelectId << 27) | kPFI_Output_Select_2Id,
      kPFI4_Output_SelectId                = (tPFI_Output_Select_2::kPFI4_Output_SelectId << 27) | kPFI_Output_Select_2Id,
      kPFI5_Output_SelectId                = (tPFI_Output_Select_2::kPFI5_Output_SelectId << 27) | kPFI_Output_Select_2Id,

      kPFI_Output_Select_3Id               = 86,
      kPFI6_Output_SelectId                = (tPFI_Output_Select_3::kPFI6_Output_SelectId << 27) | kPFI_Output_Select_3Id,
      kPFI7_Output_SelectId                = (tPFI_Output_Select_3::kPFI7_Output_SelectId << 27) | kPFI_Output_Select_3Id,
      kPFI8_Output_SelectId                = (tPFI_Output_Select_3::kPFI8_Output_SelectId << 27) | kPFI_Output_Select_3Id,

      kPFI_Output_Select_4Id               = 87,
      kPFI9_Output_SelectId                = (tPFI_Output_Select_4::kPFI9_Output_SelectId << 27) | kPFI_Output_Select_4Id,
      kPFI10_Output_SelectId               = (tPFI_Output_Select_4::kPFI10_Output_SelectId << 27) | kPFI_Output_Select_4Id,
      kPFI11_Output_SelectId               = (tPFI_Output_Select_4::kPFI11_Output_SelectId << 27) | kPFI_Output_Select_4Id,

      kPFI_Output_Select_5Id               = 88,
      kPFI12_Output_SelectId               = (tPFI_Output_Select_5::kPFI12_Output_SelectId << 27) | kPFI_Output_Select_5Id,
      kPFI13_Output_SelectId               = (tPFI_Output_Select_5::kPFI13_Output_SelectId << 27) | kPFI_Output_Select_5Id,
      kPFI14_Output_SelectId               = (tPFI_Output_Select_5::kPFI14_Output_SelectId << 27) | kPFI_Output_Select_5Id,

      kPFI_Output_Select_6Id               = 89,
      kPFI15_Output_SelectId               = (tPFI_Output_Select_6::kPFI15_Output_SelectId << 27) | kPFI_Output_Select_6Id,

      kPFI_DIId                            = 90,
      kPFI_DIDefaultId                                  = (tPFI_DI::kDefaultId << 27) | kPFI_DIId,

      kPFI_DOId                            = 91,
      kLowerPortId                         = (tPFI_DO::kLowerPortId << 27) | kPFI_DOId,
      kUpperPortId                         = (tPFI_DO::kUpperPortId << 27) | kPFI_DOId,

      kPFI_FilterId                        = 92,
      kPFI0_Filter_SelectId                = (tPFI_Filter::kPFI0_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI1_Filter_SelectId                = (tPFI_Filter::kPFI1_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI2_Filter_SelectId                = (tPFI_Filter::kPFI2_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI3_Filter_SelectId                = (tPFI_Filter::kPFI3_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI4_Filter_SelectId                = (tPFI_Filter::kPFI4_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI5_Filter_SelectId                = (tPFI_Filter::kPFI5_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI6_Filter_SelectId                = (tPFI_Filter::kPFI6_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI7_Filter_SelectId                = (tPFI_Filter::kPFI7_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI8_Filter_SelectId                = (tPFI_Filter::kPFI8_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI9_Filter_SelectId                = (tPFI_Filter::kPFI9_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI10_Filter_SelectId               = (tPFI_Filter::kPFI10_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI11_Filter_SelectId               = (tPFI_Filter::kPFI11_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI12_Filter_SelectId               = (tPFI_Filter::kPFI12_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI13_Filter_SelectId               = (tPFI_Filter::kPFI13_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI14_Filter_SelectId               = (tPFI_Filter::kPFI14_Filter_SelectId << 27) | kPFI_FilterId,
      kPFI15_Filter_SelectId               = (tPFI_Filter::kPFI15_Filter_SelectId << 27) | kPFI_FilterId,

      kRTSI_FilterId                       = 93,
      kRTSI0_Filter_SelectId               = (tRTSI_Filter::kRTSI0_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI1_Filter_SelectId               = (tRTSI_Filter::kRTSI1_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI2_Filter_SelectId               = (tRTSI_Filter::kRTSI2_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI3_Filter_SelectId               = (tRTSI_Filter::kRTSI3_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI4_Filter_SelectId               = (tRTSI_Filter::kRTSI4_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI5_Filter_SelectId               = (tRTSI_Filter::kRTSI5_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI6_Filter_SelectId               = (tRTSI_Filter::kRTSI6_Filter_SelectId << 27) | kRTSI_FilterId,
      kRTSI7_Filter_SelectId               = (tRTSI_Filter::kRTSI7_Filter_SelectId << 27) | kRTSI_FilterId,

      kClock_And_Fout2Id                   = 94,
      kPLL_In_Source_SelectId              = (tClock_And_Fout2::kPLL_In_Source_SelectId << 27) | kClock_And_Fout2Id,
      kTB1_SelectId                        = (tClock_And_Fout2::kTB1_SelectId << 27) | kClock_And_Fout2Id,
      kTB3_SelectId                        = (tClock_And_Fout2::kTB3_SelectId << 27) | kClock_And_Fout2Id,
      kRTSI_Clock_FreqId                   = (tClock_And_Fout2::kRTSI_Clock_FreqId << 27) | kClock_And_Fout2Id,

      kPLL_ControlId                       = 95,
      kPLL_MultiplierId                    = (tPLL_Control::kPLL_MultiplierId << 27) | kPLL_ControlId,
      kPLL_DivisorId                       = (tPLL_Control::kPLL_DivisorId << 27) | kPLL_ControlId,
      kPLL_EnableId                        = (tPLL_Control::kPLL_EnableId << 27) | kPLL_ControlId,
      kPLL_VCO_ModeId                      = (tPLL_Control::kPLL_VCO_ModeId << 27) | kPLL_ControlId,

      kPLL_StatusId                        = 96,
      kPLL_LockedId                        = (tPLL_Status::kPLL_LockedId << 27) | kPLL_StatusId,

      kAI_Config_FIFO_BypassId             = 97,
      kAI_Bypass_ChannelId                 = (tAI_Config_FIFO_Bypass::kAI_Bypass_ChannelId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_BankId                    = (tAI_Config_FIFO_Bypass::kAI_Bypass_BankId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_Cal_Sel_PosId             = (tAI_Config_FIFO_Bypass::kAI_Bypass_Cal_Sel_PosId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_Cal_Sel_NegId             = (tAI_Config_FIFO_Bypass::kAI_Bypass_Cal_Sel_NegId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_Mode_MuxId                = (tAI_Config_FIFO_Bypass::kAI_Bypass_Mode_MuxId << 27) | kAI_Config_FIFO_BypassId,
      kAO_Bypass_AO_Cal_SelId              = (tAI_Config_FIFO_Bypass::kAO_Bypass_AO_Cal_SelId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_GainId                    = (tAI_Config_FIFO_Bypass::kAI_Bypass_GainId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_DitherId                  = (tAI_Config_FIFO_Bypass::kAI_Bypass_DitherId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_PolarityId                = (tAI_Config_FIFO_Bypass::kAI_Bypass_PolarityId << 27) | kAI_Config_FIFO_BypassId,
      kAI_Bypass_Config_FIFOId             = (tAI_Config_FIFO_Bypass::kAI_Bypass_Config_FIFOId << 27) | kAI_Config_FIFO_BypassId,

      kCDI_FIFO_DataId                     = 98,
      kCDI_FIFO_DataDefaultId                                  = (tCDI_FIFO_Data::kDefaultId << 27) | kCDI_FIFO_DataId,

      kCDO_FIFO_DataId                     = 99,
      kCDO_FIFO_DataDefaultId                                  = (tCDO_FIFO_Data::kDefaultId << 27) | kCDO_FIFO_DataId,

      kCDIO_StatusId                       = 100,
      kCDO_FIFO_Empty_StId                 = (tCDIO_Status::kCDO_FIFO_Empty_StId << 27) | kCDIO_StatusId,
      kCDO_FIFO_Full_StId                  = (tCDIO_Status::kCDO_FIFO_Full_StId << 27) | kCDIO_StatusId,
      kCDO_FIFO_Request_StId               = (tCDIO_Status::kCDO_FIFO_Request_StId << 27) | kCDIO_StatusId,
      kCDO_Overrun_StId                    = (tCDIO_Status::kCDO_Overrun_StId << 27) | kCDIO_StatusId,
      kCDO_Underflow_StId                  = (tCDIO_Status::kCDO_Underflow_StId << 27) | kCDIO_StatusId,
      kCDI_FIFO_Empty_StId                 = (tCDIO_Status::kCDI_FIFO_Empty_StId << 27) | kCDIO_StatusId,
      kCDI_FIFO_Full_StId                  = (tCDIO_Status::kCDI_FIFO_Full_StId << 27) | kCDIO_StatusId,
      kCDI_FIFO_Request_StId               = (tCDIO_Status::kCDI_FIFO_Request_StId << 27) | kCDIO_StatusId,
      kCDI_Overrun_StId                    = (tCDIO_Status::kCDI_Overrun_StId << 27) | kCDIO_StatusId,
      kCDI_Overflow_StId                   = (tCDIO_Status::kCDI_Overflow_StId << 27) | kCDIO_StatusId,

      kCDIO_CommandId                      = 101,
      kCDO_DisarmId                        = (tCDIO_Command::kCDO_DisarmId << 27) | kCDIO_CommandId,
      kCDO_ArmId                           = (tCDIO_Command::kCDO_ArmId << 27) | kCDIO_CommandId,
      kCDI_DisarmId                        = (tCDIO_Command::kCDI_DisarmId << 27) | kCDIO_CommandId,
      kCDI_ArmId                           = (tCDIO_Command::kCDI_ArmId << 27) | kCDIO_CommandId,
      kCDO_ResetId                         = (tCDIO_Command::kCDO_ResetId << 27) | kCDIO_CommandId,
      kCDI_ResetId                         = (tCDIO_Command::kCDI_ResetId << 27) | kCDIO_CommandId,
      kCDO_Error_Interrupt_Enable_SetId    = (tCDIO_Command::kCDO_Error_Interrupt_Enable_SetId << 27) | kCDIO_CommandId,
      kCDO_Error_Interrupt_Enable_ClearId  = (tCDIO_Command::kCDO_Error_Interrupt_Enable_ClearId << 27) | kCDIO_CommandId,
      kCDI_Error_Interrupt_Enable_SetId    = (tCDIO_Command::kCDI_Error_Interrupt_Enable_SetId << 27) | kCDIO_CommandId,
      kCDI_Error_Interrupt_Enable_ClearId  = (tCDIO_Command::kCDI_Error_Interrupt_Enable_ClearId << 27) | kCDIO_CommandId,
      kCDO_FIFO_Request_Interrupt_Enable_SetId       = (tCDIO_Command::kCDO_FIFO_Request_Interrupt_Enable_SetId << 27) | kCDIO_CommandId,
      kCDO_FIFO_Request_Interrupt_Enable_ClearId         = (tCDIO_Command::kCDO_FIFO_Request_Interrupt_Enable_ClearId << 27) | kCDIO_CommandId,
      kCDI_FIFO_Request_Interrupt_Enable_SetId       = (tCDIO_Command::kCDI_FIFO_Request_Interrupt_Enable_SetId << 27) | kCDIO_CommandId,
      kCDI_FIFO_Request_Interrupt_Enable_ClearId         = (tCDIO_Command::kCDI_FIFO_Request_Interrupt_Enable_ClearId << 27) | kCDIO_CommandId,
      kCDO_Error_Interrupt_ConfirmId       = (tCDIO_Command::kCDO_Error_Interrupt_ConfirmId << 27) | kCDIO_CommandId,
      kCDI_Error_Interrupt_ConfirmId       = (tCDIO_Command::kCDI_Error_Interrupt_ConfirmId << 27) | kCDIO_CommandId,
      kCDO_Empty_FIFO_Interrupt_Enable_SetId     = (tCDIO_Command::kCDO_Empty_FIFO_Interrupt_Enable_SetId << 27) | kCDIO_CommandId,
      kCDO_Empty_FIFO_Interrupt_Enable_ClearId       = (tCDIO_Command::kCDO_Empty_FIFO_Interrupt_Enable_ClearId << 27) | kCDIO_CommandId,
      kCDO_SW_UpdateId                     = (tCDIO_Command::kCDO_SW_UpdateId << 27) | kCDIO_CommandId,
      kCDI_SW_SampleId                     = (tCDIO_Command::kCDI_SW_SampleId << 27) | kCDIO_CommandId,

      kCDI_ModeId                          = 102,
      kCDI_Sample_Source_SelectId          = (tCDI_Mode::kCDI_Sample_Source_SelectId << 27) | kCDI_ModeId,
      kCDI_Halt_On_ErrorId                 = (tCDI_Mode::kCDI_Halt_On_ErrorId << 27) | kCDI_ModeId,
      kCDI_PolarityId                      = (tCDI_Mode::kCDI_PolarityId << 27) | kCDI_ModeId,
      kCDI_FIFO_ModeId                     = (tCDI_Mode::kCDI_FIFO_ModeId << 27) | kCDI_ModeId,
      kCDI_Data_LaneId                     = (tCDI_Mode::kCDI_Data_LaneId << 27) | kCDI_ModeId,

      kCDO_ModeId                          = 103,
      kCDO_Update_Source_SelectId          = (tCDO_Mode::kCDO_Update_Source_SelectId << 27) | kCDO_ModeId,
      kCDO_RetransmitId                    = (tCDO_Mode::kCDO_RetransmitId << 27) | kCDO_ModeId,
      kCDO_Halt_On_ErrorId                 = (tCDO_Mode::kCDO_Halt_On_ErrorId << 27) | kCDO_ModeId,
      kCDO_PolarityId                      = (tCDO_Mode::kCDO_PolarityId << 27) | kCDO_ModeId,
      kCDO_FIFO_ModeId                     = (tCDO_Mode::kCDO_FIFO_ModeId << 27) | kCDO_ModeId,
      kCDO_Data_LaneId                     = (tCDO_Mode::kCDO_Data_LaneId << 27) | kCDO_ModeId,

      kCDI_Mask_EnableId                   = 104,
      kCDI_MaskDefaultId                                  = (tCDI_Mask_Enable::kDefaultId << 27) | kCDI_Mask_EnableId,

      kCDO_Mask_EnableId                   = 105,
      kCDO_MaskDefaultId                                  = (tCDO_Mask_Enable::kDefaultId << 27) | kCDO_Mask_EnableId,

      kSCXI_Legacy_CompatibilityId         = 106,
      kSCXI_Force_AI_EXTMUX_CLK_WidthId    = (tSCXI_Legacy_Compatibility::kSCXI_Force_AI_EXTMUX_CLK_WidthId << 27) | kSCXI_Legacy_CompatibilityId,

      kDIO_Reserved_0Id                    = 107,
      kDIO_Reserved_0ValueId                             = (tDIO_Reserved_0::kValueId << 27) | kDIO_Reserved_0Id,

      kDIO_Reserved_1Id                    = 108,
      kDIO_Reserved_1ValueId                             = (tDIO_Reserved_1::kValueId << 27) | kDIO_Reserved_1Id,

      kDIO_Reserved_2Id                    = 109,
      kDIO_Reserved_2ValueId                             = (tDIO_Reserved_2::kValueId << 27) | kDIO_Reserved_2Id,

      kDIO_Reserved_3Id                    = 110,
      kDIO_Reserved_3ValueId                             = (tDIO_Reserved_3::kValueId << 27) | kDIO_Reserved_3Id,

      kDIO_Reserved_4Id                    = 111,
      kDIO_Reserved_4ValueId                             = (tDIO_Reserved_4::kValueId << 27) | kDIO_Reserved_4Id,

      kDIO_Reserved_5Id                    = 112,
      kDIO_Reserved_5ValueId                             = (tDIO_Reserved_5::kValueId << 27) | kDIO_Reserved_5Id,

      kDIO_Reserved_6Id                    = 113,
      kDIO_Reserved_6ValueId                             = (tDIO_Reserved_6::kValueId << 27) | kDIO_Reserved_6Id,

      kDIO_Reserved_7Id                    = 114,
      kDIO_Reserved_7ValueId                             = (tDIO_Reserved_7::kValueId << 27) | kDIO_Reserved_7Id,

      kLB_Reserved_0Id                     = 115,
      kLB_Reserved_0Value0Id                            = (tLB_Reserved_0::kValue0Id << 27) | kLB_Reserved_0Id,
      kLB_Reserved_0Value1Id                            = (tLB_Reserved_0::kValue1Id << 27) | kLB_Reserved_0Id,

      kLB_Reserved_1Id                     = 116,
      kLB_Reserved_1ValueId                             = (tLB_Reserved_1::kValueId << 27) | kLB_Reserved_1Id,

      kAO_Waveform_Order0Id                = 117,
      kDAC0AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order0Id,

      kAO_Waveform_Order1Id                = 118,
      kDAC1AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order1Id,

      kAO_Waveform_Order2Id                = 119,
      kDAC2AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order2Id,

      kAO_Waveform_Order3Id                = 120,
      kDAC3AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order3Id,

      kAO_Waveform_Order4Id                = 121,
      kDAC4AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order4Id,

      kAO_Waveform_Order5Id                = 122,
      kDAC5AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order5Id,

      kAO_Waveform_Order6Id                = 123,
      kDAC6AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order6Id,

      kAO_Waveform_Order7Id                = 124,
      kDAC7AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order7Id,

      kAO_Waveform_Order8Id                = 125,
      kDAC8AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order8Id,

      kAO_Waveform_Order9Id                = 126,
      kDAC9AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order9Id,

      kAO_Waveform_Order10Id               = 127,
      kDAC10AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order10Id,

      kAO_Waveform_Order11Id               = 128,
      kDAC11AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order11Id,

      kAO_Waveform_Order12Id               = 129,
      kDAC12AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order12Id,

      kAO_Waveform_Order13Id               = 130,
      kDAC13AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order13Id,

      kAO_Waveform_Order14Id               = 131,
      kDAC14AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order14Id,

      kAO_Waveform_Order15Id               = 132,
      kDAC15AO_Waveform_OrderDefaultId                                  = (tAO_Waveform_Order::kDefaultId << 27) | kAO_Waveform_Order15Id,

      kAO_Config_Bank0Id                   = 133,
      kBank0AO_DAC_Offset_SelectId              = (tAO_Config_Bank::kAO_DAC_Offset_SelectId << 27) | kAO_Config_Bank0Id,
      kBank0AO_DAC_Reference_SelectId           = (tAO_Config_Bank::kAO_DAC_Reference_SelectId << 27) | kAO_Config_Bank0Id,
      kBank0AO_Update_ModeId                    = (tAO_Config_Bank::kAO_Update_ModeId << 27) | kAO_Config_Bank0Id,
      kBank0AO_DAC_PolarityId                   = (tAO_Config_Bank::kAO_DAC_PolarityId << 27) | kAO_Config_Bank0Id,

      kAO_Config_Bank1Id                   = 134,
      kBank1AO_DAC_Offset_SelectId              = (tAO_Config_Bank::kAO_DAC_Offset_SelectId << 27) | kAO_Config_Bank1Id,
      kBank1AO_DAC_Reference_SelectId           = (tAO_Config_Bank::kAO_DAC_Reference_SelectId << 27) | kAO_Config_Bank1Id,
      kBank1AO_Update_ModeId                    = (tAO_Config_Bank::kAO_Update_ModeId << 27) | kAO_Config_Bank1Id,
      kBank1AO_DAC_PolarityId                   = (tAO_Config_Bank::kAO_DAC_PolarityId << 27) | kAO_Config_Bank1Id,

      kAO_Config_Bank2Id                   = 135,
      kBank2AO_DAC_Offset_SelectId              = (tAO_Config_Bank::kAO_DAC_Offset_SelectId << 27) | kAO_Config_Bank2Id,
      kBank2AO_DAC_Reference_SelectId           = (tAO_Config_Bank::kAO_DAC_Reference_SelectId << 27) | kAO_Config_Bank2Id,
      kBank2AO_Update_ModeId                    = (tAO_Config_Bank::kAO_Update_ModeId << 27) | kAO_Config_Bank2Id,
      kBank2AO_DAC_PolarityId                   = (tAO_Config_Bank::kAO_DAC_PolarityId << 27) | kAO_Config_Bank2Id,

      kAO_Config_Bank3Id                   = 136,
      kBank3AO_DAC_Offset_SelectId              = (tAO_Config_Bank::kAO_DAC_Offset_SelectId << 27) | kAO_Config_Bank3Id,
      kBank3AO_DAC_Reference_SelectId           = (tAO_Config_Bank::kAO_DAC_Reference_SelectId << 27) | kAO_Config_Bank3Id,
      kBank3AO_Update_ModeId                    = (tAO_Config_Bank::kAO_Update_ModeId << 27) | kAO_Config_Bank3Id,
      kBank3AO_DAC_PolarityId                   = (tAO_Config_Bank::kAO_DAC_PolarityId << 27) | kAO_Config_Bank3Id,

      kDAC0_Direct_DataId                  = 137,
      kDAC0Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC0_Direct_DataId,

      kDAC1_Direct_DataId                  = 138,
      kDAC1Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC1_Direct_DataId,

      kDAC2_Direct_DataId                  = 139,
      kDAC2Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC2_Direct_DataId,

      kDAC3_Direct_DataId                  = 140,
      kDAC3Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC3_Direct_DataId,

      kDAC4_Direct_DataId                  = 141,
      kDAC4Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC4_Direct_DataId,

      kDAC5_Direct_DataId                  = 142,
      kDAC5Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC5_Direct_DataId,

      kDAC6_Direct_DataId                  = 143,
      kDAC6Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC6_Direct_DataId,

      kDAC7_Direct_DataId                  = 144,
      kDAC7Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC7_Direct_DataId,

      kDAC8_Direct_DataId                  = 145,
      kDAC8Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC8_Direct_DataId,

      kDAC9_Direct_DataId                  = 146,
      kDAC9Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC9_Direct_DataId,

      kDAC10_Direct_DataId                 = 147,
      kDAC10Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC10_Direct_DataId,

      kDAC11_Direct_DataId                 = 148,
      kDAC11Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC11_Direct_DataId,

      kDAC12_Direct_DataId                 = 149,
      kDAC12Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC12_Direct_DataId,

      kDAC13_Direct_DataId                 = 150,
      kDAC13Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC13_Direct_DataId,

      kDAC14_Direct_DataId                 = 151,
      kDAC14Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC14_Direct_DataId,

      kDAC15_Direct_DataId                 = 152,
      kDAC15Direct_DataDefaultId                                  = (tDAC_Direct_Data::kDefaultId << 27) | kDAC15_Direct_DataId,

      kCal_PWMId                           = 153,
      kLow_TimeId                          = (tCal_PWM::kLow_TimeId << 27) | kCal_PWMId,
      kHigh_TimeId                         = (tCal_PWM::kHigh_TimeId << 27) | kCal_PWMId,

      kGen_PWM0Id                          = 154,
      kPWM0PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM0Id,

      kGen_PWM1Id                          = 155,
      kPWM1PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM1Id,

      kGen_PWM2Id                          = 156,
      kPWM2PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM2Id,

      kGen_PWM3Id                          = 157,
      kPWM3PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM3Id,

      kGen_PWM4Id                          = 158,
      kPWM4PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM4Id,

      kGen_PWM5Id                          = 159,
      kPWM5PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM5Id,

      kGen_PWM6Id                          = 160,
      kPWM6PWM_Duty_CycleDefaultId                                  = (tGen_PWM::kDefaultId << 27) | kGen_PWM6Id,

      kStatic_AI_Control0Id                = 161,
      kCtrl0AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control0Id,

      kStatic_AI_Control1Id                = 162,
      kCtrl1AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control1Id,

      kStatic_AI_Control2Id                = 163,
      kCtrl2AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control2Id,

      kStatic_AI_Control3Id                = 164,
      kCtrl3AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control3Id,

      kStatic_AI_Control4Id                = 165,
      kCtrl4AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control4Id,

      kStatic_AI_Control5Id                = 166,
      kCtrl5AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control5Id,

      kStatic_AI_Control6Id                = 167,
      kCtrl6AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control6Id,

      kStatic_AI_Control7Id                = 168,
      kCtrl7AI_AO_ControlDefaultId                                  = (tStatic_AI_Control::kDefaultId << 27) | kStatic_AI_Control7Id,


      kMaxRegisterId = 168

   } tId;

   tMSeries(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tMSeries();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline void flushBus(nMDBG::tStatus2* statusChain = NULL);
private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   tBoolean _deallocateBus;
   u32 _addressOffset;

};

#ifndef ___tMSeries_ipp___
#ifndef ___tMSeries_h_no_inline___
#include "tMSeries_auto.cpp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

